,all_awardings,archived,associated_award,author,author_flair_background_color,author_flair_css_class,author_flair_richtext,author_flair_template_id,author_flair_text,author_flair_text_color,author_flair_type,author_fullname,author_patreon_flair,author_premium,body,body_sha1,can_gild,collapsed,collapsed_because_crowd_control,collapsed_reason,collapsed_reason_code,comment_type,controversiality,created_utc,distinguished,gilded,gildings,id,is_submitter,link_id,locked,no_follow,parent_id,permalink,retrieved_utc,score,score_hidden,send_replies,stickied,subreddit,subreddit_id,subreddit_name_prefixed,subreddit_type,top_awarded_type,total_awards_received,treatment_tags,unrepliable_reason
0.0,[],False,,dbotton,,,[],,,,text,t2_ijymj,False,False,Give me a few minutes as getting ready to upload a video with full functioning CLOG Builder in operation :),42c923fe04a20fa0ca29d9cae8b896a2200f6820,True,False,,,,,0,1643214189,,0,{},hub727p,False,t3_s1itqi,False,True,t1_hub6spx,/r/lisp/comments/s1itqi/the_common_lisp_omnificent_gui_online_lisp/hub727p/,1643214202,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
1.0,[],False,,ian_mtl,,,[],,,,text,t2_mh8188k,False,False,"I'm psyched, will watch both videos tonight.",ec2c5ef24ec30702de84a5ff897f140cb0e6f6a5,True,False,,,,,0,1643214094,,0,{},hub6spx,False,t3_s1itqi,False,True,t1_hsc87er,/r/lisp/comments/s1itqi/the_common_lisp_omnificent_gui_online_lisp/hub6spx/,1643214115,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
2.0,[],False,,tdrhq,,,[],,,,text,t2_6xy9v,False,False,"What are the ""tools you already know"" for building the startup?  For instance, if you choose to use Java to write your backend, you'll probably be better served by writing in CL. If you choose, say, Node.js/Django it could be a tossup. Here's where CL shines: you can judge different languages with how fast you can iterate in those languages. That's the first derivative of your output. As you build infrastructure, that derivative goes up, because it's faster to build features. CL shines in this second derivative of output (mainly because of macros, reader macros etc.). So at time 0: dx for CL is probably lower than dx for node.js. But d\^2x for CL is much much higher than node.js, so at t=6months, CL will be more productive than node.js.

If you're trying to get your product out in the next 30 days, pick Node.js. If you think you're going to iterate a lot and try different things, pick CL.

For mobile, yeah, don't attempt Lisp if you're not already comfortable with it. I'm planning to embark on a new mobile project and I \*might\* choose to do it with Lispworks, but I'm not sure yet. (I've built mobile apps before, so I'm well aware of the trade-offs I'm making when making this choice though, I wouldn't recommend that for a CL-beginner)",c3aa54ac6864b0331405a5023586b2fd7f39ccd8,True,False,,,,,0,1643213784,,0,{},hub5y21,False,t3_sd3nwj,False,True,t3_sd3nwj,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/hub5y21/,1643213799,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
3.0,[],False,,agumonkey,,,[],,,,text,t2_62nu4,False,False,"true but macros require a serious abstraction level gap that is still hard to swallow for the mainstream (mainstream is still at jsx level)

CL repl is high grade but few lisps have fully featured repl (and the support for deep modification) AFAIR",8d4dc4035d78ded202c766d8ac24d04ea497bf66,True,False,,,,,0,1643212772,,0,{},hub385s,False,t3_sd3nwj,False,True,t1_huapw09,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/hub385s/,1643212791,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
4.0,[],False,,tdrhq,,,[],,,,text,t2_6xy9v,False,False,"This is my thoughts too. As much as I love Lisp, and use almost exclusively Lisp as a solo dev, I'm not sure I would enjoy working on another Lispers code base as much. I would rather read code in a language where the code style is more predictable (""one way of doing things"" etc.) Lisp is great for writing code, not necessarily reading code.",60a8164b96ec9a5b36ac5d86beeb470b3ddeaa2a,True,False,,,,,0,1643212722,,0,{},hub33ac,False,t3_sd3nwj,False,False,t1_hualp4w,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/hub33ac/,1643212738,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
5.0,[],False,,PerpetualRiot,,,[],,,,text,t2_ckfk4572,False,False,"&gt; And the tco is directly proportional to the number of significant lines of code (sloc), largely the technology makes no difference in that.

I can't find anything suggesting this claim. Rather, measures of cost per SLOC seem to make no attempt to distinguish the cost of different technologies, rather just very generalized prices -- but they vary *drastically* from company to company. Probably the biggest inference is that larger companies with larger codebases are paying more *per* SLOC. And nothing beyond that.",a7dfe8ac5d527161a04b33b573aa8bc920ca8ab8,True,False,,,,,0,1643209839,,0,{},huavisf,False,t3_sd3nwj,False,True,t1_huaomme,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/huavisf/,1643209856,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
6.0,[],False,,Sunlighter,,,[],,,,text,t2_42e5w,False,False,"Back when I was in college I discovered that Scheme was vastly more productive than Java. I was able to implement complex algorithms such as LR(1) parser generators in Scheme, even though they kept eluding me in Java and C++, and I think it was because Scheme is a lot less cluttered and stays out of the way. (Incidentally, I did not use macros at all in my Scheme code, and I still saw enormous benefits from using Scheme.)

Now I have many years of experience in the C# and dot-Net ecosystem, but in the past few months I've started playing with Common Lisp. Lisp is *much* more productive than C# just because it stays out of the way and lets me get straight to the point. Also, CL has *immediacy*, where you can modify a program while it is running, and see the result right away. This is like ""hot reload"" without all the limitations, and it's something that you don't get with just an interpreter prompt.

If you spend time learning Lisp, you will get that time back, and then some, when you use Lisp. Being able to move *quickly* is very valuable to a startup, and [Speed Matters](https://www.scattered-thoughts.net/writing/speed-matters/) in other ways as well. I think any kind of Lisp is going to give you a 10x speedup over a language like C# or Java, even though the latter are more common in industry.",a4583c22e2961ceaed490da3a4221540abb7ae4e,True,False,,,,,0,1643209522,,0,{},huauq2o,False,t3_sd3nwj,False,True,t3_sd3nwj,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/huauq2o/,1643209534,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
7.0,[],False,,PerpetualRiot,,,[],,,,text,t2_ckfk4572,False,False,"Sorry, that was supposed to be a quote of the previous poster.

My argument can probably be summarized that as the size of a project grows (especially in terms of team sizes), a language like Lisp becomes more expensive because the costs of coordinating ideas becomes greater. Ie. the cost increase proportional to the size of a team probably, in practice, increases faster than the costs proportional to the lines of code.

Type errors, macros making absolute messes, etc. are all much greater problems on larger projects with larger teams, but pose almost no challenge for teams of a lone developer or even a few developers. A single hacker was able to writer Rollercoaster Tycoon in assembly, while major companies put extreme costs into games written in C++. And it's always easier to grok your own code than someone else's code, unless you work with that person a lot.

Languages that are most successful at large companies seem to be those that enforce everyone to be on the same page, e.g. through static typing or reduced expressivity (I bet a major reason for the ubiquity of single dispatch comes down to how difficult it becomes to coordinate the expressive power multiple dispatch enables). C never could become a major applications language, which instead was dominated by Pascal, then Smalltalk, then Java. And Look at how successful Java and C# are -- OOP probably became so popular because it allows us to communicate concepts through code much more easily than imperative-alone languages).

Research shows that both static typing and dynamic typing ends up with about the same amount of bugs, however case study after case study seems to suggest static typing produces more success in a business context. Like I talked about before, I think this comes down to not-strictly-technical reasons, but how our minds interface with the code and the different social dynamics between small teams and large teams. (companies conducting case studies are usually going to be larger companies).",646e5785d057e7cd91642b12a970544d38924524,True,False,,,,,0,1643208901,,0,{},huat6me,False,t3_sd3nwj,False,False,t1_huapbq6,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/huat6me/,1643208916,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
8.0,[],False,,Ok-Trip-9201,,,[],,,,text,t2_go8h8pzg,False,False,"Thanks for the help guys, that fixed it.",cff0dae0dbbb806ce792e0967c60b5494b25b9bf,True,False,,,,,0,1643208806,,0,{},huasydu,True,t3_scpy64,False,True,t1_hu89gf5,/r/lisp/comments/scpy64/trouble_using_withslots_for_a_class_defined_in/huasydu/,1643208820,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
9.0,[],False,,Ok-Trip-9201,,,[],,,,text,t2_go8h8pzg,False,False,"Thanks for the help guys, unfortunately though now I'm getting another error. 

    There is no applicable method for the generic function
    #&lt;STANDARD-GENERIC-FUNCTION (SB-PCL::SLOT-ACCESSOR :GLOBAL RCF-TILE::TEXT SB-PCL::READER) (1)&gt;
  when called with arguments
    (NIL).
See also:
  The ANSI Standard, Section 7.6.6

removing `(format t ""~a"" rcf-tile::text)` makes the error go away. Any ideas?",577c1f4d7c5a5a35d19e9786c3193e1803a00da3,True,False,,,,,0,1643208412,,0,{},huarzr2,True,t3_scpy64,False,True,t1_hu89gf5,/r/lisp/comments/scpy64/trouble_using_withslots_for_a_class_defined_in/huarzr2/,1643208423,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
10.0,[],False,,Gold-Energy2175,,,[],,,,text,t2_f1mqvqm1,False,False,"&gt; One opinion I've come to believe: the ""super programmers"" are effective regardless of the technology they use. Learning Lisp won't automatically make you one of them.

Well yes. But crap programmers won't go to the effort of learning Lisp, part of the reason they are crap.

And a great programmer will be much, much more productive with great tools rather than crap ones.

Also, &gt;80% of the total cost of any system is in maintenance and operations, not development.",56669896bbfa5f47fef69beaec134716ca22486e,True,False,,,,,0,1643208236,,0,{},huarkhy,False,t3_sd3nwj,False,True,t1_huakkw6,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/huarkhy/,1643208247,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
11.0,[],False,,Gold-Energy2175,,,[],,,,text,t2_f1mqvqm1,False,False,Superman versus the US Army. Who do you think would win.,6db149badc30889e1315872862b44b949ebbfa69,True,False,,,,,0,1643208121,,0,{},huaralp,False,t3_sd3nwj,False,True,t1_hua8ako,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/huaralp/,1643208135,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
12.0,[],False,,vermiculus,,,[],,,,text,t2_5z3v8,False,False,"I put them together for a reason. In context, both development and maintenance requires developers familiar with the implementation.",7347b0d4ea44d4c6e914193e5e546f8356cd7a06,True,False,,,,,0,1643208108,,0,{},huar9f8,False,t3_sd3nwj,False,True,t1_huaomme,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/huar9f8/,1643208120,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
13.0,[],False,,daybreak-gibby,,,[],,,,text,t2_3i7ao4bs,False,False,"I agree. I don't know what it is about Lisp family programming languages, but they get to be shoe-horned into intellectual pursuit languages. You even see the idea in OP's question: learning lisp will make them a better a programmer.",d7ad1f85dc6d24eefc1eeb7f95b87a429ee74dfa,True,False,,,,,0,1643207875,,0,{},huaqpky,False,t3_sd3nwj,False,True,t1_huadud0,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/huaqpky/,1643207887,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
14.0,[],False,,Gold-Energy2175,,,[],,,,text,t2_f1mqvqm1,False,False,"This isn't a very good answer.

If you can build it using common tech then so can everyone else.

A way to gain competitive advantage is to use better tools or, even better, use better tools than can be used to build even better ones. Lisp is like that.

C, C++, Java, PHP, Python C# and all the other Algol languages are just not as good. The language is locked and you basically only have functions and if the way you want to extend the language isn't possible using a function (e.g. conditional evaluation of parameters) then you can't do it.",a958fa4a8ef4a17ae5989aabaa1c8f53bed03622,True,False,,,,,0,1643207865,,0,{},huaqopl,False,t3_sd3nwj,False,True,t1_hua5e1v,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/huaqopl/,1643207879,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
15.0,[],False,,Gold-Energy2175,,,[],,,,text,t2_f1mqvqm1,False,False,"closures are nice. but the really big advantage for all Lisps over all non-Lisps are the macro system, which relies upon code and data having the same structure.

And the repl.

No Algol language has either of those things -they might claim to have macros and a repl but the only thing they really have in common are the names.",e1a6fc834cc318cf5968832fe11034898046f003,True,False,,,,,0,1643207527,,0,{},huapw09,False,t3_sd3nwj,False,True,t1_hua8sy2,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/huapw09/,1643207541,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
16.0,[],False,,Gold-Energy2175,,,[],,,,text,t2_f1mqvqm1,False,False,"&gt;  it’s a question of how much money it costs to develop and maintain a product.

The flaw in this argument is that whilst it might initially cost more to develop in a new language, say Clojure, the operational costs will come right down because Lisps are much less verbose: you can do more with each SLOC, and operational cost, which swamp development costs, is directionally proportional to the number of SLOC.",dc90b2ff5c35f2c19177959dd1f86375ecd89e97,True,False,,,,,0,1643207285,,0,{},huapbq6,False,t3_sd3nwj,False,True,t1_hualp4w,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/huapbq6/,1643207304,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
17.0,[],False,,ZeoChill,,,[],,,,text,t2_7k16kmbb,False,True,"*I would suggest you read this first, by the legendary Peter Norvig (also an Old school lisper).*

*https://norvig.com/21-days.html*

*Many people always seem to be in a rush, but end up going nowhere fast. The best things take time and purposeful dedication to develop, whether it is being an exemplary leader or acquiring skills - as an exceptional Engineer, Artist or Architect. Time gives you experience which in turn polishes mastery.*

*I would suggest you look to a minimal lisp, one of lisp's many true daughters - Scheme.*

*1) Pickup ""The little Schemer"".*

*2) You could then proceed to ""The Seasoned Schemer""  or simply*

*3)  go ahead read it in tandem with ""Structure and Interpretation of Computer Programs (SICP)"".*

*This process will take you 3 - 7 months depending on your dedication, motivation and focus. What I can promise you is that as long as you live and do anything as an engineer. This period of time will always bring fond memories.*",864ebf4e464c890231371fb70a5fc16d7557fa50,True,False,,,,,0,1643207222,,0,{},huap6ho,False,t3_sd3nwj,False,True,t3_sd3nwj,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/huap6ho/,1643207237,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
18.0,[],False,,Gold-Energy2175,,,[],,,,text,t2_f1mqvqm1,False,False,"&gt; it’s a question of how much money it costs to develop and maintain a product.

Those are two separate things with maintenance being by far and away the largest cost: the usual rubric is that maintenance is 80% of the total cost of ownership.

And the cost of both development is proportional to the number of significant lines of code., largely the technology makes no difference.

So if, as is the case with Lisp (CL or Clojure for e.g.), if you can halve the cost of maintenance by doubling the cost to build then you should do it.",ea5de7a7ca3df780e485456ae739106258efcf26,True,False,,,,,0,1643206983,,0,{},huaomme,False,t3_sd3nwj,False,False,t1_hua6lxq,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/huaomme/,1643206996,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
19.0,[],False,,PerpetualRiot,,,[],,,,text,t2_ckfk4572,False,False,"That’s a decent reason for a team of 20+ devs to not use lisp for a new product. It really isn’t a question about how productive you can be in lisp vs. language X; it’s a question of how much money it costs to develop and maintain a product. Developers who know lisp well enough to use it professionally tend to be exceptional – and exceptional is expensive.

My hypothesis is that Lisp just simply isn't as suited for development with large teams as other languages. A part of it might be that you have to lean on ""less exceptional programmers"", but the on large projects, the costs are meta to programming, rather than the cost of programming itself. It's why statically typed languages are probably successful at large companies -- it forces people who approach programming in vastly different manners to use common design choices. Sure, there are options for typing in Lisp, but it's not as smooth as a language that's typed from the get-go. This is explicitly why Go was created -- to make sure all programming is done in a most common language as possible, *restricting* expression. It solves a lot of problems of meta-coding (not as in writing code that writes code, but the social, economic, etc. environment writing code happens in).

Lisp, I think, is probably very powerful for lone developers and small teams -- places where every new complicated macro, you're probably going to have a conversation about it over lunch, if not help write it yourself, so you can stay familiar with languages and ideas expressed through the code as they're added to the code base. And this flexibility and expressiveness lets you reduce concept-code impedance, maximizing what you can do in limited time. And only a few other languages, I think, permit such a low concept-code impedance, such as Smalltalk and APL.",202bfcb00dff004d5569d349afd3cabf2763f20f,True,False,,,,,0,1643205681,,0,{},hualp4w,False,t3_sd3nwj,False,True,t1_hua6lxq,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/hualp4w/,1643205696,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
20.0,[],False,,agumonkey,,,[],,,,text,t2_62nu4,False,False,"there's also parinfer

i never used anything beside paredit, because it was the first and it was such an undescribable feeling to get it, that out of love and tradition, I never considered the rest (even though they have solid arguments)",f6bdd0d7ce6b6f20ba3f9f03341bc17cd7ba22c8,True,False,,,,,0,1643205577,,0,{},hualgup,False,t3_sd3nwj,False,True,t1_huakvvv,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/hualgup/,1643205591,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
21.0,[],False,,hedgehog0,,,[],,,,text,t2_yjt5w,False,False,"""Lispy"" is also nice if someone finds ""paredit"" requiring too many key strokes.",07975f68617bc9640977b8c87067d1cb9498ad3c,True,False,,,,,0,1643205312,,0,{},huakvvv,False,t3_sd3nwj,False,False,t1_hua8sy2,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/huakvvv/,1643205322,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
22.0,[],False,,ForkInBrain,,,[],,,,text,t2_8kdde,False,False,"One opinion I've come to believe: the ""super programmers"" are effective regardless of the technology they use.  Learning Lisp won't automatically make you one of them.

Learn lisp.  Not for the practical benefits, but because it will expose you to ideas.  You're in UNI so there is still a chance your brain has not been corrupted by the dominant paradigm.  The basics won't take you long, and you will forever have an educated opinion on the matter.  As a CS student, also, it will be educational to learn just how much can be accomplished with language fundamentally based on just symbol bindings and cons cells.  It is a language that is simple yet capable of expressing very complex designs.

Start with the Gentle Introduction: https://www.cs.cmu.edu/~dst/LispBook/book.pdf  As a CS student this should be easy for you, but it might help to start from first principles, slowly introduced.  I, personally, found Common Lisp not a language best served by jumping in and hacking away making programs, but I had to un-learn many years of assumptions (C being my first language).  You might be different.

Then go to Paradigms of Artificial Intelligence Programming, by Peter Norvig.  I believe the PDF is free somewhere on the internet.  Get at least part way through.

At this point you'll know whether you like it or not.  Pay attention to what it feels like to do REPL driven development.

But, also, be honest about the endeavor.  Peter Norvig above switched his teaching to Python because students picked it up faster, and he could teach the same concepts more effectively.  Seriously, check out his Advent of Code solutions at https://github.com/norvig/pytudes -- he writes Python in a very lisp-like way.

Think of it this way: if lisp were demonstrably, and actually, better for developing most software it would be used more.  The entire world is not full of idiots choosing to use inferior tools because they don't like parenthesis.  Learning lisp today will either make it clear to you why this is so, or it will make you very confused, because you come to believe the lisp way is the best way but most people don't understand.  If the latter is the case for you, you will then have a greater understanding of what it is to be human.

P.S. I don't have a favorite programming language.  Each fills a niche, and some niches are bigger than others.",9c9a2777b38922018b40ef7ea4f2d4a36920f051,True,False,,,,,0,1643205173,,0,{},huakkw6,False,t3_sd3nwj,False,True,t3_sd3nwj,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/huakkw6/,1643205185,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
23.0,[],False,,agumonkey,,,[],,,,text,t2_62nu4,False,False,Yeah I won't disagree with you.,504f14ee093b91161748e685e9a62acce77bf3bc,True,False,,,,,0,1643204887,,0,{},huajyn2,False,t3_sd3nwj,False,True,t1_huajaps,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/huajyn2/,1643204898,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
24.0,[],False,,podgorniy,,,[],,,,text,t2_13ilu3,False,False,"&gt; For your first point: function oriented, macros, mutation-light codebase are smaller and cleaner, almost by construction. Which means they're easier to adapt to changing needs.

I understand logic behind the argument, it was appealing to me, and still is appealing to an extent. But not enough to advice going for a lisp other than mainstream language for a startup.

I don't see how it manifests in reality besides in a codebases supported by a single hacker person. As soon as the team grows and domain stops fitting into single head as well as solution model coded with lisp it becomes increasingly hard to find a place for a change, distinguish working app from broken and reconstruct model (like semantics of all those maps) the author had ad in their head when they wrote the code. Tests will help, but that's another skill and can of worms from startup perspective.

&gt; the language pushes for concision and abstraction

It pushes you there without giving tools to deal with the situation. Big freedom bring big responsibilities. One needs to be extra smart and experienced to deal with that. btw, I think that's the reason behind relatively high clojure wages: it's not about language rather about capabilities of people who can handle clojure.",0c5d34ce8cc75347edfea5660ad926bef38e4154,True,False,,,,,0,1643204573,,0,{},huajaps,False,t3_sd3nwj,False,True,t1_huacayv,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/huajaps/,1643204590,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
25.0,[],False,,metacontent,,,[],,,,text,t2_4e6ke,False,False,"DHH didnt build rails for the intellectual pursuit. Node wasn't built for that reason either. A million other apps all built in various languages for various purposes and none of them just simply yo be intellectual exercises.

If you consign yourself to only using lisp as an intellectual exercise then you are consigning youself to forever only be just another trend follower. 

It depends what you want to do. Do u want to put in your 40-50 hours a week at some company and that is it for the rest of your career, nothing wrong with it, that is the path the majority take. Probably stick with mainstream languages in that case.

Or do you want to create something that is your own, something unique and special. If so, don't limit yourself by thinking a less popular language just cant be used. Ruby wasnt that popular when Rails was built. 

There is absolutely no reason a new unique  killer app cant be written today in Lisp if you have a great idea and you implement it well and it successfully fills a niche.",abbf25020776c91e56803639891c9dea3f1dc838,True,False,,,,,0,1643201787,,0,{},huadud0,False,t3_sd3nwj,False,False,t1_hua5e1v,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/huadud0/,1643201805,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
26.0,[],False,,agumonkey,,,[],,,,text,t2_62nu4,False,False,"For your first point: function oriented, macros, mutation-light codebase are smaller and cleaner, almost by construction. Which means they're easier to adapt to changing needs.

For the second point, it's more cultural. I fail to imagine anybody writing code as shitty as I saw in PHP4 days. Actually I saw some not long ago, a dude writing python, same kind of method, piles and piles of subroutines effecting global structures in whatever ways, he could find the source of his bugs. I rewrote his code in functional style it was a few oneliners helpers ten the main logic was 10-20 LoC now. Bug free too. PHP was even worse, around 2009, wordpress 2nd most downloaded plugin (a tiny thing to add myspace/facebook icons to a page) source was many pages long of never ending loops all doing the same thing (copy paste I assume) but with slight tweaks. 30% was dead code, 30% was comment. Lispers are known to be smug, the language pushes for concision and abstraction [0], not verbose bug fest.

[0] which is a subtle art, you can also shoot yourself by overdoing this, macros especially",1b5b97b8c017175ee3a9cbc55136139a60f971d0,True,False,,,,,0,1643200941,,0,{},huacayv,False,t3_sd3nwj,False,True,t1_huaahgc,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/huacayv/,1643200958,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
27.0,[],False,,Decweb,,,[],,,,text,t2_7ntpstpe,False,False,"My most gratifying and/or financially rewarding software projects over many decades have all been based in lisp.
That includes projects that attempted to solve problems with piles of code in one language, only to discard it and come up with a successful and timely implementation in lisp.  Lisp is still unmatched for productivity.

People will crap all over lisp. It  won't fit their mental model of a viable tool chain.  So it may be that the best experience for it is in personal projects and startups, where you can do what works for you.

If you already use Java, one of the reasons java overcame its detractors in the early years was that the world has moved to a network oriented model of APIs, and java does very well there.  Lisp can do the same thing in a modern tool chain.  Got a microservice architecture? Lisp can power those services.

And of course one of the premier (and current) lisps is based on the JVM (Clojure), so you can have the best of both worlds.

Common Lisp is also still viable, but with less mind share and with slightly different fortes in computing.",609477c6383aeeb70931dc269f226a1ea977275f,True,False,,,,,0,1643200258,,0,{},huab458,False,t3_sd3nwj,False,True,t3_sd3nwj,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/huab458/,1643200275,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
28.0,[],False,,podgorniy,,,[],,,,text,t2_13ilu3,False,False,"I agree that html generation and metaprogramming capabilities are way nicer in lisps then in mainstream languages. As a webdeveloper I appreciate beauty of html and server (ring, pedestal) abstractions. But that's not what is needed for the startup: on needs ability to create features fast, adapt codebase to new requirements fast and scale teams. One won't get to that level bu just learning or adopting lisp. Lisp will actually stay in a way of the people who are not fluent with it, and go find enough of such people.

Why do you assume that lisp codebase will be different from ones you saw? Lisp has no inherit tools to lead developer creating better codebase, it purely relies on author's discipline. And then author will same level of discipline will produce good codebase in other languages.",086e14682bfe104f002faf81f9a7e39aec78b334,True,False,,,,,0,1643199887,,0,{},huaahgc,False,t3_sd3nwj,False,True,t1_hua8qq7,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/huaahgc/,1643199899,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
29.0,[],False,,agumonkey,,,[],,,,text,t2_62nu4,False,False,"A lot of lisp traits have filtered in the mainstream. closure oriented code mostly (and the consequential map/filter/reduce). Destructuring too. Null-coalescing thinking... Julia-lang even has macros (this was posted recently https://jkrumbiegel.com/pages/2021-06-07-macros-for-beginners/), rust-lang too.

I still like lisp, the history, the culture a bit (there's also 20000 papers from the 70s - 90s period worth reading, starting with lambda papers, shivers, danvy, gibbons)

try to hang out on live chat (IRC, slack) to see how people do things on the field",d26d57ec5fc2fc0571760b7f50534c9c33fe2ce9,True,False,,,,,0,1643198842,,0,{},hua8sy2,False,t3_sd3nwj,False,True,t3_sd3nwj,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/hua8sy2/,1643198858,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
30.0,[],False,,agumonkey,,,[],,,,text,t2_62nu4,False,False,"back in the days I can easily speculate mastering macros could make your live go from hell to heaven.

consider how much of todays webdev is having shortcuts to produce html trees, which was one reader macro away from most lispers at the time (few people talked about this in the recent years.

but I didn't work at viaweb, I just saw enough php/wordpress codebase in the 2000s to consider the opposite world",13037f2f612d403f6f03f80b3daabbe7f8bf4821,True,False,,,,,0,1643198802,,0,{},hua8qq7,False,t3_sd3nwj,False,True,t1_hua6t8j,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/hua8qq7/,1643198816,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
31.0,[],False,,infrul,,,[],,,,text,t2_wo39q9,False,False,Lisp will give you super powers but that's not the same thing as having an army to command.,76f68823e812c5fe98c885fdf5395fb1d007a4d3,True,False,,,,,0,1643198514,,0,{},hua8ako,False,t3_sd3nwj,False,True,t3_sd3nwj,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/hua8ako/,1643198526,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
32.0,[],False,,dzecniv,,,[],,,,text,t2_j6dwn,False,False,"I don't think I'm exceptional yet I use Lisp ""professionally"", in production, for a couple small-ish products (but real useful). I am not a 20+ devs company. Just wanna say that there is a large panel of situations where we can use Lisp in production. Solo devs, small teams, big teams…

&gt; So use the tool you want to use!

so much",77d1cba2da4aa51508c44585457c73aa7a68690f,True,False,,,,,0,1643197970,,0,{},hua7h0p,False,t3_sd3nwj,False,True,t1_hua6lxq,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/hua7h0p/,1643197986,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
33.0,[],False,,podgorniy,,,[],,,,text,t2_13ilu3,False,False,"&gt; Inspired by Paul Grahams essay about how his company Viaweb was written mostly in lisp and how because if this he was able to compete with larger dev teams

I have strong doubts that that's what caused his success. After about 15 years in webdev, and after learning clojure and reading things around lisps I don't see how lisp is superior to give that big leverage. Strong python/java developers will achieve same business results.

From startup perspective use something what will allow to scale (people) quickly. For some niches niche languages will do good (Whatsapp and erlang), some projects started php (facebook) or rails (github) but had to move to other ""scalable"" (i.e. java) solutions later.

Conclusion: use whatever will allow you to focus on the goal. Lisp is for enthusiasts and it is not giving magical powers when it comes to business.",f496c8142117b1d3f80a9b8d0517dd69f1a636b6,True,False,,,,,0,1643197528,,0,{},hua6t8j,False,t3_sd3nwj,False,True,t3_sd3nwj,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/hua6t8j/,1643197545,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
34.0,[],False,,vermiculus,,,[],,,,text,t2_5z3v8,False,False,"In all things, use the right tool for the job. If there is a larger ecosystem / larger community for an application you’d like to write, take that into account.

For personal productivity, where you control the deployment environment, lisp often can’t be beat (for me personally).

There’s another facet to this, though. 

There’s a reason most companies seem to lean away from lisp (and thus why there is comparatively little visibility in industry): it’s hard to find developers. That’s a decent reason for a team of 20+ devs to not use lisp for a new product. It really isn’t a question about how productive you can be in lisp vs. language X; it’s a question of how much money it costs to develop and maintain a product. Developers who know lisp well enough to use it professionally tend to be exceptional – and exceptional is expensive. I’ll add here that this point alone should pique your interest if you’re serious about being a generally-successful engineer (which is far more achievable and reliable than developing the next big mobile app).

That said, you should be realistic about how many devs will ever work on your thing. By all odds, it will likely only ever be you.

So use the tool you want to use! If you’re more interested in the product than the journey, take into account what the ‘right’ tool is, too.",b3c3ff268909e323d0d0a6f7d495761d43f7c05b,True,False,,,,,0,1643197389,,0,{},hua6lxq,False,t3_sd3nwj,False,True,t3_sd3nwj,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/hua6lxq/,1643197405,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
35.0,[],False,,stylewarning,,,[],,,,text,t2_4n3qxa0,False,False,"If your goal is to build a startup, learning Lisp isn't really the right thing to do.

Learn Lisp if the intellectual pursuit intrigues you, and you can decide if it makes you more productive or not. It certainly does for me.",e4e4773a102a38ee3b6235f9a064e5d1f5172dd9,True,False,,,,,0,1643196536,,0,{},hua5e1v,False,t3_sd3nwj,False,True,t3_sd3nwj,/r/lisp/comments/sd3nwj/lisp_worth_learning_for_productivity/hua5e1v/,1643196552,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
36.0,[],False,,Gold-Energy2175,,,[],,,,text,t2_f1mqvqm1,False,False,I didn't know you could do that with asserts. Thanks for the pointer I will have to go and research.,cdd16e29431e8f2732c5e9d9eea0f353e1484a5e,True,False,,,,,0,1643188446,,0,{},hu9v6pm,True,t3_sbr6hc,False,True,t1_hu9o1j0,/r/lisp/comments/sbr6hc/idiomatic_way_of_checking_parameters/hu9v6pm/,1643188458,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
37.0,[],False,,flaming_bird,#dadada,lisplizard,"[{'e': 'text', 't': 'lisp lizard'}]",b3916e2a-9901-11e5-af2e-0e2f4ead9f7b,lisp lizard,dark,richtext,t2_ptn2u,False,False,"LGTM. The only thing possibly missing from your `assert`s are places to be set when the `continue` restart is invoked, depending on whether you'd like them to be interactively settable.",1c11052d959d76e97bdb4542d8e447fc840c70d5,True,False,,,,,0,1643182847,,0,{},hu9o1j0,False,t3_sbr6hc,False,True,t3_sbr6hc,/r/lisp/comments/sbr6hc/idiomatic_way_of_checking_parameters/hu9o1j0/,1643182863,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
38.0,[],False,,Gold-Energy2175,,,[],,,,text,t2_f1mqvqm1,False,False,"Thank you, I like that idea.",d399ac29ac9f552b2d309b09266790f3d47e37a8,True,False,,,,,0,1643175536,,0,{},hu9cy3o,True,t3_sbr6hc,False,True,t1_hu3gdth,/r/lisp/comments/sbr6hc/idiomatic_way_of_checking_parameters/hu9cy3o/,1643175551,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
39.0,[],False,,Gold-Energy2175,,,[],,,,text,t2_f1mqvqm1,False,False,Wouldn't just setting max-length to (min max-length (length elide-string))) be simpler? It seems strange to throw an exception which you immediately catch in the same function.,57359667e60f904d053e690e9a3de5578a46cf6d,True,False,,,,,0,1643175521,,0,{},hu9cx3z,True,t3_sbr6hc,False,True,t1_hu1ltrm,/r/lisp/comments/sbr6hc/idiomatic_way_of_checking_parameters/hu9cx3z/,1643175536,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
40.0,[],False,,Gold-Energy2175,,,[],,,,text,t2_f1mqvqm1,False,False,"Well that is exactly my question: I use it, but maybe I'm wrong or there is a better way.",285c6f6309a8cee89c0b102eed89eb6e31c826da,True,False,,,,,0,1643175408,,0,{},hu9cq1k,True,t3_sbr6hc,False,True,t1_hu5fvbk,/r/lisp/comments/sbr6hc/idiomatic_way_of_checking_parameters/hu9cq1k/,1643175424,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
41.0,[],False,,Gold-Energy2175,,,[],,,,text,t2_f1mqvqm1,False,False,Thank you.,174534c6b3882921f07bb41f7a29c9824d9b171b,True,False,,,,,0,1643175369,,0,{},hu9cnja,True,t3_sbr6hc,False,False,t1_hu8dcti,/r/lisp/comments/sbr6hc/idiomatic_way_of_checking_parameters/hu9cnja/,1643175382,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
42.0,[],False,,mirkov19,,,[],,,,text,t2_1taay5g,False,False,"The Google Common Lisp Style Guide has a section on [Assertions and Conditions](https://google.github.io/styleguide/lispguide.xml?showone=Assertions_and_Conditions#Assertions_and_Conditions). They recommend `assert` to catch internal errors and bugs, and `error` with explicit condition type for user input errors.",1593138ab8ff964392eefbd6faa3f45b30f0c325,True,False,,,,,0,1643159226,,0,{},hu8dcti,False,t3_sbr6hc,False,True,t3_sbr6hc,/r/lisp/comments/sbr6hc/idiomatic_way_of_checking_parameters/hu8dcti/,1643159242,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
43.0,[],False,,ipe369,,,[],,,,text,t2_lrq3g,False,False,"to expand on the other answer, qualifying the symbol would look like this:

    (with-slots (rcf-tile::text) tile
      (format t ""~a"" rcf-tile::text))

`with-slots` is just a macro that binds `text` to `(slot-value tile 'text)`. When running this code in your `roguelike` package, the reader comes across `'text` and creates a symbol in the `roguelike` package, so you're effectively doing `(slot-value tile 'roguelike::text)`. To make the reader create the symbol in the `rcf-tile` package, you need to qualify it, e.g. `(slot-value tile 'rcf-tile::text)`

The only way to do this with the `with-slots` macro is by using the `rcf-tile::text` slot - but this will also bind the value to a variable named by `rcf-tile::text`. That's why you need to write `rcf-tile::text` when calling `format` here, too",2aa5271938dfc2f22712cf797295f98ec6df6e2c,True,False,,,,,0,1643157612,,0,{},hu89gf5,False,t3_scpy64,False,True,t3_scpy64,/r/lisp/comments/scpy64/trouble_using_withslots_for_a_class_defined_in/hu89gf5/,1643157631,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
44.0,[],False,,flaming_bird,#dadada,lisplizard,"[{'e': 'text', 't': 'lisp lizard'}]",b3916e2a-9901-11e5-af2e-0e2f4ead9f7b,lisp lizard,dark,richtext,t2_ptn2u,False,False,"&gt; It has a slot RCF-TILE::TEXT, while ROGUELIKE::TEXT is requested.

Your code is in different packages - the object has a slot named with a symbol in the `RCF-TILE` package and you are asking it for a slot named with a symbol in the `ROGUELIKE` package.

Use a properly qualified symbol or export/import proper symbols, and things will get into a better shape.",64e40f222954a96b931823151d2af675a05f4896,True,False,,,,,0,1643151946,,0,{},hu7vnz2,False,t3_scpy64,False,True,t3_scpy64,/r/lisp/comments/scpy64/trouble_using_withslots_for_a_class_defined_in/hu7vnz2/,1643151959,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
45.0,[],False,,lichtbogen,,,[],,,,text,t2_hcp02jw,False,False,"&gt;Currently I use (assert), but that doesn't seem especially neat.

Why? I would also use assert in these situations, and I've seen it used by others. Maybe I'm in the wrong though?",e50128bdc75630dcb8ed44a9e3c65a8d138f332a,True,False,,,,,0,1643117829,,0,{},hu5fvbk,False,t3_sbr6hc,False,True,t3_sbr6hc,/r/lisp/comments/sbr6hc/idiomatic_way_of_checking_parameters/hu5fvbk/,1643117847,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
46.0,[],False,,emacsomancer,,emacs,[],,,dark,text,t2_8a43c,False,False,"oohh, has it begun?",e1d66d02bc9698f339b9b88956bee931b8e8eb8f,True,False,,,,,0,1643117606,,0,{},hu5ffbr,False,t3_c2xef1,False,True,t1_hu4rxo7,/r/lisp/comments/c2xef1/why_should_i_learn_lisp_in_2019_or_future/hu5ffbr/,1643117620,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
47.0,[],False,,Steven1799,,,[],,,,text,t2_rbcjf,False,False,"You could try [https://github.com/mmontone/cl-rest-server](https://github.com/mmontone/cl-rest-server). It needs a bit of work, but it's about the best I found when I looked for this about 4 months ago. Contributing there would be your best bet.",67eb255433311b9ab670cfd6b3a10165786aa32f,True,False,,,,,0,1643113576,,0,{},hu583qs,False,t3_sc0ga8,False,True,t1_hu56v84,/r/lisp/comments/sc0ga8/what_would_be_reliable_libs_for_building_rest_api/hu583qs/,1643113591,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
48.0,[],False,,drrnmk,,,[],,,,text,t2_578u17q4,False,False,Server side. My client is clojurescript.,4ce0692e417dde3a75debb858ab704fb1c0cdb30,True,False,,,,,0,1643112813,,0,{},hu56v84,True,t3_sc0ga8,False,True,t1_hu56arw,/r/lisp/comments/sc0ga8/what_would_be_reliable_libs_for_building_rest_api/hu56v84/,1643112890,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
49.0,[],False,,Steven1799,,,[],,,,text,t2_rbcjf,False,False,Are you looking at client or server side? Or both?,dfdbcce3e77650e6d86a6d1512ecc074904e9c77,True,False,,,,,0,1643112446,,0,{},hu56arw,False,t3_sc0ga8,False,True,t3_sc0ga8,/r/lisp/comments/sc0ga8/what_would_be_reliable_libs_for_building_rest_api/hu56arw/,1643112956,2,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
50.0,[],False,,D4RX_,,,[],,,,text,t2_ttzaj,False,False,knock knock,f5f1a0dd33f9b84aa4336ebd58925e46c83b9401,True,False,,,,,0,1643101332,,0,{},hu4rxo7,False,t3_c2xef1,False,True,t1_erz9lya,/r/lisp/comments/c2xef1/why_should_i_learn_lisp_in_2019_or_future/hu4rxo7/,1643102248,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
51.0,[],False,,kazkylheku,,,[],,,,text,t2_12b11c,False,False,"Ah, but how easy would it be to get a version of that meta-circular evaluator working that had a bug planted in it?",736b789d5a6514f27a2457494e54df7f10d18824,True,False,,,,,0,1643086335,,0,{},hu45d0m,False,t3_sblcen,False,True,t3_sblcen,/r/lisp/comments/sblcen/sectorlisp_is_a_512byte_implementation_of_lisp/hu45d0m/,1643086353,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
52.0,[],False,,shimazu-yoshihiro,,,[],,,,text,t2_efnl7gde,False,False,Neat to hear from the devs.  Thx!,0a56fcad06de1117f5d239663d2576d7c5d75abf,True,False,,,,,0,1643080276,,0,{},hu3t2pw,False,t3_sauovq,False,True,t3_sauovq,/r/lisp/comments/sauovq/lisp_in_production_interview_with_atlas_the_guys/hu3t2pw/,1643080288,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
53.0,[],False,,GabiNaali,,,[],,,,text,t2_7cuh9baq,False,False,"Imagine a distant civilization finding the golden lisp disk and making a religion out of it.

""Every computer program must be written in Holy Lisp"" - 1st commandment of the Church of the Golden Lisp",b57625438c85e18d0211e6cdd3f9c7aa5a2fa62f,True,False,,,,,0,1643079074,,0,{},hu3qdts,False,t3_sblcen,False,True,t1_hu0swmd,/r/lisp/comments/sblcen/sectorlisp_is_a_512byte_implementation_of_lisp/hu3qdts/,1643079090,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
54.0,[],False,,JoMartin23,,,[],,,,text,t2_x5onm,False,False,"for max length you can just set anything higher than max to max and specify that to be the behaviour,e.g. (max-length (min max-length 40)).  Doesn't really seem like a use case for an error.",54a4b4b9471c699384cc3c063b93ed1ed0f0fc9b,True,False,,,,,0,1643074783,,0,{},hu3gdth,False,t3_sbr6hc,False,True,t3_sbr6hc,/r/lisp/comments/sbr6hc/idiomatic_way_of_checking_parameters/hu3gdth/,1643076344,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
55.0,[],False,,drrnmk,,,[],,,,text,t2_578u17q4,False,False,what do you think about \`hunchentoot\` + \`easy-routes\`?,528b054acb7324f243484822284a5ff1ead93956,True,False,,,,,0,1643072090,,0,{},hu3a6pc,True,t3_sc0ga8,False,True,t3_sc0ga8,/r/lisp/comments/sc0ga8/what_would_be_reliable_libs_for_building_rest_api/hu3a6pc/,1643076601,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
56.0,[],False,,death,,,[],,,,text,t2_4fr2,False,False,"A while ago I wrote [this](https://gist.github.com/death/28cccef566a6f61bb1fb6b2421e34805). The model can of course be improved on in many ways, but the approach may be an inspiration.",2884ffc0f9e6e7478874b40b9f1a117974def171,True,False,,,,,0,1643067735,,0,{},hu36nu6,False,t3_sb8yno,False,True,t3_sb8yno,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/hu36nu6/,1643067888,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
57.0,[],False,,annonimusone,,,[],,,,text,t2_13zsbd,False,False,"I thought it was:

• `quote x`
• `atom x`
• `eq x y`
• `cons x y`
• `cond (x y) (w z) (t q)`
• `car x` and
• `cdr x`",347c00dbe2498df01400910c4930375607b0dbf9,True,False,,,,,0,1643061914,,0,{},hu2s98b,False,t3_sb8yno,False,True,t3_sb8yno,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/hu2s98b/,1643061933,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
58.0,[],False,,HiPhish,,,[],,,,text,t2_16lgo8x,False,False,"Really cool, I only listened to the first ten minutes or so, but I will definitely finish it when I have some free time. I did not know Atlas was an actual company, I thought it was just a community or side project.",28b1c3ad8205de8af0fefabac249d50ddc228ec7,True,False,,,,,0,1643061668,,0,{},hu2rm90,False,t3_sauovq,False,True,t3_sauovq,/r/lisp/comments/sauovq/lisp_in_production_interview_with_atlas_the_guys/hu2rm90/,1643061681,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
59.0,[],False,,theangeryemacsshibe,,,"[{'e': 'text', 't': 'λf.(λx.f (x x)) (λx.f (x x))'}]",00985e14-9780-11e5-b1fb-0eda5640e7ed,λf.(λx.f (x x)) (λx.f (x x)),dark,richtext,t2_k29ke5b,False,False,"Okay, thanks.",62aeb68baba98575aac11fce75c597e14988a022,True,False,,,,,0,1643060384,,0,{},hu2o88y,False,t3_sb8yno,False,True,t1_hu2mwk5,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/hu2o88y/,1643060397,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
60.0,[],False,,alexshendi1,,,[],,,,text,t2_c3t7g3lp,False,False,"Oh dear, I misspelled ""PARENTHESES"". Now edited.",8bc3fc986123f33355a39011c4131109a6b1da19,True,False,,,,,0,1643060368,,0,{},hu2o6ol,False,t3_sb8yno,False,True,t1_hu0ux3m,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/hu2o6ol/,1643060380,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
61.0,[],False,,lispm,,symbolics,[],,,dark,text,t2_24eol,False,False,"[http://www.mirandabanda.org/cogblog/2008/06/07/closures-part-i/](http://www.mirandabanda.org/cogblog/2008/06/07/closures-part-i/)

Quote:

\&gt; BlueBook BlockContexts are nearly closures. They close-over their enclosing environment, providing access to an enclosing method’s arguments and temporary variables.  But they lack their own local environment, hijacking their method activation’s (or home context’s) temps to store their own arguments and temporaries (let’s call these locals).  Worse still, they’re not reentrant.  ...",711a6257eb018b6aa0e98211a37af710c90a1630,True,False,,,,,0,1643059892,,0,{},hu2mwk5,False,t3_sb8yno,False,True,t1_hu2hl61,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/hu2mwk5/,1643059908,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
62.0,[],False,,theangeryemacsshibe,,,"[{'e': 'text', 't': 'λf.(λx.f (x x)) (λx.f (x x))'}]",00985e14-9780-11e5-b1fb-0eda5640e7ed,λf.(λx.f (x x)) (λx.f (x x)),dark,richtext,t2_k29ke5b,False,False,"Yes, I meant any not-Scheme Lisp. And the Blue Book seems to specify closures, but now I notice that it was published in 1983.",84cceb5598d1200d7cc1879798424434f07f0648,True,False,,,,,0,1643057892,,0,{},hu2hl61,False,t3_sb8yno,False,True,t1_hu288w6,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/hu2hl61/,1643057903,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
63.0,[],False,,lispm,,symbolics,[],,,dark,text,t2_24eol,False,False,"I think that Smalltalk got lexical scope much later than Scheme. Probably later than Common Lisp, which was designed around 1982.

The original Smalltalk 80 did not have closures and blocks were non-reentrant, from what I read.",3f91c335e203ee797cb582fa8bf8a0e71b2a05da,True,False,,,,,0,1643054324,,0,{},hu288w6,False,t3_sb8yno,False,True,t1_htzb0gg,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/hu288w6/,1643054337,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
64.0,[],False,,lmvrk,,,[],,,,text,t2_635s78rc,False,False,"Thanks for the info! So the restart case should be within the when, not around it.

And good to know about declare. I only really use sbcl,and just assumed that was the default behavipr. I suppose i should probably read the spec for declare before recommending it.",4298fb6551c2ed3780b6eb24b3fbec0065fd65b7,True,False,,,,,0,1643051703,,0,{},hu21ci5,False,t3_sbr6hc,False,True,t1_hu1o67c,/r/lisp/comments/sbr6hc/idiomatic_way_of_checking_parameters/hu21ci5/,1643051715,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
65.0,[],False,,RentGreat8009,#dadada,clnet,"[{'e': 'text', 't': 'common lisp'}]",e88a9064-978c-11e5-ab20-0eed8c938c85,common lisp,dark,richtext,t2_88v06h2c,False,False,Thanks!,1da20795f84bb9c5e16697aea34f14720e38fc37,True,False,,,,,0,1643051204,,0,{},hu200op,False,t3_sb8yno,False,True,t1_hu1kmgv,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/hu200op/,1643051222,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
66.0,[],False,,uardum,,,[],,,,text,t2_77fw0,False,False,"It's strange that the flak for extra warnings fell on ASDF and not on SBCL, which has added numerous warnings over the past few releases, resulting in one of my libraries being taken off of Quicklisp on two separate occasions.",965bbce95ff20857837595ebc0c774ed4e3c8276,True,False,,,,,0,1643050564,,0,{},hu1yb2c,False,t3_s98cpo,False,True,t3_s98cpo,/r/lisp/comments/s98cpo/common_lisp_asdf_maintainer_considers_resignation/hu1yb2c/,1643050575,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
67.0,[],False,,a-concerned-mother,,,[],,,,text,t2_ao35scl,False,False,web asm,8dd93c427e167785e29a511e7dd51c51713aedae,True,False,,,,,0,1643047697,,0,{},hu1qkei,False,t3_sb8yno,False,True,t1_htzezay,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/hu1qkei/,1643047714,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
68.0,[],False,,stassats,,,[],,,,text,t2_32vww,False,False,"declare does not perform type checking on all implementations with the default safety levels. check-type is more guaranteed.

And it's better to establish restarts only when an error is signaled, that way it'll be associated with that error and won't incur the costs of registering restarts when there's no error.",efc6725157f422cf30bcbfad701beab899a5d71f,True,False,,,,,0,1643046814,,0,{},hu1o67c,False,t3_sbr6hc,False,True,t1_hu1ltrm,/r/lisp/comments/sbr6hc/idiomatic_way_of_checking_parameters/hu1o67c/,1643046826,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
69.0,[],False,,Aidenn0,,,[],,,,text,t2_2vwkk,False,False,"Ah, yes, I read yours completely backwards that parentheses were necessary, but not sufficient.",aa4295efd2d181d3cefe2c8195b8c4880d470d7b,True,False,,,,,0,1643046251,,0,{},hu1mm57,False,t3_sb8yno,False,True,t1_htz7s4d,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/hu1mm57/,1643046268,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
70.0,[],False,,lmvrk,,,[],,,,text,t2_635s78rc,False,False,"For most things, `declare` is your friend. The only exception is the max-length assertion. But for the other assertion you can do 

    (declare (type (member :beginning :middle :end) position))

This will do type checking (except when `(speed 3) (safety 0)`, at least on sbcl).",6b6fed4d394b08c8793ea2d28f5818d062dbf41f,True,False,,,,,0,1643045963,,0,{},hu1ltrm,False,t3_sbr6hc,False,True,t3_sbr6hc,/r/lisp/comments/sbr6hc/idiomatic_way_of_checking_parameters/hu1ltrm/,1643045982,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
71.0,[],False,,Aidenn0,,,[],,,,text,t2_2vwkk,False,False,"Found it: [https://groups.google.com/g/comp.lang.lisp/c/Bj8Hx6mZEYI/m/6AWmNEwQR5YJ](https://groups.google.com/g/comp.lang.lisp/c/Bj8Hx6mZEYI/m/6AWmNEwQR5YJ) slight correction, he said it was ""not a Lisp""",07fcccacb6e93a9f0a207112c801d311cac05f6a,True,False,,,,,0,1643045523,,0,{},hu1kmgv,False,t3_sb8yno,False,True,t1_hu18zvs,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/hu1kmgv/,1643045538,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
72.0,[],False,,maufdez,,red-lisp,[],,,dark,text,t2_guxh6,False,False,"Quoting Morpheus,  
""Unfortunately, no one can be told what the Matrix is. You have to see it for yourself.""  
Just  sed 's/Matrix/Lisp/g'

Though I like u/kazkylheku's answer better.",85c72ae1653210da9e610882633950e953aa2674,True,False,,,,,0,1643041805,,0,{},hu1am4b,False,t3_sb8yno,False,True,t3_sb8yno,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/hu1am4b/,1643041817,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
73.0,[],False,,RentGreat8009,#dadada,clnet,"[{'e': 'text', 't': 'common lisp'}]",e88a9064-978c-11e5-ab20-0eed8c938c85,common lisp,dark,richtext,t2_88v06h2c,False,False,Do you have a link?,1628f52f38705dab43a5a4d1512ac3b92bb30914,True,False,,,,,0,1643041186,,0,{},hu18zvs,False,t3_sb8yno,False,True,t1_htz6kxz,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/hu18zvs/,1643041205,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
74.0,[],False,,abudabu,,,[],,,,text,t2_1150y,False,False,"I would say it's that the written representation of code as data structures (homoiconicity). Sure, there are lots of things features that showed up first in Lisps, but that is the one _critical_ choice the language designer makes. If the language is homoiconic, it's going to _look_ like a Lisp, with leading parentheses or braces that bounds each expression. And it's also the critical feature that let's a language act like a lisp - very, very easy to write super powerful macros.",5743144a308f7bd54499a71ab14a7153e747eef2,True,False,,,,,0,1643039753,,0,{},hu15b0v,False,t3_sb8yno,False,True,t3_sb8yno,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/hu15b0v/,1643039766,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
75.0,[],False,,alexshendi1,,,[],,,,text,t2_c3t7g3lp,False,False,"A small reminder, that until 1992 Dylan used prefix syntax, i.e. LOTS OF IRRITATING PARANTHESES.",b8cd4a25d938365aeb53ba53007befb2fffff4d0,True,False,,,,,0,1643035502,,0,{},hu0ux3m,False,t3_sb8yno,False,True,t1_htz6vvx,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/hu0ux3m/,1643035516,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
76.0,[],False,,_supert_,,,[],,,,text,t2_dwj10,False,False,We could etch it on the next Pioneer plaque.,fcf3be759d11629faa04c5215c97ed2bb474683f,True,False,,,,,0,1643034605,,0,{},hu0swmd,False,t3_sblcen,False,True,t3_sblcen,/r/lisp/comments/sblcen/sectorlisp_is_a_512byte_implementation_of_lisp/hu0swmd/,1643034617,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
77.0,[],False,,quote-nil,,,[],,,,text,t2_a2wy0xyq,False,False,"&gt;To me, lisp feels very axiomatic, you just need a few base parts to build up the whole thing.

This is one of lisp's main appeals to me. If the question of what makes a lisp is a subjective one, this one would apply to me.",9398f37253e971997d715cc1790ef8da22148249,True,False,,,,,0,1643031549,,0,{},hu0mi6d,False,t3_sb8yno,False,True,t1_htz1v7w,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/hu0mi6d/,1643031565,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
78.0,[],False,,Ecstatic-Leader485,,,[],,,,text,t2_cy6h70gn,False,False,"WebAssembly uses S-Exprs iirc and at least initially, M-Exprs were proposed for usage in LISP (they went with S-Exprs instead, thank god)",46c633eebe39f6b448dcd684665ad74c1644ae3d,True,False,,,,,0,1643030041,,0,{},hu0jmwp,False,t3_sb8yno,False,True,t1_htzezay,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/hu0jmwp/,1643030057,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
79.0,[],False,,theangeryemacsshibe,,,"[{'e': 'text', 't': 'λf.(λx.f (x x)) (λx.f (x x))'}]",00985e14-9780-11e5-b1fb-0eda5640e7ed,λf.(λx.f (x x)) (λx.f (x x)),dark,richtext,t2_k29ke5b,False,False,"Well, the evaluator in Common Lisp is always eager, whereas you have several reduction strategies with lambda calculus. ""size"" could refer to the nesting or count of lambda terms, and the form with the least nesting or fewest lambda terms might be ""simplest"". There is a similar issue when simplifying algebraic terms, of course.",187046e78a0d1b9b8111ae79a755c4fb18bc0c87,True,False,,,,,0,1643006948,,0,{},htzo9k4,False,t3_sb8yno,False,True,t1_htzny5m,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htzo9k4/,1643006962,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
80.0,[],False,,moon-chilled,,,[],,,,text,t2_62mab0xi,False,False,"Sure, but 'simplicity' is not quantifiable in the general case (though there happens to be an uncontroversially simpler form in this case).",952a0a1ad91df66f41deb8c5bce4d7ac81285637,True,False,,,,,0,1643006735,,0,{},htzny5m,False,t3_sb8yno,False,False,t1_htzncs2,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htzny5m/,1643006747,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
81.0,[],False,,theangeryemacsshibe,,,"[{'e': 'text', 't': 'λf.(λx.f (x x)) (λx.f (x x))'}]",00985e14-9780-11e5-b1fb-0eda5640e7ed,λf.(λx.f (x x)) (λx.f (x x)),dark,richtext,t2_k29ke5b,False,False,"Fair enough. But you _can_ reduce to a form which is smaller with lambda calculus, whereas you cannot with Lisp.",faedeaa51085c8a8ac604efa17803c5e8ea65938,True,False,,,,,0,1643006337,,0,{},htzncs2,False,t3_sb8yno,False,True,t1_htzm23k,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htzncs2/,1643006354,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
82.0,[],False,,kazkylheku,,,[],,,,text,t2_12b11c,False,False,"Say, a configuration language built in Lisp and processed by Lisp might be made of S-expressions, but isn't Lisp. Not Lisp code, but data.
An assembly language written in Lisp is assembly language, not Lisp:

    (asm (mov %eax 42)
         (ret))",d0b2d35c1e9673bf15a4b92b14e544e64db4b4b4,True,False,,,,,0,1643005915,,0,{},htzmpo2,False,t3_sb8yno,False,True,t1_htzezay,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htzmpo2/,1643005927,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
83.0,[],False,,kazkylheku,,,[],,,,text,t2_12b11c,False,False,"Lambda calculus is a family of abstractions where you can pick and choose attributes like whether evaluation is eager or lazy. Or even whether there are types: type people refer to it as ""untyped lambda calculus"", since they have some typed one in mind.",24c1082c1216e2e6a2f499f6f5b41e294870895a,True,False,,,,,0,1643005746,,0,{},htzmg9j,False,t3_sb8yno,False,True,t1_htzb0gg,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htzmg9j/,1643005758,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
84.0,[],False,,kazkylheku,,,[],,,,text,t2_12b11c,False,False,"Some people also claim that those who disagree with those people are gatekeepers.

Yet, without being called a gatekeeper:

* you can safely insist not only that C isn't Pascal but that Modula-2 isn't Pascal, even though they are more similar than Emacs Lisp and Common Lisp, and from the same designer.

* you can safely insist that Bob Bishop's ""Dung Beetles"" video game isn't Pac Man, even though there is a character running through a maze whose goal is to eat all the dots by moving over them, while avoiding contact with a handful of monsters.",60ad9b87b14d2dbddfb9f330fc6697c6142ec1ea,True,False,,,,,0,1643005652,,0,{},htzmb4a,False,t3_sb8yno,False,True,t1_htzeuyw,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htzmb4a/,1643005666,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
85.0,[],False,,moon-chilled,,,[],,,,text,t2_62mab0xi,False,False,"&gt; lambda calculus is more lazy

Lambda calculus does not specify an evaluation strategy.  There is no canonical 'reduction' of (λx.y)(λz.zz λz.zz), though you can prove that it is equivalent to any number of other expressions.",079e933bdd857e690839b1dfdb4b9860582e31a2,True,False,,,,,0,1643005486,,0,{},htzm23k,False,t3_sb8yno,False,True,t1_htzb0gg,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htzm23k/,1643005498,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
86.0,[],False,,kazkylheku,,,[],,,,text,t2_12b11c,False,False,"&gt; *matures to making heavy use of some other structure besides lists.*

Not for any of the meta-programing, though.",a053a12f40902dfa00e3c09dc033cccd30d6f413,True,False,,,,,0,1643005306,,0,{},htzlryi,False,t3_sb8yno,False,True,t1_htyz6p2,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htzlryi/,1643005316,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
87.0,[],False,,kazkylheku,,,[],,,,text,t2_12b11c,False,False,"What makes a Lisp 

* source code made of tree structure, which is conveniently manipulated by programs.

* This tree structure is made of binary cells (""conses"" or ""pairs"") and atoms: all objects that are not conses. 

* The tree structure has links in one direction only: root toward leaves, and is susceptible to garbage-collected functional programming. Pairs contain two values (classically called `car` and `cdr`), and no parent pointer.

* Lists are represented by a convention that (1) the empty list isn't a cons, but a special atom notated `()` (and, classically, that is equivalent to a symbol called `NIL`). A non-empty list is a pair whose `car` is the first item, and whose `cdr` contains the rest of the list; so a singly-linked list terminated by the atom `()` is formed through these `cdr` fields.

* A Lisp has a special family of atoms called symbols. Symbol objects correspond to identifier tokens in the textual source code. When the same identifier appears in two or more places in the textual representation of Lisp code or data, the internal cons-tree representation of that identifier will have the same symbol object in all the corresponding places where that identifier appears. That symbol object has a name property, which is a character string closely derived from that identifier.

* When a Lisp datum is treated as Lisp code, symbols represent entities and concepts like variable and function name bindings. Lists denote compound expressions such as function calls and other syntax. Most expressions that are atom objects evaluate to themselves, including some kinds of symbols. However, most symbols, though atoms, evaluate to the values they represent as variable bindings. Compound expressions (those that are conses rather than atoms) are subject to the rule that the `car` is a symbol, which determines the meaning of everything else. It can be a special operator, macro or else a function. A function call form is a list whose first element is the name, and the remaining elements, if any, are the argument expressions.

* Lisps have a `quote` operator whereby any sub-structure of the source code is made available as a literal datum. For instance whereas `(+ 1 1)`, `(quote (+ 1 1))` is a literal which denotes the object `(+ 1 1)`, making that exact three-element list available as a constant.  

* Lisps typically provide the entire language at all times. Macros that transform code before it is interpreted and compiled are written using the full language rather than a restricted subset. Compiling is available to application code.

* Lisps typically feature applicative programming, especially for list objects. List processing, such as transforming code into other code, can be performed without mutating any existing tree structure. For instance the operation `(append '(1 2 3) '(4 5 6))` calculates the list `(1 2 3 4 5 6)` without flipping any bits in the existing two lists. The `(1 2 3)` part of the new list is new structure: three new cells. The `(4 5 6)` part is shared with the original list.

* Lisps are famous for supporting anonymous functions, for which the constructing operator is classically called `lambda` (spelled out as a word), in connection with the greek letter from lambda calculus.

* Classically, the empty list `()` is not only synonymous with the symbol `NIL`, but also behaves as Boolean false: the only false value. Any other value is true. There is a symbol that is the ""canonical"" true value, such as `T`, but Lisp code looking for a true value in a variable or function result rarely compares to that symbol (which would often be wrong).   Lisp code in classical dialects which are like this exploits the equivalence of the empty list and false. E.g. in an expression like `(if pending-requests (do-this) (do-that))`, `queued-requests` may be the actual list of the pending requests, and not a Boolean variable indicating the state of such a list, which is somewhere else. If the list has items, it will evaluate `(do-this)`, otherwise it is empty and `(do-that)` is evaluated.  The Scheme dialect has notably dispensed with this; its only false is the object `#f` which is unrelated to empty lists.

* Classically, all expressions have a value in Lisp.  For instance, if you define a function, that defining form will return a value, such as the name of the function.  This is famously remarked upon in an Alan Perlis epigram which says something like ""Lisp programmers know the value of everything but the cost of nothing"". The Scheme dialect has also dispensed with this; some imperative built-in procedures in Scheme do not have a defined value according to the spec. Actual implementations cannot get away from the Alan Perlis epigram though; they may have some `#&lt;undefined&gt;` object or whatever coming out of those procedures, and that is *de facto* some kind of value.

* Lisps are, by and large, strictly evaluated, not lazily, much like run-of-the mill languages like C: when a function is called, the argument expressions are reduced to values before the function call takes place; it receives the values.   Common Lisp has strict left-to-right argument evaluation, but it's unspecified whether the function binding is evaluated before the arguments or after. Scheme leaves all evaluation order unspecified, like C.",79fe4e8b88ce712e35083ab934c0ca033a20f0bd,True,False,,,,,0,1643005236,,0,{},htzlo3n,False,t3_sb8yno,False,True,t3_sb8yno,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htzlo3n/,1643005251,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
88.0,[],False,,jmhimara,,,[],,,,text,t2_6uxxc,False,False,"Related questions: Are there any s-expression based languages that aren't Lisp? Or conversely, are there any lisps that don't use s-expressions?",f0fd84bd75c9a79f60ad4b384be8f13cbfc2611d,True,False,,,,,0,1643001295,,0,{},htzezay,False,t3_sb8yno,False,True,t3_sb8yno,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htzezay/,1643001309,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
89.0,[],False,,jmhimara,,,[],,,,text,t2_6uxxc,False,False,"&gt; Some people claim that python is a lisp

Never heard that, but I've heard something similar said about Julia.",fc578a532bfcd681cf218a4e50d8b87a364ea962,True,False,,,,,0,1643001228,,0,{},htzeuyw,False,t3_sb8yno,False,True,t1_htygif4,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htzeuyw/,1643001243,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
90.0,[],False,,FaustsPudel,,,[],,,,text,t2_6ntzgfpl,False,False,"https://www.amazon.com/Little-Schemer-Daniel-P-Friedman/dp/0262560992

^Work through this book, and you’ll learn by doing. Check out Dr.Racket, if you need an IDE. Chez is also another

https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262510871/ref=mp_s_a_1_1?crid=1LNT6YSQN3UDK&amp;keywords=structure+and+interpretation+of+computer+programs&amp;qid=1643001029&amp;sprefix=structure+and+%2Caps%2C102&amp;sr=8-1

^ this book is wonderful, but recommend doing it after the little schemer book.",b7a2c2e30888d25db1a5291e0da08a5c81a0cad5,True,False,,,,,0,1643001117,,0,{},htzenwj,False,t3_sb8yno,False,True,t3_sb8yno,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htzenwj/,1643001129,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
91.0,[],False,,theangeryemacsshibe,,,"[{'e': 'text', 't': 'λf.(λx.f (x x)) (λx.f (x x))'}]",00985e14-9780-11e5-b1fb-0eda5640e7ed,λf.(λx.f (x x)) (λx.f (x x)),dark,richtext,t2_k29ke5b,False,False,"I don't agree that functions are more like λ-calculus in Lisp than other languages. 

Alan Kay was impressed by the metacircular interpreter in the Lisp 1.5 manual, but wasn't impressed by the multitude of special forms for a ""functional"" language. And I suppose Smalltalk got lexical scope working before Lisp \\ Scheme did. Functions/closures are essential to even messaging OO in my opinion.

And Lisp is eagerly evaluated, whereas lambda calculus is more lazy, in that irreducible terms can just disappear. e.g. `(defun f (x) 'blah) (f (loop))` will not terminate, but one can reduce the equivalent lambda terms.",857448ad88761d7af62878a4dc60ec4d592522c4,True,False,,,,,0,1642999170,,0,{},htzb0gg,False,t3_sb8yno,False,True,t1_htyp67v,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htzb0gg/,1642999185,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
92.0,[],False,,umlcat,,,[],,,,text,t2_6sc8m,False,False,"I may not expressed myself well, the ""parentheses"" feature was a distinctive, but **not required** for a P.L. to be based on Lisp ;-)",f09419e0e4297546de653eb54655c574d0815898,True,False,,,,,0,1642997578,,0,{},htz7s4d,False,t3_sb8yno,False,True,t1_htz6vvx,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htz7s4d/,1642997589,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
93.0,[],False,,Aidenn0,,,[],,,,text,t2_2vwkk,False,False,"This was 30ish years ago now, but Dylan was considered to be a lisp by a fairly wide audience, despite the lack of ""silly parentheses.""  Definitions change though so perhaps today it would not be considered a lisp (particularly since a large fraction of dynamic languages have many features that were lisp-like historically, but lack the parentheses).",df3312406ec6a769e1ae7f0dba4e04dd01578df1,True,False,,,,,0,1642997153,,0,{},htz6vvx,False,t3_sb8yno,False,True,t1_htywp1v,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htz6vvx/,1642997164,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
94.0,[],False,,Aidenn0,,,[],,,,text,t2_2vwkk,False,False,"Heck, KMP is on record as not thinking scheme is a dialect of lisp; I'm not sure where c.l.l archives are these days, but there *was* a fairly thoughtful discussion mostly hidden in a massive flamewar when Ron Garret (then Eran Gat) asked a similar question to OP.

His reasoning was roughly that {mac|zeta|etc} lisp people hung out in one group went to particular conferences and scheme people hang out with a different group and went to different conferences.",b673ee37d789f2e449f29ba603a8c8b2dadc67ed,True,False,,,,,0,1642997011,,0,{},htz6kxz,False,t3_sb8yno,False,True,t1_htygif4,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htz6kxz/,1642997025,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
95.0,[],False,,arthurno1,,,[],,,,text,t2_13zo3p,False,False,"Even if you use other data structures to store your program data in, your program is still processed as lists, isn't it? So it is a list processing driving the entire system, so I would say it is heavy use of list structures. Even if you don't use them explicitly.",b3f9919a39a975a722fd4a4cfb6c3a1e4128f169,True,False,,,,,0,1642995216,,0,{},htz2l1d,False,t3_sb8yno,False,True,t1_htyz6p2,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htz2l1d/,1642995232,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
96.0,[],False,,revohour,,,[],,,,text,t2_fg4ze5ge,False,False,"I agree, but it feels 'less lispy' when you do, in my opinion.

To me, lisp feels very axiomatic, you just need a few base parts to build up the whole thing. It was really cool how they taught you to implement cons with a closure in SICP. Now, of course you don't really implement cons with closures, and you don't really write programs using only lists, but that's still part of what makes lisps lispy to me.

Maybe another lispy feature is including unlispy things, like how coalton is giving us strong typing.",fadd6ebd001a7f2f0bd5446442a65ef0dd9f40ed,True,False,,,,,0,1642994899,,0,{},htz1v7w,False,t3_sb8yno,False,True,t1_htyz6p2,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htz1v7w/,1642994914,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
97.0,[],False,,bogon64,,,[],,,,text,t2_1wtcxjs8,False,False,"“Heavy use of list structures”

Is that even true anymore? I feel like any lisp project I develop eventually matures to making heavy use of some other structure besides lists. Usually a hash, maybe an immutable array or heap or black red tree or something. 

Maybe it’s just the projects I tackle, but I feel like list processing is good for rough draft or proof of concept, until the O(n) searches become problematic and I convert to hash builtins (or reimplement hashes poorly).",becd5a245dead57f8bb00e166ad45b264f4ea360,True,False,,,,,0,1642993780,,0,{},htyz6p2,False,t3_sb8yno,False,True,t1_htygif4,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htyz6p2/,1642993790,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
98.0,[],False,,umlcat,,,[],,,,text,t2_6sc8m,False,False,"Two things to be consider, syntax &amp; semantics.

**(a) Syntax, since Lisp uses ""a lot of silly"" parentheses.**

Some new P.L. uses F.P. without a lot of parentheses.

**(b) Semantics, which supports F.P. ( ""Functional Programming"" ).**

Of course, you can have P.L. that supports some sort of F.P., without using parentheses as Lisp does, like C# does with lambdas.

And, you could have parentheses based syntax, without F.P. which seems as you Lisp &amp;  COBOL hybrid.

I suggest to use ""LISP inspired P.L."" or ""LISP based P.L."" term, instead.

**Remember, In lisp, developers defines data, and lists &amp; functions by themselves are also data, besides atomic values.**

So, how does your P.L. idea applies this ?

Good Work, Good Luck !!!",fae3dfa34aff459f622d29475b47a1a60efbd9f9,True,False,,,,,0,1642992848,,0,{},htywp1v,False,t3_sb8yno,False,True,t3_sb8yno,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htywp1v/,1642992863,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
99.0,[],False,,quote-nil,,,[],,,,text,t2_a2wy0xyq,False,False,"I don't think there's a single defining quality. As someone recently said, ""lisp is *gestalt*"". Languages, whether natural or formal, seem to have a ""genetic"" development like that of living organisms. Lisp languages share a common ancestry. Some argue that Scheme is not a lisp, that is an Algol-like. Certainly, scheme is a descendent of both. Even modern lisps take from scheme the lexical binding of variables, which iirc is also a feature from algol. Some say macros, some say lots of irritating silly parentheses, some would say the combination of both.

I think a prominent feature of lisp which makes it stand out is the explicit use of λ-forms. Sure, most languages today have adopted ""anonymous functions"", and ML languages are directly modelled on λ calculus too. But whereas in imperative and object oriented languages lambda constructions are machine procedures, in lisp they are conceptially different (honestly I don't k know enough ML to characterize their role in that case). In lisp it pays to think of them as their λ calculus counterparts, as objects that can be applied to other objects. Not merely machine procedures to be carried out (that's implementation), not either mathematical functions, but as expressions with a (possibly empty) set of free variables which could be bound and reduced to produce one of a set of values. If this sounds a bit awkward, it's because I find it hard to accurately express the subtle identity of a λ term.",b6ba3819e138934fc0341388586835d2a5654a1e,True,False,,,,,0,1642989815,,0,{},htyp67v,False,t3_sb8yno,False,True,t3_sb8yno,/r/lisp/comments/sb8yno/what_makes_a_lisp_a_lisp/htyp67v/,1642989827,1,False,True,False,lisp,t5_2qh35,r/lisp,public,,0,[],
