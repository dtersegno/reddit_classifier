,all_awardings,archived,associated_award,author,author_flair_background_color,author_flair_css_class,author_flair_richtext,author_flair_template_id,author_flair_text,author_flair_text_color,author_flair_type,author_fullname,author_patreon_flair,author_premium,body,body_sha1,can_gild,collapsed,collapsed_because_crowd_control,collapsed_reason,collapsed_reason_code,comment_type,controversiality,created_utc,distinguished,gilded,gildings,id,is_submitter,link_id,locked,no_follow,parent_id,permalink,retrieved_utc,score,score_hidden,send_replies,stickied,subreddit,subreddit_id,subreddit_name_prefixed,subreddit_type,top_awarded_type,total_awards_received,treatment_tags,unrepliable_reason,author_cakeday
0.0,[],False,,slack1256,,,[],,,,text,t2_3fucmq85,False,False,"GHC can use the LLVM backend and you will get ARM/M1 support even with old versions of GHC such as 8.10.7.  

```
$ cabal v2-build --ghc-options '-fllvm'
$ stack build --ghc-options '-fllvm'
$ ghc -0 main -fllvm main.hs
```
All work",f87a76a83ec3b263b12e6483d59d9ea6c75468b9,True,False,,,,,0,1648565422,,0,{},i2kjsq8,False,t3_tqzxy1,False,True,t3_tqzxy1,/r/haskell/comments/tqzxy1/now_that_stackage_supports_ghc_92_is_it_easy_to/i2kjsq8/,1648565436,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
1.0,[],False,,gcross,,,[],,,,text,t2_572z0,False,True,"Thanks, that's really interesting!",6dd1ab2ea441ffd80e1701045b36f986ab0fb9de,True,False,,,,,0,1648563533,,0,{},i2kf709,False,t3_tm900v,False,True,t1_i2i233w,/r/haskell/comments/tm900v/new_largerecords_release_now_with_100_fewer_quotes/i2kf709/,1648563546,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
2.0,[],False,,valcron1000,,,[],,,,text,t2_hw1ys,False,False,You shouldn't 'cabal install' anything but standalone executables like 'hlint'. If you *really* want to do that you can use 'cabal install --lib',311d3467aacdb7dcf77324ddeb6731b748aa81e2,True,False,,,,,0,1648562692,,0,{},i2kd6m4,False,t3_tqytst,False,True,t3_tqytst,/r/haskell/comments/tqytst/when_i_cabal_install_anything_why_is_it/i2kd6m4/,1648562705,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
3.0,[],False,,tomejaguar,,,[],,,,text,t2_45sug,False,False,Thanks! And thanks for all your help in the early days of Opaleye :),930d3eb7069e725e9e43c4f6ef3e14e128d62ee3,True,False,,,,,0,1648560354,,0,{},i2k7ti2,True,t3_tpo6u8,False,True,t1_i2feojq,/r/haskell/comments/tpo6u8/breakage_and_deprecation_cycle_policies/i2k7ti2/,1648560368,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
4.0,[],False,,Iceland_jack,,,[],,,,text,t2_3qjdu,False,False,"I will still try just out of personal curiosity because I won't know what the options are unless I do.

With `Free` I went about it the wrong(?) way, I first attempted to use the datatype [`Free`](https://hackage.haskell.org/package/free-5.1.7/docs/Control-Monad-Free.html#t:Free) and derive instances through that.

    data Deferred a = Now a | Later (Deferred a)
      deriving (Functor, Applicative, Monad) via .. Free Identity ..

    data Hopes a = Confirmed a | Possible (Hopes a) | Failed
      deriving (Functor, Applicative, Monad) via .. Free Maybe ..

    data Demand a b = Satisfied b | Hungry (a -&gt; Demand a b)
      deriving (Functor, Applicative, Monad) via .. Free (a -&gt;) ..

    data Either a b = Left a | Right b
      deriving (Functor, Applicative, Monad) via .. Free (Const a) ..

which turned out to be much too impractial, specifying the functor, distributing it through `Free` and making sure everything lined up. It was a much better approach to first create a generic implementation for a free Monad that `Free` itself can be derived via

    data Free f a = Pure a | Free (f (Free f a))
      deriving (Functor, Applicative, Monad) via GenericFreeMonad ""Pure"" (Free f)

and then the specialised versions can be derived as well.. anyway, ultimately I'm just lazy and not great at generic programming so I wanted code for free",ab1227101df5d4672d11d1eaf552a1de39e5a8d5,True,False,,,,,0,1648559756,,0,{},i2k6jx7,True,t3_tpzy07,False,True,t1_i2k3ynq,/r/haskell/comments/tpzy07/generic_applicative/i2k6jx7/,1648559769,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
5.0,[],False,,WarDaft,,,[],,,,text,t2_cspxi,False,False,"What's wrong with `deriving Applicative via (RightSumBias EtaConvert Parallel)` or `... via (LeftSumBias Extract Fanout)`? It doesn't have to cover every conceivable case, if it covers 95% of use cases with a small set of combinators, then it still reduces Applicative boilerplate by 95%. `Either` as it functions would be made as a `Sum (Const String) Identity` so you'd want `... via (RightSumBias Coerce Parallel)` to describe its current behaviour, because you favour the `Right` side when possible (`pure`), and handle the `Left` side showing up by reconstructing the term to change the type. Is there something I'm missing here?",88242fb3b0c6455c240a322dfa2a26de7d018d50,True,False,,,,,0,1648559637,,0,{},i2k6b76,False,t3_tpzy07,False,True,t1_i2jybrg,/r/haskell/comments/tpzy07/generic_applicative/i2k6b76/,1648559661,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
6.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,http://www.catb.org/~esr/faqs/smart-questions.html,050c5803f3280acb618df51ef042e3eadaea797d,True,False,,,,,0,1648558744,,0,{},i2k4in1,False,t3_tqytst,False,True,t3_tqytst,/r/haskell/comments/tqytst/when_i_cabal_install_anything_why_is_it/i2k4in1/,1648558761,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
7.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"I agree that I don't think that goal was clear from your original post, and I don't really have much to contribute toward that goal, except to say that you may be asking to much metaprogramming out of `deriving`; some things really are better done with TTH or some other general purpose metaprogramming utilities.",2f483ed1300f9d9df444cfce2b6a2294bd4c08e0,True,False,,,,,0,1648558466,,0,{},i2k3ynq,False,t3_tpzy07,False,False,t1_i2k1qt9,/r/haskell/comments/tpzy07/generic_applicative/i2k3ynq/,1648558479,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
8.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"Well, it has turned out to be simpler than implementing full dependent types. We already have Liquid Haskell, but there is no Dependent Haskell yet. 

While the implementations of good SMT solvers are very complex, their interfaces are quite simple. The implementation details don't have to leak into the type system.",d932ee016f97ddb475634ef2bb1fbfdd0042cf28,True,False,,,,,0,1648557494,,0,{},i2k22fn,False,t3_tnrsg7,False,True,t1_i2k1bgh,/r/haskell/comments/tnrsg7/the_haskell_interlude_11_simon_peyton_jones/i2k22fn/,1648557505,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
9.0,[],False,,Iceland_jack,,,[],,,,text,t2_3qjdu,False,False,"Yes most of what we derive is not canonical but I think `Applicative` has a more interesting deriving question. I was hoping this post would inspire a configuration language that is desriptive for expressive `Applicative`, I'm perhaps not good at expressing it but I am not looking to make `Generically1` pick arbitrary behaviour for sum types but to find the best configuration language that can capture the meaning of each instance. For example what goes here `???` to get the cartesian `Applicative` versus the `ZipList` one

    data List a = Nil | a ::: List a
      deriving stock Generic1
      deriving (Functor, Applicative) via ???",58e492899706a05f7630db75f0a5ffbf50aecc38,True,False,,,,,0,1648557320,,0,{},i2k1qt9,True,t3_tpzy07,False,True,t1_i2frhxq,/r/haskell/comments/tpzy07/generic_applicative/i2k1qt9/,1648557334,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
10.0,[],False,,Las___,,,[],,,,text,t2_hgb80y2l,False,False,"Making an SMT solver part of the type checker would have many big detriments, as evident by the simple fact that they are quite complex.
Preventing the user from managing proofs isn't a good thing in practice, albeit you could still have something like Wingman generate the proofs for you, and then they'd be embedded into the source code, meaning the type checker can stay simple.",65a7246a387f8ae287a94e453886b7c2dcb8ba4f,True,False,,,,,0,1648557089,,0,{},i2k1bgh,False,t3_tnrsg7,False,True,t1_i2c721x,/r/haskell/comments/tnrsg7/the_haskell_interlude_11_simon_peyton_jones/i2k1bgh/,1648557103,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
11.0,[],False,,kuribas,,,[],,,,text,t2_nct91,False,False,"That's an overgeneralisation.  Sometimes higher-kinded types can make your life easier.  You just should not use them by default, or use advanced type features just because it is cool to do so.  Avoid type classes and type system extensions when you can, but when you cannot, don't hesitate to use them.",8d5c9b7106cd7cefc1ebcf723dca06375759b0a1,True,False,,,,,0,1648555562,,0,{},i2jykwr,False,t3_tqbba5,False,True,t1_i2hj6v1,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2jykwr/,1648555577,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
12.0,[],False,,Iceland_jack,,,[],,,,text,t2_3qjdu,False,False,This is all about deriving via and I am basically asking what goes here: `deriving Applicative via ?` for the most common applicatives.,e4174a4b5e62b06ea5af3f6a96acb81c1d347e07,True,False,,,,,0,1648555415,,0,{},i2jybrg,True,t3_tpzy07,False,True,t1_i2g09z3,/r/haskell/comments/tpzy07/generic_applicative/i2jybrg/,1648555428,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
13.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"Let's say there are two projects A and B. They both want to use a data type C, but both A and B want to add their own extensions to this data type. However, A doesn't care about B's extensions, so in this case it isn't natural that functions in A need to account for B's extensions.

Practical examples are exceptions as mentioned in another comment or events.",01379dd9393efd2df2a2fc76933d99548a30dd65,True,False,,,,,0,1648554691,,0,{},i2jx4wv,False,t3_tqbba5,False,True,t1_i2js4cs,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2jx4wv/,1648554706,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
14.0,[],False,,Ariakenom,,,[],,,,text,t2_d2j2t,False,False,"But we can add StringifyT the same way (or combine them). And then we can do everything. 

But we don't have extensibility in the class direction since we must specify the classes, ex EvalT, when parsing. So it doesn't work. Maybe we can pass class dicts to k but that's obviously more advanced.",063ad76e504de956a137f1474032b9bb93791a5c,True,False,,,,,0,1648553799,,0,{},i2jvp9u,False,t3_tqbba5,False,True,t1_i2js5ys,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2jvp9u/,1648553811,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
15.0,[],False,,TheCommieDuck,,,[],,,,text,t2_52eu3,False,False,"once you have EvalT, you can't do anything with it except call evaluate  

once you hide the a you can never get it out again, only call evaluate",743df47d01bea84065e30bdabdee6f4edd6b900d,True,False,,,,,0,1648551381,,0,{},i2js5ys,False,t3_tqbba5,False,True,t1_i2jlzjz,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2js5ys/,1648551393,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
16.0,[],False,,korreman,,,[],,,,text,t2_9tvgnu8q,False,False,"I feel like what you describe as the Expression Problem is a non-problem in Haskell (and OCaml, F#, Rust, etc.)

If I want to new add functionality around a type, no problem.
If I want to modify a type,
I have to modify the functions that depend directly on the definition of that type.
That's just natural.
It's a purely additive modification when extending an ADT,
we're just appending patterns to case expressions.
The compiler tells us exactly what's missing.

It boils down to representing that 2-D matrix in one dimension
made from lines of code.

    A1 A2
    B1 B2

Becomes `A1 A2 B1 B2` or `A1 B1 A2 B2` depending on whether you're writing object-oriented or data-oriented.
Adding a column:

    A1 A2 A3
    B1 B2 B3

It becomes `A1 A2 A3 B1 B2 B3` or `A1 B1 A2 B2 A3 B3`.
If you try to go `A1 A2 B1 B2 A3 B3`, that's bad code organization.
Either extending functionality or extending types _should_ result in having to add code in multiple locations.
I personally think that the 'functional' way of slicing the matrix works better.",53294ca234178ee24e1c4817c6e0c1992714ec2f,True,False,,,,,0,1648551348,,0,{},i2js4cs,False,t3_tqbba5,False,True,t3_tqbba5,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2js4cs/,1648551360,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
17.0,[],False,,Ariakenom,,,[],,,,text,t2_d2j2t,False,False,"    &gt; data EvalT = forall a. Eval a =&gt; EvalT a
    &gt; instance Eval EvalT where evaluate (EvalT a) = evaluate a

    &gt; let k = if 20 &gt; 4 then EvalT (Constant 2.2) else EvalT (BinaryPlus (Constant 5.5) (Constant 2.1))
    &gt; evaluate k
    2.2

LGTM?",cb29d909688ed93a9b14ebcd3ee3f563e84ab666,True,False,,,,,0,1648546372,,0,{},i2jlzjz,False,t3_tqbba5,False,True,t1_i2gflei,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2jlzjz/,1648546388,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
18.0,[],False,,romesrf,,,[],,,,text,t2_3dd9ltqt,False,False,!! Cool,fe46fb8e20f1baa9acfe3eb561be9b983fe92f8e,True,False,,,,,0,1648543962,,0,{},i2jjagl,False,t3_tqj5ki,False,True,t3_tqj5ki,/r/haskell/comments/tqj5ki/ann_bloodhound01900/i2jjagl/,1648543973,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
19.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"Yes, for this example you'd write:

    class Expr rep where
      constant :: Double -&gt; rep
      binaryplus :: rep -&gt; rep -&gt; rep

    newtype Stringify = Stringify String

    instance Expr Stringify where
      constant d = Stringify (show d)
      binaryplus (Stringify x) (Stringify y) = Stringify (x ++ "" + "" ++ y)

    newtype Evaluate = Evaluate Double

    instance Expr Evaluate where
      constant d = Evaluate d
      binaryplus (Evaluate x) (Evaluate y) = Evaluate (x + y)

    class MulExpr rep where
      binarymul :: rep -&gt; rep -&gt; rep

    instance MulExpr Stringify where
      binarymul (Stringify x) (Stringify y) = Stringify (""("" ++ x ++ "" * "" ++ y ++ "")"")

    instance MulExpr Evaluate where
      binarymul (Evaluate x) (Evaluate y) = Evaluate (x * y)

    parse :: (Expr rep, MulExpr rep) =&gt; Int -&gt; rep
    parse x = if x &gt; 4 then binarymul (constant 2.2) (constant 4.2) else binaryplus (constant 5.5) (constant 2.1)",b46ae8f90b54c0da391cc782138eb539e186ac0c,True,False,,,,,0,1648540697,,0,{},i2jfnq1,False,t3_tqbba5,False,True,t1_i2gd04z,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2jfnq1/,1648540707,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
20.0,[],False,,circleglyph,,,[],,,,text,t2_557783ba,False,False,"It can, yes. But this is Haskell; most dependency can run foul of our bi-annual compiler bump and shuffle!

Very generally, though, I find the ecosystem and good practice evolves quite rapidly, and libraries need to keep up.",69ab8360b4529999e1c6f7a30d58aee1b68a0708,True,False,,,,,0,1648535594,,0,{},i2j9m2x,False,t3_tqbba5,False,True,t1_i2j8sw6,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2j9m2x/,1648535605,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
21.0,[],False,,brnhy,,,[],,,,text,t2_jhxia,False,False,"I strongly disagree that frequent releases signal quality. As a counterpoint it could signal problematic dependencies, being tied to compiler versions, and generally brittle abstractions.",b63ac0eae1bb8b64a736adde48575f7cde6069ef,True,False,,,,,0,1648534948,,0,{},i2j8sw6,False,t3_tqbba5,False,True,t1_i2hj6v1,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2j8sw6/,1648534960,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
22.0,[],False,,sccrstud92,,,[],,,,text,t2_7v2vu,False,False,Thank you! I forgot that one.,8aa5701c3c77f6c1c714340679b6724355173fcf,True,False,,,,,0,1648530334,,0,{},i2j2fvd,False,t3_tqbba5,False,True,t1_i2in81o,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2j2fvd/,1648530367,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
23.0,[],False,,kushagarr,,,[],,,,text,t2_kfnt1txs,False,False,Thank you,6b50e31a7e1337db9ecb0e2fcb6e65ca27f57df5,True,False,,,,,0,1648528872,,0,{},i2j07fs,False,t3_tqj5ki,False,True,t3_tqj5ki,/r/haskell/comments/tqj5ki/ann_bloodhound01900/i2j07fs/,1648528883,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
24.0,[],False,,fabfianda,,,[],,,,text,t2_faqm8,False,False,Thank you!,184eb63a906e3136190bfe5ddab6df3340bd9b91,True,False,,,,,0,1648527142,,0,{},i2ixedu,False,t3_tqj5ki,False,True,t3_tqj5ki,/r/haskell/comments/tqj5ki/ann_bloodhound01900/i2ixedu/,1648527157,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
25.0,[],False,,kablewie,,,[],,,,text,t2_cfbyd,False,False,also `SomeException`: https://hackage.haskell.org/package/base-4.16.1.0/docs/Control-Exception.html#t:SomeException,b3e211151e7e5b9348b44862d4bfee454d23b37c,True,False,,,,,0,1648521553,,0,{},i2in81o,False,t3_tqbba5,False,True,t1_i2gflei,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2in81o/,1648521567,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
26.0,[],False,,paretoOptimalDev,,,[],,,,text,t2_fjx3p3ff,False,False,I really feel like this should show by default.,9a20bb4f3f1cd1a255dcf30668cf6fb8bc69888f,True,False,,,,,0,1648518484,,0,{},i2igwi3,False,t3_tpa9t2,False,True,t1_i2ae6hy,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i2igwi3/,1648518499,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
27.0,[],False,,Axman6,,,[],,,,text,t2_37j8m,False,False,Looks like macOS' header for this would be `netinet/in.h` according to https://www.unix.com/man-page/osx/4/tcp/,3a0345ac68efefe01076daf8ce15b71c5b396b91,True,False,,,,,0,1648512652,,0,{},i2i4yo1,False,t3_tilhpz,False,True,t1_i1fduqi,/r/haskell/comments/tilhpz/haskell_network_library_tcp_keepalive_parameters/i2i4yo1/,1648512663,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
28.0,[],False,,Axman6,,,[],,,,text,t2_37j8m,False,False,I'm surprised no one has recommended that you use an already existing command line parsing library like optparse-applicative.,d4c12eb09658c577d143c7753704d3d37b7d1ab1,True,False,,,,,0,1648511260,,0,{},i2i2bpn,False,t3_tngqtp,False,True,t3_tngqtp,/r/haskell/comments/tngqtp/parsing_with_parsec_command_line_arguments_of/i2i2bpn/,1648511273,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
29.0,[],False,,Axman6,,,[],,,,text,t2_37j8m,False,False,"Our DAML codebase has many large records, because you need to associate a lot of data with financial things.

We also have a pattern of defining ""Services"" which are large records of functions which perform various domain specific functionality, and those services can have dozens or even hundreds of fields. Not sure this is the best way to actually design such things but it's what we have and it does its job.",b576713321bde1dc4d0f11ab2d0d60a83ce61cd9,True,False,,,,,0,1648511134,,0,{},i2i233w,False,t3_tm900v,False,True,t1_i1zax87,/r/haskell/comments/tm900v/new_largerecords_release_now_with_100_fewer_quotes/i2i233w/,1648511146,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
30.0,[],False,,Tarmen,,,[],,,,text,t2_7mjdo,False,False,"The expression problem is mostly interesting for libraries - wouldn't it be neat if users of your sql library could extend it with new sql ops or query types without making the library code or user code more complicated that the specialized case?

Sadly that isn't really the case anywhere. Tagless final is the best encoding I know and MTL is still more complex than basic monads with specialized ops. But I definitely prefer tagless final over anonymous sums+inject, that encoding becomes really tedious and can have some serious runtime overhead.",9728b57204610f93fcf826faad31246d43bd8810,True,False,,,,,0,1648504366,,0,{},i2hokfw,False,t3_tqbba5,False,True,t3_tqbba5,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2hokfw/,1648504384,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
31.0,[],False,,circleglyph,,,[],,,,text,t2_557783ba,False,False,"&gt;Healthy code bases should be continously tended to and refactored

If you combine this opinion with just how cheap refactoring is in Haskell, higher-kinded type shenanigans rarely come out on top in any metric. Concrete types, boring lower-case Haskell and frequent releases are important signals of library quality.",efbe759e0f336256f95d058eb58d2a1dc6504404,True,False,,,,,0,1648501964,,0,{},i2hj6v1,False,t3_tqbba5,False,True,t3_tqbba5,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2hj6v1/,1648501976,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
32.0,[],False,,phadej,,,[],,,,text,t2_4qmwn,False,False,"&gt; we GHC devs make no guarantees, at all, about the order of inferred variables, or even where in a type they appear

But there is `StandaloneKindSignatures`! so I need guarantees I can get them.

Or do you mean that even with given standalone kind signature GHC may add kind-variables there. That doesn't sound great.",d7d3f6ccb866625ef82b5a778b5286ab724345b0,True,False,,,,,0,1648496556,,0,{},i2h5zih,False,t3_tjm0ga,False,True,t1_i2h5nez,/r/haskell/comments/tjm0ga/ghc_proposal_breakage_should_we_proceed/i2h5zih/,1648496569,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
33.0,[],False,,goldfirere,,,[],,,,text,t2_culpc,False,False,"Yes, I agree that inferred variables are in violation of the spirit of that principle. And moreover, the lack of being able to bring them into scope in type headers is a violation of the letter of that principle.

It's true that being able to explicitly instantiate inferred variables would be useful sometimes. However, it is hoped that library designers will choose to make such variables specified, not inferred. The problem with inferred variables is that their order may change arbitrarily between releases of GHC -- we GHC devs make no guarantees, at all, about the order of inferred variables, or even where in a type they appear. So any ability to interact directly with inferred variables would make your code fragile. Sadly, I don't see a way to do better here: see section 3.1 of the [original paper](https://richarde.dev/papers/2016/type-app/visible-type-app.pdf).",89b996dfb8578228452debdf31c1567267b68367,True,False,,,,,0,1648496418,,0,{},i2h5nez,True,t3_tjm0ga,False,True,t1_i2gyc3r,/r/haskell/comments/tjm0ga/ghc_proposal_breakage_should_we_proceed/i2h5nez/,1648496433,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
34.0,[],False,,phadej,,,[],,,,text,t2_4qmwn,False,False,"Inferred variables as a concept seems to be against ""Explicit Variable Principle (EVP)"" (mentioned in https://github.com/goldfirere/ghc-proposals/blob/type-variables/principles.rst, linked from https://github.com/ghc-proposals/ghc-proposals/pull/448). I agree with that priciple.

I.e. IMO it's bad design that ""inferred"" variables cannot be explicitly applied (they are omitted by ""(specified)"" in the EVP definition). I'd really wish to be able to write

    Control.Category.id @{Type} @(-&gt;) @Int

as its type is

    Control.Category.id
      :: forall {k} (cat :: k -&gt; k -&gt; *) (a :: k).
         Category @{k} cat =&gt;
         cat a a

I see these variables (`k`) in this example, as implicit arguments in types, which will be filled by he type/kind-checker. The same way types are (mostly) filled by the type-checker. But I'm sure there will be situations where explicitly specifying an ""inferred"" type-variable would be very very valuable.",46a6d99ce8776f492c513a065c2ed3c91153e7e0,True,False,,,,,0,1648493382,,0,{},i2gyc3r,False,t3_tjm0ga,False,False,t1_i2gvy3b,/r/haskell/comments/tjm0ga/ghc_proposal_breakage_should_we_proceed/i2gyc3r/,1648493393,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
35.0,[],False,,WarDaft,,,[],,,,text,t2_cspxi,False,False,"I love recursion strategies, but in practice I agree with your end note about complexity, and I've kinda preferred the simpler case of factoring your datatypes into meaning types and  structure types:

    {-# LANGUAGE OverloadedRecordDot, NamedFieldPuns, FlexibleContexts,
	DuplicateRecordFields, RecordWildCards, TypeOperators,       
            PartialTypeSignatures #-}

import Data.Void

data Expr b u c
    = Const { c :: c }
    | Unary { u :: u, x :: Expr b u c }
    | Binary { x :: Expr b u c, b :: b, y :: Expr b u c }

data Evaler b u c o
    = Ev { c :: c -&gt; o, u :: u -&gt; o -&gt; o, b :: b -&gt; o -&gt; o -&gt; o }

eval f e@(Const _) = f.c e.c
eval f e@(Unary _ _) = f.u e.u $ eval f e.x
eval f e@(Binary _ _ _) = f.b e.b (eval f e.x) (eval f e.y) 

data Add = Add

toStr :: Evaler Add Void Double String
toStr = Ev {c = show, u = undefined, b} where
    b _ x y = concat [x,"" + "",y]

-- &gt;&gt; eval toStr (Binary (Const 3) Add (Const 3))
-- ""3.0 + 3.0""

(.|) = either
	
type a .| b = Either a b

data Factorial = F; data Mult = Mult

extEv :: _ -&gt; _ -&gt; _ -&gt; Evaler b u c o -&gt; Evaler b' u' c' o
extEv c u b e = e {c = c e.c, u = u e.u, b = b e.b}

toStr2 :: Evaler (Add .| Mult) (Void .| Factorial) Double String
    toStr2 =        
    extEv id (.| \_-&gt;(++""!"")) (.| \_ x y-&gt;concat[x,"" * "",y]) toStr
    
    --  &gt;&gt; eval toStr2' (Binary (Const 3) (Right Mult) (Const 5))
-- ""3.0 * 5.0""
    -- And of course you can still do:
    instance Num a =&gt; Num (Expr (Add .| Mult) u a) where
        a + b = Binary a (Left Add) b
        a * b = Binary a (Right Mult) b
        fromInteger = Const
    
    -- &gt;&gt; eval toStr2 $ 3 * 5 + 7
-- ""3.0 * 5.0 + 7.0""
    -- Note that parenthesis don't work here for the Num instance

This, of course, hasn't actually *solved* the expression problem here, merely dramatically reduced it. If you wanted to change the structure of Expr by, for example, introducing Trinary functions you'd still have to change things. Or technically you could encode them as curried Unary Lambdas, so this kinda does solve the expression problem just in a different way, with different mental overhead.

But, as far as complexity, I typed up almost the whole example in reddit *first*, then debuged type and typo errors in about 7 minutes, so it's quite workable.",9b1d0c5763dedcba511a924aaa1beb71f3422208,True,False,,,,,0,1648493240,,0,{},i2gxzz1,False,t3_tqbba5,False,True,t3_tqbba5,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2gxzz1/,1648493256,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
36.0,[],False,,SSchlesinger,,,[],,,,text,t2_jggeg,False,False,Dang,c9468787c38aad9bf51479e87d9a77c43aba19a2,True,False,,,,,0,1648493020,,0,{},i2gxh65,False,t3_tpo6u8,False,True,t1_i2cbwv4,/r/haskell/comments/tpo6u8/breakage_and_deprecation_cycle_policies/i2gxh65/,1648493034,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
37.0,[],False,,goldfirere,,,[],,,,text,t2_culpc,False,False,"That's right -- the variables don't propagate, even with `ScopedTypeVariables`.

Your example looks sensible, but it goes against the spirit of inferred variables, for which order must not matter. More argumentation in this direction at https://github.com/serokell/ghc-proposals/blob/decl-invis-binders/proposals/0000-decl-invis-binders.rst#alternatives

I disagree that `(cat :: k' -&gt; k' -&gt; Type)` is CUSKy. The problem with CUSKs is that whether or not a declaration had a CUSK was determined using a set of arbitrary syntactic rules -- and yet had a profound effect on how kind inference worked. On the other hand, `cat :: k' -&gt; k' -&gt; Type` just depends on unification, which is a reliable algorithm. It's overly verbose, but much more predictable than CUSKs.",5e69b5492d7e372222d566603d5314ae1876e19b,True,False,,,,,0,1648492376,,0,{},i2gvy3b,True,t3_tjm0ga,False,True,t1_i2guabd,/r/haskell/comments/tjm0ga/ghc_proposal_breakage_should_we_proceed/i2gvy3b/,1648492390,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
38.0,[],False,,phadej,,,[],,,,text,t2_4qmwn,False,False,"So we can write:

    type Category :: forall {k} . (k -&gt; k -&gt; Type) -&gt; Constraint

but kind variables don't propagate from there even with `ScopedTypeVariables`?

I'd prefer that we would write

    type Category :: forall {k} . (k -&gt; k -&gt; Type) -&gt; Constraint
    class Category @{k'} cat where

The `(cat :: k' -&gt; k' -&gt; Type)` fills like thing from the past. CUSKy.",e13b7af1c1a078e3be5cd7d9456a51e2da5e50d1,True,False,,,,,0,1648491687,,0,{},i2guabd,False,t3_tjm0ga,False,True,t1_i2gt5ml,/r/haskell/comments/tjm0ga/ghc_proposal_breakage_should_we_proceed/i2guabd/,1648491701,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
39.0,[],False,,goldfirere,,,[],,,,text,t2_culpc,False,False,"Yes, impossible even with kind signatures, because there is no way to bring a type variable from a kind signature into scope in a definition. This matters if the only occurrence of the type variable is in a non-injective type family used in a kind, for example. Like I said, the scenarios are obscure!

As for unifying type and term: I think we're headed in that direction. According to [https://github.com/ghc-proposals/ghc-proposals/pull/448](https://github.com/ghc-proposals/ghc-proposals/pull/448), we *will* accept your ""foo"" example, and so it makes sense also to do so in types.",91b523059a7a671f1b062be7a46470a5c666fec9,True,False,,,,,0,1648491220,,0,{},i2gt5ml,True,t3_tjm0ga,False,True,t1_i2b9589,/r/haskell/comments/tjm0ga/ghc_proposal_breakage_should_we_proceed/i2gt5ml/,1648491238,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
40.0,[],False,,dun-ado,,,[],,,,text,t2_ihltqlra,False,False,"Yep, there’s a highly readable seminal paper on that topic.",48f67d2699d98bd42b27d89a309d0a7a24c17d83,True,False,,,,,0,1648491186,,0,{},i2gt2r3,False,t3_tqbba5,False,False,t1_i2gssbl,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2gt2r3/,1648491200,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
41.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,Data types a la carte is the main topic of this blog post.,8760dec984d88d9e26bc1b4f8a5882420ed48da5,True,False,,,,,0,1648491065,,0,{},i2gssbl,False,t3_tqbba5,False,True,t1_i2gg6ae,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2gssbl/,1648491079,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
42.0,[],False,,goldfirere,,,[],,,,text,t2_culpc,False,False,"The proposal is accepted. I believe Csongor Kiss (don't know his Reddit username offhand) has an implementation, but I'm not sure he's got the time/motivation to actually get it merged.",a3afd2d80db57b97bce7b9e6641f30f0b5a4868b,True,False,,,,,0,1648491055,,0,{},i2gsrg5,True,t3_tjm0ga,False,True,t1_i2baa66,/r/haskell/comments/tjm0ga/ghc_proposal_breakage_should_we_proceed/i2gsrg5/,1648491071,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
43.0,[],False,,odnua,,,[],,,,text,t2_41qy2wit,False,False,"Swarm is a fairly small programming game written in Haskell and it has a lot of easy Issues 🙂

https://github.com/swarm-game/swarm/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+label%3A%22C-Low+Hanging+Fruit%22",0a0e0c0d44d6c121a5724ec19abfd88027ef092d,True,False,,,,,0,1648489657,,0,{},i2gpeoy,False,t3_tq6myc,False,True,t3_tq6myc,/r/haskell/comments/tq6myc/searching_for_opensource_project_for_training/i2gpeoy/,1648489670,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
44.0,[],False,,dun-ado,,,[],,,,text,t2_ihltqlra,False,False,"You may be interested in the following highly readable papers:

http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf

https://bahr.io/pubs/files/bahr14wgp-paper.pdf",ee9a1b492828125a0c951ae27e063a8f1aa3e5d1,True,False,,,,,0,1648485932,,0,{},i2gg6ae,False,t3_tqbba5,False,True,t3_tqbba5,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2gg6ae/,1648485951,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
45.0,[],False,,sccrstud92,,,[],,,,text,t2_7v2vu,False,False,"For situations where you want to produce an element of some type that is a member of a type class, but you don't know at compile-time which type you are gonna get, it is fairly common to see a wrapper around a hidden existential (I call it the ""Some- pattern"", but idk the name).

Examples:

* Type-level Naturals - https://hackage.haskell.org/package/base-4.16.1.0/docs/GHC-TypeLits.html#t:SomeNat
* Symbols - https://hackage.haskell.org/package/base-4.16.1.0/docs/GHC-TypeLits.html#t:SomeSymbol

Could this pattern be used here? If so, parsers could produce `SomeExpr`s and you can consume those with `withSomeExpr`, and then you don't have to deal with the ""Data types a la carte"" injection constructors.",04d6fc71d08632f8fe5d5201e88032afe3a63ce3,True,False,,,,,0,1648485698,,0,{},i2gflei,False,t3_tqbba5,False,True,t3_tqbba5,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2gflei/,1648485712,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
46.0,[],False,,sccrstud92,,,[],,,,text,t2_7v2vu,False,False," &gt; Alright, a hint. Imagine you want to write a function that parses a string and produces an expression. What would the type of this function be? Specifically, what is its return type?

Does the finally tagless paper address this problem?",34d25971dc268d166ad75f2322e41cb3e2ce6119,True,False,,,,,0,1648484676,,0,{},i2gd04z,False,t3_tqbba5,False,True,t3_tqbba5,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2gd04z/,1648484693,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
47.0,[],False,,el_micha,,,[],,,,text,t2_95sh7,False,False,"Cool stuff. 

The trick with the nested types is also used and explained in this [Introduction to Recursion Schemes](https://blog.sumtypeofway.com/posts/introduction-to-recursion-schemes.html), which I read a few weeks ago and digested only partly. To see the same trick in a new context with a new explanation is a great learning experience.",fe6dff82851f27f3cb66149cf6a219d41dc3929c,True,False,,,,,0,1648483956,,0,{},i2gb77m,False,t3_tqbba5,False,True,t3_tqbba5,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2gb77m/,1648483973,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
48.0,[],False,,WarDaft,,,[],,,,text,t2_cspxi,False,False,"I love recursion strategies, but in practice I've kinda preferred the simpler case of factoring your datatypes by structure:

    {-# LANGUAGE OverloadedRecordDot, NameFieldPuns #-}
    data Expr b u c
        = Const { c :: c }
        | Unary { op :: u, x :: Expr b u c }
        | Binary { op :: b, x :: Expr b u c, y :: Expr b u c }
    
    data Evaler u b c o
        = Ev { c :: c -&gt; o, u :: u -&gt; o -&gt; o, b :: b -&gt; o -&gt; o -&gt; o }
    
    eval f e@(Const _) = f.c e.c
    eval f e@(Unary _ _) = f.u e.u $ eval f e.x
    eval f e@(Binary _ _ _) = f.b e.b (eval f e.x) (eval f e.y)
    
    baseStringy :: Evaler Void Add Double String
    baseStringy = Ev {c = show, u = undefined, b} where
        b x y = concat [x,"" + "",y]
    
    (|||) = either
    type a ||| b = Either a b
    
    data Factorial = F
    
    extStringy :: 
        Evaler (Factorial ||| Void) (Mult ||| Add) Double String
    extStringy = Ev {c = baseStringy.c, u, b} where
        u = (++""!"") ||| baseStringy.u
        b = (\x y -&gt; concat [x,"" * "",y]) ||| baseStringy.b
    
    -- In fact, this suggests a general extension strategy
    
    extEvaler c u b e = ev {c = c e.c, u = u e.u, b = b e.b}",40f85179cdbe41fd2583de420702a71fc0a16468,True,False,,,,,0,1648483719,,0,{},i2galy0,False,t3_tqbba5,False,True,t3_tqbba5,/r/haskell/comments/tqbba5/more_thoughts_on_the_expression_problem_in_haskell/i2galy0/,1648483733,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
49.0,[],False,,blyatmobilebr,,,[],,,,text,t2_4kugqv4r,False,False,"Thanks for clarifying, I really appreciate it 🙂",19fdf0d086c16b45449a08fb4a43e685adb27323,True,False,,,,,0,1648483474,,0,{},i2g9zs5,False,t3_t3zw0x,False,True,t1_i2fqque,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i2g9zs5/,1648483487,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
50.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"I was initially turned off by liquid Haskell's dependency on proprietary services, which DT languages of the time didn't have.  (I believe liquid Haskell not longer requires any non-Free Software to be effective.)

I believe there are also known limitations where refinement-type-like-proof-search still fails to find a simple variant of an existing proof that human programmers can adapt rather quickly.

Finally, you can have the call-out-to-external-verifier be a tactic / elaborator reflection script while still providing full dependent types.  I.e. refinement types are a strictly limited subset of DTs.",0793b77d8e217a288034c83268028268db47d849,True,False,,,,,0,1648481685,,0,{},i2g5jti,False,t3_tnrsg7,False,True,t1_i2ftpnk,/r/haskell/comments/tnrsg7/the_haskell_interlude_11_simon_peyton_jones/i2g5jti/,1648481698,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
51.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"Like physics and other sciences, I think programming touches on the non-axiomatic, non-definitional world outside of mathematics.

Computer Science is a field of Mathematics, though. :)",7ee71f4aeab88860d600b3f5d024a12aca04099a,True,False,,,,,0,1648480592,,0,{},i2g2vqe,False,t3_t3zw0x,False,True,t1_i2frq6d,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i2g2vqe/,1648480606,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
52.0,[],False,,WarDaft,,,[],,,,text,t2_cspxi,False,False,"Why would this not just be done by using deriving via to specify which particular generic behaviour you are favouring with the Sum? 

Isn't this the ***entire point*** of deriving via? To tell the compiler how to derive instances when there's no clear way to do so without some developer annotation?",1e2b59aaefe1804e6cf0eedf086604b6f2f6c458,True,False,,,,,0,1648479495,,0,{},i2g09z3,False,t3_tpzy07,False,True,t3_tpzy07,/r/haskell/comments/tpzy07/generic_applicative/i2g09z3/,1648479506,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
53.0,[],False,,johnorford,,,[],,,,text,t2_14ajvp,False,False,my gut feeling is  refinement types gives you alot of power without much more effort. was always confused how dependent types got more hype..,ebf5c80b2e9e1b215e8d9e6bc4858ff63b6b350a,True,False,,,,,0,1648476666,,0,{},i2ftpnk,False,t3_tnrsg7,False,True,t1_i2c721x,/r/haskell/comments/tnrsg7/the_haskell_interlude_11_simon_peyton_jones/i2ftpnk/,1648476678,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
54.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"I'd be inclined to say that all programming is math, but maybe that is a bit of an extreme opinion.",1d0a94720eb3550b0cc4f8780581df9d740231be,True,False,,,,,0,1648475764,,0,{},i2frq6d,False,t3_t3zw0x,False,True,t1_i2fiqr8,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i2frq6d/,1648475778,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
55.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"&gt; since the instance is not unique. Seeing 'derive Applicative' for a Sum type doesn't tell me how it works

`derive Applicative via DescriptiveNewtype` (`DerivingVia`) deals with the practical aspects of both sides of that.

Choosing one of the (many, non-unique) instances to be ""canonical"" is something we already have to deal with in the ecosystem.  So, to don't see why theoretical idealism should prevent do so for `Applicative`.  (This addresses the theoretical issues raise the the first part of the quoted text.)",24204d475ddd4f2c58967916f6c0557f771f9d1b,True,False,,,,,0,1648475660,,0,{},i2frhxq,False,t3_tpzy07,False,True,t1_i2f33pf,/r/haskell/comments/tpzy07/generic_applicative/i2frhxq/,1648475672,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
56.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"I think it's worth it to understand Haskell in terms of the lambda calculus, with very few exceptions, due to how laziness and reduction steps are related.

Category theory can be useful in setting up analogies, but rarely maps directly to code.  Not all monads are `Monads`; and you are allowed to provide a `Monad` instance for things where `(&gt;=&gt;)` is not associative.

Other branches of math are generally only useful if you are writing code (in _any_ language) that users/implements that branch of math.",a8c07e6dffe00e0504a97b165d3158e9c94a88ab,True,False,,,,,0,1648475312,,0,{},i2fqque,False,t3_t3zw0x,False,True,t1_i2fiqr8,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i2fqque/,1648475322,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
57.0,[],False,,el_micha,,,[],,,,text,t2_95sh7,False,False,"Ah yes, right. I don't know why I thought this would consume input. 
```number = many1 digit``` fixed my problem. Thanks a lot!",09bb24703a1f5889eb4720b0e8fcae3675445de5,True,False,,,,,0,1648471258,,0,{},i2fisve,False,t3_t3zw0x,False,True,t1_i2ff2gq,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i2fisve/,1648471272,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
58.0,[],False,,blyatmobilebr,,,[],,,,text,t2_4kugqv4r,False,False,Is learning Math a requirement to learn Haskell or understand it fully? And how could learning math help me with my Haskell learning?,bbb1b352bf48aea38e9bc45b69a2227c69917662,True,False,,,,,0,1648471225,,0,{},i2fiqr8,False,t3_t3zw0x,False,True,t3_t3zw0x,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i2fiqr8/,1648471236,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
59.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"`many digit` does accept the empty string, right? Shouldn't you use `some digit`?",c5d3dd8dc8afa574238af8d6f0424a03a22398c0,True,False,,,,,0,1648469049,,0,{},i2ff2gq,False,t3_t3zw0x,False,True,t1_i2fevy8,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i2ff2gq/,1648469063,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
60.0,[],False,,el_micha,,,[],,,,text,t2_95sh7,False,False,"I tried it, and ```atom``` does not parse the empty string. 
Yes, ```number = many digit```, but this again consumes input.",9fe88f2d77a15f6bb500914fa71744d6533126cd,True,False,,,,,0,1648468940,,0,{},i2fevy8,False,t3_t3zw0x,False,False,t1_i2fd1yh,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i2fevy8/,1648468952,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
61.0,[],False,,cameleon,,,[],,,,text,t2_3c83v,False,False,"Yes, it's on my github; the specific change is [https://github.com/hesselink/dayta/commit/01df9c6adfb0bd20a0d208b13b3b219f24137bde](https://github.com/hesselink/dayta/commit/01df9c6adfb0bd20a0d208b13b3b219f24137bde). I don't think there's anything unexpected, most of the changes are ones you mention in the article.",9f352181616169e127d199685eee2e87d57e6112,True,False,,,,,0,1648468813,,0,{},i2feojq,False,t3_tpo6u8,False,True,t1_i2fejfz,/r/haskell/comments/tpo6u8/breakage_and_deprecation_cycle_policies/i2feojq/,1648468828,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
62.0,[],False,,tomejaguar,,,[],,,,text,t2_45sug,False,False,"That's really great to hear! Is your project available for me to look at?  If so I'd love to take a look to see exactly what you had to do to upgrade, so I can improve my understanding of user needs for future upgrades.",07770ee51c5041a4673ae76fc7741adfe2de9d8a,True,False,,,,,0,1648468726,,0,{},i2fejfz,True,t3_tpo6u8,False,True,t1_i2fd8bf,/r/haskell/comments/tpo6u8/breakage_and_deprecation_cycle_policies/i2fejfz/,1648468742,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
63.0,[],False,,cameleon,,,[],,,,text,t2_3c83v,False,False,"Slightly off topic, but I just upgraded a hobby project across a major opaleye version, and I want to say thank you for the very good notes to help me upgrade. While there was some breakage as you mention in your policy, the good deprecation messages, as well as the informative changelog, made the upgrade easy to do. Thank you!",4f217d0798c95bb23254be2ab52426bbd88b6931,True,False,,,,,0,1648467889,,0,{},i2fd8bf,False,t3_tpo6u8,False,False,t3_tpo6u8,/r/haskell/comments/tpo6u8/breakage_and_deprecation_cycle_policies/i2fd8bf/,1648467900,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
64.0,[],False,,Syrak,,,[],,,,text,t2_4atne,False,False,"Could `number` be accidentally be using `many`? Otherwise I'm not sure what could be causing this, so it's probably worth providing a reproducible example.",d7151b8706bfc5c8738e55bc41e352528bba575c,True,False,,,,,0,1648467771,,0,{},i2fd1yh,False,t3_t3zw0x,False,True,t1_i2da8y5,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i2fd1yh/,1648467788,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
65.0,[],False,,Odd-Fox-8410,,,[],,,,text,t2_7pefb5kd,False,False,"Thank you for the resources, and the help is much appreciated. I'll try and look into parsers, and get a firm grip on that before I tackle Template Haskell.",b06d7c42be8fab685b3f7138953d0b6afe5294f1,True,False,,,,,0,1648466802,,0,{},i2fbm9o,True,t3_tq3p9p,False,False,t1_i2f9zdw,/r/haskell/comments/tq3p9p/what_do_i_need_to_start_writing_an_extension_or/i2fbm9o/,1648466813,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
66.0,[],False,,j_mie6,,,[],,,,text,t2_pcp1xu1,False,False,"Depends on your existing knowledge of Haskell and stuff like monads, applicatives, etc. I haven't gotten around to writing a tutorial for Parser Combinators yet (I'd actually like to write a book about them at some point) in Haskell, but I do have this wiki here ( https://github.com/j-mie6/Parsley/wiki/Guide-to-Parser-Combinators ) for my parser combinator library in Scala, that might be of some help. A Haskell version of a lot of the later material there can be found in this paper https://dl.acm.org/doi/10.1145/3471874.3472984. The paper assumes some familiarity with Parser Combinators, the wiki does not (but is written in Scala): it's the resource I use to teach my 2nd year undergrads about Parser Combinators for their compilers project. It doesn't talk about monads/applicatives at all. I'm more than happy to answer any questions you have about either of those two.

For learning about them, I'd recommend sticking to parsec and not megaparsec (a better library, but one that is a bit trickier to learn starting from ground-zero, I think). I'm trying to think of a resource for that off-hand that isn't a blog/paper that describes how to _make_ such a library and not how to _use_ one (hence why I linked to the two above!), but I'm struggling! Certainly though, Graham Hutton has a few tutorials talking about parser combinators, but not necessarily how they are used in practice (a notable hole in the literature). That all said, you might find this tutorial by the writer of megaparsec useful (if a little dense if you don't know much about monads just yet!): https://markkarpov.com/tutorial/megaparsec.html

Hopefully that helps, as I said, I'm happy to answer any questions you have about them, they are my jam.",7b6cffb89440f9dc4b7a6c36b98486e8f35ef56d,True,False,,,,,0,1648465623,,0,{},i2f9zdw,False,t3_tq3p9p,False,True,t1_i2f8j1q,/r/haskell/comments/tq3p9p/what_do_i_need_to_start_writing_an_extension_or/i2f9zdw/,1648465637,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
67.0,[],False,,OuiOuiKiwi,,,[],,,,text,t2_16f7sl7i,False,False,https://goodfirstissue.dev/,10bc996af61c473f695a1e1e051cc303f9b10784,True,False,,,,,0,1648465108,,0,{},i2f9aot,False,t3_tq6myc,False,True,t3_tq6myc,/r/haskell/comments/tq6myc/searching_for_opensource_project_for_training/i2f9aot/,1648465122,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
68.0,[],False,,Odd-Fox-8410,,,[],,,,text,t2_7pefb5kd,False,False,"That's awesome, thanks. Can you point me to some resources to started with Parsers?",efe62918501114f3d062c19f50f2e8a5700596d6,True,False,,,,,0,1648464523,,0,{},i2f8j1q,True,t3_tq3p9p,False,True,t1_i2ezihq,/r/haskell/comments/tq3p9p/what_do_i_need_to_start_writing_an_extension_or/i2f8j1q/,1648464537,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
69.0,[],False,,thefybe,,,[],,,,text,t2_118sdr,False,False,"I think deriving Applicative or Monad generically should not be supported, since the instance is not unique. Seeing 'derive Applicative' for a Sum type doesn't tell me how it works, as I'd have to understand the Applicative (Sum f g) instance. For product types it is Zip-like (I assume) which is sensible. But even for a simple type such as 'Either a b' there are many possible implementations.

It also makes the instances unstable under refactoring. If there is some bias in which side to pick,
the two datatypes 'data Side a = SideL a | SideR a'
and 'data Side a = SideR a | SideL a' will have different derived implementations.",16dbcad46aa480feb498935fbf0e7f392e40849f,True,False,,,,,0,1648460024,,0,{},i2f33pf,False,t3_tpzy07,False,True,t3_tpzy07,/r/haskell/comments/tpzy07/generic_applicative/i2f33pf/,1648460035,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
70.0,[],False,,maeevick,,,[],,,,text,t2_4rpfujtg,False,False,👀,e7f901c059d3385c5c4867829706272ddfa9e6b3,True,False,,,,,0,1648457891,,0,{},i2f0qv1,False,t3_tpsbti,False,True,t3_tpsbti,/r/haskell/comments/tpsbti/new_early_access_book_functional_programming_for/i2f0qv1/,1648457906,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
71.0,[],False,,j_mie6,,,[],,,,text,t2_pcp1xu1,False,False,"urgh, sorry, Reddit mangled my comment when I edited it. Fixed now",77246791bfeeca46a4b3daca97e5457c31ba0495,True,False,,,,,0,1648457210,,0,{},i2f000p,False,t3_tq3p9p,False,True,t1_i2ezihq,/r/haskell/comments/tq3p9p/what_do_i_need_to_start_writing_an_extension_or/i2f000p/,1648457222,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
72.0,[],False,,j_mie6,,,[],,,,text,t2_pcp1xu1,False,False,"Ah, I see. These are definitely things that require the gnarly details of TH (or writing extensions), which isn't something I've played much with. But my advice is that writing extensions is going to be really quite tricky as a beginner: writing plugins might be slightly easier for more limiting (and I can't say it's documented much better in fairness). Quasiquoters are not too hard to write, in comparison, I don't think. However for though you do need some knowledge about parsers and how to write them. For compiler knowledge in general that's a great place to start. I'm happy to lend a hand with getting you started on the road to learning Parser Combinators (commonly used for quasiquoters I believe): it happens to be my entire specialism.

How I would have changed my answer would have been if you were thinking about how to optimise/generate Haskell code for some ""Domain-Specific Language. For that purpose you don't need the full power of template haskell, you only need the Typed Template Haskell subset, which imo is far less daunting to learn: there are two main operations: `$$(splice)` and `[||quote|]`. Still a bit to learn there, but it's a lot easier to get the intuition for that. Happy to elaborate if you're interested (that happens to be the other half of my specialism)",3aff54d57d0c4cdf7bd1a83d78fdfdf643f41a2f,True,False,,,,,0,1648456767,,0,{},i2ezihq,False,t3_tq3p9p,False,True,t1_i2eyst8,/r/haskell/comments/tq3p9p/what_do_i_need_to_start_writing_an_extension_or/i2ezihq/,1648456778,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
73.0,[],False,,Odd-Fox-8410,,,[],,,,text,t2_7pefb5kd,False,False,"Interesting. Can you describe what it could depend upon?

Say I wanted to create a quasiquoter for the Cypher query language, or if I wanted to do something like OverloadedStrings.",452f042b7293105eddeebe7ba58c288e4e4dd299,True,False,,,,,0,1648456122,,0,{},i2eyst8,True,t3_tq3p9p,False,True,t1_i2exa1c,/r/haskell/comments/tq3p9p/what_do_i_need_to_start_writing_an_extension_or/i2eyst8/,1648456134,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
74.0,[],False,,j_mie6,,,[],,,,text,t2_pcp1xu1,False,False,The application you have in mind will change how I would answer this question,c0891dd4e674823a1437e73f9ca33fb6f9f7714d,True,False,,,,,0,1648454743,,0,{},i2exa1c,False,t3_tq3p9p,False,True,t3_tq3p9p,/r/haskell/comments/tq3p9p/what_do_i_need_to_start_writing_an_extension_or/i2exa1c/,1648454756,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
75.0,[],False,,Odd-Fox-8410,,,[],,,,text,t2_7pefb5kd,False,False,Chiming in with Neo4j and Hasbolt.,f2b37a6efd8a8ec02718fa17aec90ce195dab58d,True,False,,,,,0,1648452414,,0,{},i2eul0p,False,t3_toj7lo,False,True,t3_toj7lo,/r/haskell/comments/toj7lo/which_nosql/i2eul0p/,1648452427,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
76.0,[],False,,ttmp3,,,[],,,,text,t2_fi7kd,False,False,Related discussion from HN: https://news.ycombinator.com/item?id=16453192,6cb99a0e937a5c3050d11e75e6d79ea100ea5c4f,True,False,,,,,0,1648448449,,0,{},i2epkwh,False,t3_tpsbti,False,True,t3_tpsbti,/r/haskell/comments/tpsbti/new_early_access_book_functional_programming_for/i2epkwh/,1648448463,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
77.0,[],False,,NateReinarWindwood,,,[],,,,text,t2_2vrrzjjg,False,False,"Pointfree is easier to understand. And it’s only longer because of the import, the function itself is shorter. And `(.:)` is often useful anyway and should be in Prelude.",37ff63d0bc6cb481fa90c24817774a2bf0154393,True,False,,,,,0,1648434865,,0,{},i2e2pwp,False,t3_tpa9t2,False,True,t1_i2drshd,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i2e2pwp/,1648434882,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
78.0,[],False,,cdsmith,,,[],,,,text,t2_1trov,False,False,That's not my ideal.  It's longer *and* harder to understand.,903377bbc44b276a3aea3a4225e37f728a201eb4,True,False,,,,,0,1648429442,,0,{},i2drshd,False,t3_tpa9t2,False,True,t1_i2a01gz,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i2drshd/,1648429454,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
79.0,[],False,,Axman6,,,[],,,,text,t2_37j8m,False,False,"A large part of my last job was built on top of lambdas reading and writing to both DynamoDB and SQS, and it was a great experience. Amazonka is amazing, u/brnhy (and recently u/_jackdk_) have been doing amazing work recently working on getting v2 out the door.",9d696dd1277b411e47a5db4c3999c493b75a92eb,True,False,,,,,0,1648428300,,0,{},i2dpffo,False,t3_toj7lo,False,True,t1_i271wq0,/r/haskell/comments/toj7lo/which_nosql/i2dpffo/,1648428312,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
80.0,[],False,,howtonotwin,,,[],,,,text,t2_niyg2,False,False,"The ""check"" for consuming a coinductive structure is that you can't. You simply can't recurse down a coinductive value and expect to form a total function. You need to either have some inductive ""fuel"" to burn on the way or be building another coinductive structure (in which case the appropriate guardedness condition applies).

`ana coalg'` is either partial or total depending on the definition of `[]`. If the codomain contains all the infinite lists, then of course `ana coalg'` successfully (and always) returns one (and your idea about the decreasing seed is counterproductive; if the seed in a corecursion must be decreasing then you've banned us from *reaching* the infinite values!). If `[]` consists of finite lists, then `ana coalg'` is partial. In Haskell, though the default is to include infinite values, when analyzing Haskell we often choose to restrict ourselves to finite ones. Defining what an infinite value exactly should be may be a bit arbitrary, but I wouldn't say it somehow makes them ""not worthy of existing"".",3b37f88bf43fe3f746b78c357d7c1a09ccf440a3,True,False,,,,,0,1648426640,,0,{},i2dly46,False,t3_t3zw0x,False,True,t1_i1ac4c8,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i2dly46/,1648426656,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
81.0,[],False,,SSchlesinger,,,[],,,,text,t2_jggeg,False,False,These look amazing — I never knew I needed this category of “Learn X with Functional Programming” book but now I’m desperate to hear of more in the genre,c1023eb4a13c631a7c31aeee197ab997b85a921c,True,False,,,,,0,1648423930,,0,{},i2dga4u,False,t3_tpsbti,False,False,t1_i2d4j1t,/r/haskell/comments/tpsbti/new_early_access_book_functional_programming_for/i2dga4u/,1648423948,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
82.0,[],False,,el_micha,,,[],,,,text,t2_95sh7,False,False,"**Situation**

I want to parse expressions like 

```
data Expr a = Lit a
            | Var Char
            | Neg (Expr a)
            | Inv (Expr a)
            | Sum [Expr a]
            | Prod [Expr a]
            deriving Show
```

using parsec. For the ```Prod``` constructor, I want to accept inputs like```a*b```, ```a/b``` but also ```ab```, where the ```*``` is implied. 

The first two cases work with the following code:
```
pointOp :: GenParser Char st Char
pointOp = do ws &gt;&gt; (char '*' &lt;|&gt; char '/') &lt;* ws

factor :: GenParser Char st IntExp
factor = do op &lt;- pointOp
            term &lt;- atom
            if op == '/' then return (Inv term) else return term

prod :: GenParser Char st IntExp
prod = do first &lt;- atom
          rest &lt;- many1 factor
          return $ Prod (first : rest)
```

where ```ws``` discards whitespace and ```atom``` can take these forms:

```
lit :: GenParser Char st IntExp
lit = do res &lt;- number
         return (Lit (read res))

var :: GenParser Char st IntExp
var = do res &lt;- oneOf $ ['a'..'z']++['A'..'Z']
         return (Var res)

group :: GenParser Char st IntExp
group = surround expr '(' ')'

atom :: GenParser Char st IntExp
atom = ws &gt;&gt; (group &lt;|&gt; var &lt;|&gt; lit) &lt;* ws
[...]
expr :: GenParser Char st IntExp
expr = try sum' &lt;|&gt; try prod &lt;|&gt; atom
```

** Problem ** 

If I change ```prod``` to also accept a factor without an op, parsec thinks it is consuming empty strings repeatedly:
```
prod :: GenParser Char st IntExp
prod = do first &lt;- atom
          rest &lt;- many1 (factor **&lt;|&gt; atom**)
          return $ Prod (first : rest)
```
gives 
&gt; Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string.

[This thread](https://github.com/jgm/pandoc/issues/1342) mentions parsec not knowing it consumes anything, but I do not understand why or how I can fix it. Any help is appreciated.",2cb99f4f4ef189f0cf502fe8e204c957eda773dd,True,False,,,,,0,1648421005,,0,{},i2da8y5,False,t3_t3zw0x,False,True,t3_t3zw0x,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i2da8y5/,1648421019,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
83.0,[],False,,Bombastry,,,[],,,,text,t2_8khpu,False,False,"I think the books *Functional Differential Geometry* and *Wtructure and Interpretation of Classical Mechanics* by Sussman and Wisdom may be more in line with what you're looking for, albeit in Scheme rather than Haskell.",85e9a9e37cc39f034309c851cc64c472c8987809,True,False,,,,,0,1648418180,,0,{},i2d4j1t,False,t3_tpsbti,False,True,t1_i2cwxzu,/r/haskell/comments/tpsbti/new_early_access_book_functional_programming_for/i2d4j1t/,1648418192,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
84.0,[],False,,agumonkey,,,[],,,,text,t2_62nu4,False,True,"It might be different but I've read monoidal analysis of computing in the 60s (an article about EACS editor M. Nivat). Always pleased to see that.

ps: https://ncatlab.org/nlab/show/monad+(in+linguistics) reddit ate your closing paren",15e05be4e561f6b09d9ddb5335ebbd37807c1e4f,True,False,,,,,0,1648417634,,0,{},i2d3e1n,False,t3_tpsbti,False,True,t1_i2d3490,/r/haskell/comments/tpsbti/new_early_access_book_functional_programming_for/i2d3e1n/,1648417645,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
85.0,[],False,,Droneslut,,,[],,,,text,t2_wee7b,False,True,"It's fantastic. The only thing it's missing is, weirdly enough, a discussion of the use of [monads in linguistics](https://ncatlab.org/nlab/show/monad+(in+linguistics))",ce16834b523f6bd4cb4fcd59c01c66de127bc005,True,False,,,,,0,1648417504,,0,{},i2d3490,True,t3_tpsbti,False,True,t1_i2d0tps,/r/haskell/comments/tpsbti/new_early_access_book_functional_programming_for/i2d3490/,1648417521,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
86.0,[],False,,RecDep,,,[],,,,text,t2_6bcd1,False,False,    listProduct = (sum .) . zipWith (*),a655ecbc95527fb18c33cbd13f96be32ea8e4149,True,False,,,,,0,1648417085,,0,{},i2d28kh,False,t3_tpa9t2,False,True,t1_i29s6bz,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i2d28kh/,1648417102,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
87.0,[],False,,agumonkey,,,[],,,,text,t2_62nu4,False,True,"Oh I never heard of this book from van eijck 

https://staff.fnwi.uva.nl/d.j.n.vaneijck2/cs/",07c66753f0c0105b7b5b1fde77732a1cd02e800f,True,False,,,,,0,1648416408,,0,{},i2d0tps,False,t3_tpsbti,False,True,t3_tpsbti,/r/haskell/comments/tpsbti/new_early_access_book_functional_programming_for/i2d0tps/,1648416419,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
88.0,[],False,,Droneslut,,,[],,,,text,t2_wee7b,False,True,"I can definitely understand that view. The course that this book is based off of is a computational physics course that is given to physics students after they've completed two or three classes so it definitely emphasizes programming as new and takes a lot of physical intuition for granted. The author has an old draft from 2018 of the book [on his site](https://quantum.lvc.edu/walck/PFP-0.1.pdf) if you want to check it out. I don't yet know how it matches up compared to the finished book but you could try checking it out and seeing if it's too introductory for you to find enjoyable. To be fair there's like 20 pages of vector integrals at the back of the book so I think there is a lot to be read beyond ""here is what a type is"" hahah. But I do get your point.",43f8e71456d97e0484a3a1284279d6f7594faede,True,False,,,,,0,1648415741,,0,{},i2czenm,True,t3_tpsbti,False,True,t1_i2cwxzu,/r/haskell/comments/tpsbti/new_early_access_book_functional_programming_for/i2czenm/,1648415756,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
89.0,[],False,,TheCommieDuck,,,[],,,,text,t2_52eu3,False,False,"My disappointment with all these things is that they're always ""learn haskell coming from another field"" rather than ""learn another field coming from haskell"".

I'm sure the book will be excellent, but when half of it is ""here is what a type is"" I know it's not aimed at me",d9d995592885fd773c329f620ecf59337f13316f,True,False,,,,,0,1648414594,,0,{},i2cwxzu,False,t3_tpsbti,False,True,t3_tpsbti,/r/haskell/comments/tpsbti/new_early_access_book_functional_programming_for/i2cwxzu/,1648414609,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
90.0,[],False,,WarDaft,,,[],,,,text,t2_cspxi,False,False,"    a ~= b = getId a == getId b
    -- or better yet with OverloadedRecordDot
    a ~= b = a.id == b.id

... because \~= resembles ≃ which is the context sensitive form of equality or ""the same for your current purposes"" -- also note, that with `OverloadedRecordDot`, `a` and `b` do not have to be the same type, if their ID is the same type, it's statically duck typed correctly:

     &gt;&gt; :t (~=)
(~=)
  :: (Eq a, GHC.Records.HasField ""id"" r1 a,
      GHC.Records.HasField ""id"" r2 a) =&gt;
     r1 -&gt; r2 -&gt; Bool
    

Note that this completely subsumes the purpose of `Entity` unless you have other methods in the class that you haven't mentioned.",b9ecadc3b5010d831f04017a33dd4b1d70817cff,True,False,,,,,0,1648412874,,0,{},i2ct6n9,False,t3_tnmkpe,False,True,t3_tnmkpe,/r/haskell/comments/tnmkpe/defining_the_eq_instance_for_a_class/i2ct6n9/,1648412889,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
91.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"&gt; However, once you have a Natural,

You gotta be careful here... laziness means a `Natural` ""value"" might still ""contain"" the `fromInteger (negate 42)` call.",bb838cfccf20c8cec1e570ed15812b4312b66c2a,True,False,,,,,0,1648411508,,0,{},i2cq687,False,t3_tpby52,False,True,t1_i2cm2ua,/r/haskell/comments/tpby52/recursive_factorial_function_error/i2cq687/,1648411524,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
92.0,[],False,,fegu,,,[],,,,text,t2_1v9b,False,False,Thanks! I as well will use this.,e2e2d646245a66cd30c55efe6c2499acc5412520,True,False,,,,,0,1648410551,,0,{},i2co0f4,False,t3_tlvopj,False,True,t1_i22larw,/r/haskell/comments/tlvopj/looking_for_svg_library_recommendations/i2co0f4/,1648410567,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
93.0,[],False,,NateReinarWindwood,,,[],,,,text,t2_2vrrzjjg,False,False,"My way looks better x)

And most of the time time you don’t need to go further than `(.)` and `(.:)`. Alternatively, there is this approach: https://www.reddit.com/r/haskell/comments/m52f6o/is_it_possible_to_generalize_function_composition/",182c6b6f805080988cca2519e42a1949273f32de,True,False,,,,,0,1648410469,,0,{},i2cntmd,False,t3_tpa9t2,False,True,t1_i2bnv2p,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i2cntmd/,1648410486,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
94.0,[],False,,temporary112358,,,[],,,,text,t2_fnog5dtk,False,False,"`fromInteger :: Integer -&gt; Natural` will throw an exception, because the `Natural` type cannot represent negative numbers. However, once you have a `Natural`, `safeFact :: Natural -&gt; Natural` will never throw an exception. This is pretty much analogous to `fromList` in `Data.List.NonEmpty`: the initial conversion might fail, but once you have the more structured input type (`Natural` and `NonEmpty`), operations using that type will not fail. In contrast, returning `Maybe Int` means that you have to check the result every time, even when you know the input is valid (nonnegative).",c997430c31cb4c27995c17e7a3dda110b03827ea,True,False,,,,,0,1648409706,,0,{},i2cm2ua,False,t3_tpby52,False,True,t1_i2bpysp,/r/haskell/comments/tpby52/recursive_factorial_function_error/i2cm2ua/,1648409718,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
95.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,I think the problem is that instances you write that way don't work for the original type class.,5c55cd77ac099673c0189df03a8010b5b4105410,True,False,,,,,0,1648405423,,0,{},i2cbwv4,False,t3_tpo6u8,False,True,t1_i2cb5n0,/r/haskell/comments/tpo6u8/breakage_and_deprecation_cycle_policies/i2cbwv4/,1648405437,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
96.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"With `ConstraintKinds` you can just use normal type synonyms:

    type MyEq a = Eq a",85156c43515a9a74ab091aa52642df1feb74e820,True,False,,,,,0,1648405310,,0,{},i2cbn58,False,t3_tpo6u8,False,True,t1_i2cb5n0,/r/haskell/comments/tpo6u8/breakage_and_deprecation_cycle_policies/i2cbn58/,1648405324,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
97.0,[],False,,tomejaguar,,,[],,,,text,t2_45sug,False,False,"Ah interesting, that might work! I have never tried it.",b109c163ad4ea83b7e31819f3eafe37bd34089da,True,False,,,,,0,1648405160,,0,{},i2cb9wl,True,t3_tpo6u8,False,True,t1_i2cb5n0,/r/haskell/comments/tpo6u8/breakage_and_deprecation_cycle_policies/i2cb9wl/,1648405174,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
98.0,[],False,,SSchlesinger,,,[],,,,text,t2_jggeg,False,False,An empty typeclass with one superclass and one empty instance with the same superclass as a constraint in the head — lets you make a typeclass synonym which is just as useful as the original,920d8394e645aecc826d69d64fa20cedb1290ae4,True,False,,,,,0,1648405111,,0,{},i2cb5n0,False,t3_tpo6u8,False,True,t1_i2cayeh,/r/haskell/comments/tpo6u8/breakage_and_deprecation_cycle_policies/i2cb5n0/,1648405129,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
99.0,[],False,,tomejaguar,,,[],,,,text,t2_45sug,False,False,What's the typeclass synonym trick?,71da023531039329802019014b37858534b3a642,True,False,,,,,0,1648405030,,0,{},i2cayeh,True,t3_tpo6u8,False,True,t1_i2c9rcx,/r/haskell/comments/tpo6u8/breakage_and_deprecation_cycle_policies/i2cayeh/,1648405042,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
100.0,[],False,,SSchlesinger,,,[],,,,text,t2_jggeg,False,False,Would using the typeclass synonym trick help with the class deprecation problem with type synonyms?,63800badf99d2dc20dc1022f233cb03e27c5bd2f,True,False,,,,,0,1648404535,,0,{},i2c9rcx,False,t3_tpo6u8,False,True,t3_tpo6u8,/r/haskell/comments/tpo6u8/breakage_and_deprecation_cycle_policies/i2c9rcx/,1648404552,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
101.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,The advantage of Liquid Haskell is that you don't have to write the proofs yourself. So even if Haskell had dependent types then it would still be beneficial to have them basically hooked up to an SMT solver to automatically generate proofs.,53e78aefd342a4bec4fd9503ac041a0c61c203ca,True,False,,,,,0,1648403427,,0,{},i2c721x,False,t3_tnrsg7,False,True,t1_i2bkzx3,/r/haskell/comments/tnrsg7/the_haskell_interlude_11_simon_peyton_jones/i2c721x/,1648403441,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
102.0,[],False,,tomejaguar,,,[],,,,text,t2_45sug,False,False,There is also the [three release policy](https://gitlab.haskell.org/haskell/prime/-/wikis/libraries/3-release-policy).,25f1c3e097f4ed9670b66113ecf7325ff1373c03,True,False,,,,,0,1648401395,,0,{},i2c243o,True,t3_tpo6u8,False,False,t3_tpo6u8,/r/haskell/comments/tpo6u8/breakage_and_deprecation_cycle_policies/i2c243o/,1648401406,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
103.0,[],False,,Dykam,,,[],,,,text,t2_3sfo0,False,True,"True, but it's good to mention it before OP tries to switch their experience to production, and uses Redis for some critical data.",eaf310f5f060daccc0ab0b8424de88bf54fce292,True,False,,,,,0,1648400751,,0,{},i2c0lay,False,t3_toj7lo,False,True,t1_i27wlkm,/r/haskell/comments/toj7lo/which_nosql/i2c0lay/,1648400765,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
104.0,[],False,,CnCDarkVoid,,,[],,,,text,t2_7e9zsner,False,False,Doesn't `Natural` raise a runtime exception for negative values? Why is it preferred over `Maybe`?,ea71f44e9840b51096bb44311eeb04a99cd9a25d,True,False,,,,,0,1648396266,,0,{},i2bpysp,False,t3_tpby52,False,True,t1_i2a6tcv,/r/haskell/comments/tpby52/recursive_factorial_function_error/i2bpysp/,1648396276,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
105.0,[],False,,WarDaft,,,[],,,,text,t2_cspxi,False,False,"If it's for learning purposes, it's possible to write your own database in Haskell in *an afternoon*.",e2182aca9f86600e1967bff3f4d2d5bd9eabf932,True,False,,,,,0,1648396027,,0,{},i2bpex0,False,t3_toj7lo,False,True,t3_toj7lo,/r/haskell/comments/toj7lo/which_nosql/i2bpex0/,1648396045,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
106.0,[],False,,WarDaft,,,[],,,,text,t2_cspxi,False,False,"If you want to go that route...

    import Data.Variadic
    (.:) = composeN

Though *ideally* this would be done by hiding the default `.` and using `TypeApplication` so you could instead pass a natural like so: `listProduct = sum . @2 zipWith (*)` except that you can't actually do this with operators.",23cf6cdef0b2a25b7aa113b98c3b0fb070aad658,True,False,,,,,0,1648395359,,0,{},i2bnv2p,False,t3_tpa9t2,False,True,t1_i2a01gz,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i2bnv2p/,1648395375,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
107.0,[],False,,ysangkok,,,[],,,,text,t2_4qktt,False,False,"Doesn't it overlap with dependent typing (DT) though? If Haskell adopts either, I had the impression that it would be DT.",8ab91f42f8ed62332bb6f86e5e928cfa6df07a45,True,False,,,,,0,1648394116,,0,{},i2bkzx3,False,t3_tnrsg7,False,True,t1_i26u4lx,/r/haskell/comments/tnrsg7/the_haskell_interlude_11_simon_peyton_jones/i2bkzx3/,1648394126,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
108.0,[],False,,ysangkok,,,[],,,,text,t2_4qktt,False,False,I don't like Mongo because I never grokked it's query language. What's with the magic dollar prefixed keys? I was trying to write aggregates and it was a nightmare.,09ca9a8662d8e7fbad81d85bf5a59613bdcef6c3,True,False,,,,,0,1648392113,,0,{},i2bgi01,False,t3_toj7lo,False,True,t1_i27fkg4,/r/haskell/comments/toj7lo/which_nosql/i2bgi01/,1648392124,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
109.0,[],False,,Leading_Dog_1733,,,[],,,,text,t2_hs4uamcx,False,False,"You are right and I think its a good question. I would love to read a study of how different programming languages become popular.

I think Python benefited very much from the whole Perl 5 to Perl 6 transition. If Larry Wall had just released another incremental version of Perl, I suspect Python would never have gained the market share that let it take off.

I would also agree with you on the standard library point; it's not enough alone. 

I haven't programmed in Ruby but Racket Scheme has a standard library that is as good as the Python standard library from a features perspective (not a performance perspective though) and Racket Scheme has never become popular.",72be57db6971a23a8be286c7b7d7edaa2c7ddc26,True,False,,,,,0,1648391086,,0,{},i2beasx,False,t3_py8u24,False,True,t1_i2asjo3,/r/haskell/comments/py8u24/why_did_haskell_not_succeed/i2beasx/,1648391104,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
110.0,[],False,,ChrisWohlert,,,[],,,,text,t2_v8h3i,False,False,"In the context of mapping the resultat of sql, mapping select statement to Constructor args, bevilges boilerplate imo.",c47bbe150978975a750c305472419b6720025848,True,False,,,,,0,1648389328,,0,{},i2bancf,True,t3_tnjnrz,False,True,t1_i223d93,/r/haskell/comments/tnjnrz/does_a_reverse_of_tuple_sections_exist/i2bancf/,1648389344,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
111.0,[],False,,phadej,,,[],,,,text,t2_4qmwn,False,False,Isn't arity /=kind assumption no longer true if unsaturates type families are implemented. What is the status of that proposal?,68ffecaf29ddf3c2f70cf6d6c78b2318a9140be0,True,False,,,,,0,1648389148,,0,{},i2baa66,False,t3_tjm0ga,False,False,t3_tjm0ga,/r/haskell/comments/tjm0ga/ghc_proposal_breakage_should_we_proceed/i2baa66/,1648389162,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
112.0,[],False,,phadej,,,[],,,,text,t2_4qmwn,False,False,Impossible to express even using StandaloneKindSignatures?,ccd10f7e143fef2f5b2464bb3bab9b5646b138d0,True,False,,,,,0,1648388593,,0,{},i2b9589,False,t3_tjm0ga,False,True,t3_tjm0ga,/r/haskell/comments/tjm0ga/ghc_proposal_breakage_should_we_proceed/i2b9589/,1648388609,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
113.0,[],False,,Competitive_Ad2539,,,[],,,,text,t2_8g6liftg,False,False,"Well, that's just your emotions. Emotions are informationless .   


I've already stated, that this app can lead newcomers astray. When you learn ADT, it's important to know the difference between products - tuples and alike, coproducts - Either, Maybe, e.t.c., and exponentials - functions. Also (co/contra)variant stuff. This ""app"" doesn't even know the difference between \* kind and (\* -&gt; \*) kind, which is the worst type of mistake you can make in understanding the type signature. If you eat that, you are going to suck at Type Tetris for the rest of your life.",0daf1fa4c0a0d467badfc1a280c1edd3f452d8ba,True,False,,,,,0,1648388248,,0,{},i2b8gob,False,t3_tl228c,False,True,t1_i2arg07,/r/haskell/comments/tl228c/haskell_type_visualizer/i2b8gob/,1648388267,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
114.0,[],False,,moi2388,,,[],,,,text,t2_4uz9hvt8,False,False,I didn’t know about this. Thanks!,6b736ec3b4b4c3e7a6ce626158fc449d8ee3dabf,True,False,,,,,0,1648380360,,0,{},i2avxo8,False,t3_tpa9t2,False,True,t1_i2ae6hy,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i2avxo8/,1648380374,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
115.0,[],False,,ramin-honary-xc,,,[],,,,text,t2_8mof715w,False,False,"&gt; it is easy to use and has an incredible standard library and set of librarie

This is very true, Python is very easy to use, and does have an excellent set of standard libraries. But it kind of begs the question, why weren't there other languages that were also easy to use and had a good standard library that were being developed at the same time Python was? Why did Python win the ""easy to use and thus a good teaching language"" competation and eventually become everyone's favorite?

It certainly wasn't the only one. In fact, Ruby was mentioned in this talk which is also easy to use and has an incredible set of standard libraries, and was developed around the same time as Python (4 years after), and it initially took the world by storm, but it has lost a lot of mind share over the years.

Lua is another such language in the ""easy to learn and use"" space, developed only 2 years after Python, and arguably much easier to interface to C libraries than Python is, but it never took off the way Python did.",356991bd0c85643219240fe325a9caa3bb88c657,True,False,,,,,0,1648377616,,0,{},i2asjo3,False,t3_py8u24,False,True,t1_i27n2lm,/r/haskell/comments/py8u24/why_did_haskell_not_succeed/i2asjo3/,1648377631,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
116.0,[],False,,ocramz_,,,[],,,,text,t2_jaolcjrr,False,False,"what other kind of mean-spirited a\*\*hole shows up to ""condemn"" somebody else's work. Seriously gtfo",e051a0f15af15b0d8b907d947cc957b4ef179a68,True,False,,,,,0,1648376704,,0,{},i2arg07,False,t3_tl228c,False,True,t1_i2an48g,/r/haskell/comments/tl228c/haskell_type_visualizer/i2arg07/,1648376716,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
117.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,That's why I say that you can only use that trick once. After that you're pretty much out of luck and you either have to learn about [package environment files](https://cabal.readthedocs.io/en/3.6/cabal-commands.html#adding-libraries-to-ghc-package-environments) or you just have to delete your whole `~/.ghc` directory.,fbbade370704175f6440da33d20b40616317e6e7,True,False,,,,,0,1648374287,,0,{},i2aojk8,False,t3_tnxhwf,False,True,t1_i28uq0r,/r/haskell/comments/tnxhwf/i_need_some_beginner_help_with_actually_compiling/i2aojk8/,1648374297,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
118.0,[],False,,Competitive_Ad2539,,,[],,,,text,t2_8g6liftg,False,False,I am not a troll,05052a52c661cc1069c3370b22f6761f0cce5814,True,False,,,,,0,1648373049,,0,{},i2an48g,False,t3_tl228c,False,True,t1_i2ampzv,/r/haskell/comments/tl228c/haskell_type_visualizer/i2an48g/,1648373063,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
119.0,[],False,,ocramz_,,,[],,,,text,t2_jaolcjrr,False,False,get lost troll,664aafa7e303dbbac409510fce1d5d5b2785a0c8,True,False,,,,,0,1648372699,,0,{},i2ampzv,False,t3_tl228c,False,True,t1_i1wnc40,/r/haskell/comments/tl228c/haskell_type_visualizer/i2ampzv/,1648372710,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
120.0,[],False,,yairchu,,,[],,,,text,t2_33msg,False,False,"Using nightly, stack first shows the warning:

    Stack has not been tested with GHC versions above 9.0, and using 9.2.2, this may fail",5ada2461525cec76f369433cc2a9ba1c6c9c9a00,True,False,,,,,0,1648370510,,0,{},i2ak6r1,False,t3_tj0496,False,True,t3_tj0496,/r/haskell/comments/tj0496/stack_lts_19_release_and_nightly_on_ghc92/i2ak6r1/,1648370526,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
121.0,[],False,,Purlox,,,[],,,,text,t2_6l988,False,False,or just a single line `listProduct _ _ = 0` if it's under the already existing lines.,be84cbf1acc1289d6b9fed26fd42169ebba9607d,True,False,,,,,0,1648369645,,0,{},i2aj7r9,False,t3_tpa9t2,False,True,t1_i2addqo,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i2aj7r9/,1648369660,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
122.0,[],False,,Fun_Buffalo1043,,,[],,,,text,t2_2gnonbey,False,False,This works. Thanks!,c72d1ac20eba7f3f70d37fb0b2ed58faec9db9a9,True,False,,,,,0,1648369081,,0,{},i2aiknq,False,t3_rjm0x8,False,True,t1_hpibbu3,/r/haskell/comments/rjm0x8/help_wanted_for_llvm_config_for_haskell_on_mac/i2aiknq/,1648369097,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
123.0,[],False,,Big_Relationship_239,,,[],,,,text,t2_g3zohhjw,False,False,"Why don't you ask GHC the same question by using [\-Wall](https://downloads.haskell.org/~ghc/9.2.2/docs/html/users_guide/using-warnings.html#ghc-flag--Wall) flag?

    Pattern match(es) are non-exhaustive
    In an equation for ‘listProduct’:
        Patterns not matched:
            [_] []
            (_:_:_) []
            [] []
            [] (_:_)",90857fc7bbc1fac88e1cc35b0dc92feaa4e48c30,True,False,,,,,0,1648365288,,0,{},i2ae6hy,False,t3_tpa9t2,False,False,t3_tpa9t2,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i2ae6hy/,1648365305,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
124.0,[],False,,GoTriggerYourself,,,[],,,,text,t2_o9lcl,False,False,"This is also non exhaustive, though. To really make it exhaustive, add two lines:

```
listProduct [] _ = 0
listProduct _ [] = 0
```",a004e8509255f74d2408ea86e7366b635ecfdfbc,True,False,,,,,0,1648364623,,0,{},i2addqo,False,t3_tpa9t2,False,True,t1_i29s6bz,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i2addqo/,1648364640,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
125.0,[],False,,cdsmith,,,[],,,,text,t2_1trov,False,False,"Other responses basically answer your question.  I just wanted to point out that if possible, instead of returning Maybe, a nicer strategy is to choose an input type that can only represent valid inputs.  One such choice is [Natural](https://hackage.haskell.org/package/base-4.16.1.0/docs/Numeric-Natural.html#t:Natural).  Then instead of `safeFact :: Int -&gt; Maybe Int`, you could have `safeFact :: Natural -&gt; Natural`",c2024610e2a3f588ae6e32c2cb180272e829c385,True,False,,,,,0,1648359445,,0,{},i2a6tcv,False,t3_tpby52,False,True,t3_tpby52,/r/haskell/comments/tpby52/recursive_factorial_function_error/i2a6tcv/,1648359462,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
126.0,[],False,,NateReinarWindwood,,,[],,,,text,t2_2vrrzjjg,False,False,"Or, ideally:

    import Data.Composition ((.:))

    listProduct :: Num a =&gt; [a] -&gt; [a] -&gt; a
    listProduct = sum .: zipWith (*)",f0769016e0dae33d79c4a8200fbe9948dcb18d86,True,False,,,,,0,1648354897,,0,{},i2a01gz,False,t3_tpa9t2,False,True,t1_i29wccj,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i2a01gz/,1648354908,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
127.0,[],False,,BrunoBasher,,,[],,,,text,t2_k39yslmw,False,False,Thanks for your response. I'll try that.,2b661b5b1bbd51129e617927d9e075165f9ba1af,True,False,,,,,0,1648354711,,0,{},i29zqor,True,t3_tpby52,False,True,t1_i29yrbj,/r/haskell/comments/tpby52/recursive_factorial_function_error/i29zqor/,1648354722,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
128.0,[],False,,BrunoBasher,,,[],,,,text,t2_k39yslmw,False,False,Thanks for your response. I will use cases!,3926c2b138f0b3bbadfad7ccbc4fe33cc6193091,True,False,,,,,0,1648354701,,0,{},i29zq2n,True,t3_tpby52,False,True,t1_i29yqbt,/r/haskell/comments/tpby52/recursive_factorial_function_error/i29zq2n/,1648354715,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
129.0,[],False,,flebron,,,[],,,,text,t2_4qbym,False,False,"Well, safeFact returns a `Maybe Int`. And yet in the last case, you say `n * safeFact (n - 1)`. How can you multiply `n`, which is an `Int`, with `safeFact (n - 1)`, which is a `Maybe Int`?

You can split `safeFact (n - 1)` into cases, or use a combinator, for example `fmap (* n) (safeFact (n - 1))`, if you're comfortable with that.",b248ca8cafd32984e551fa5de2398c3c320e15fc,True,False,,,,,0,1648354104,,0,{},i29yrbj,False,t3_tpby52,False,True,t3_tpby52,/r/haskell/comments/tpby52/recursive_factorial_function_error/i29yrbj/,1648354115,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
130.0,[],False,,gabedamien,,,[],,,,text,t2_8guj3,False,False,`n * safeFact (n - 1)` can't work because `n :: Int` but `safeFact (n - 1) :: Maybe Int`. You can't multiply an `Int` by a `Maybe Int`. Either use a `case` with pattern match on `safeFact (n - 1)` or take advantage of the `Functor` instance for `Maybe` by mapping `(n*)` over it.,4d56d68f91589c7f601963f42c101b3a55d25816,True,False,,,,,0,1648354087,,0,{},i29yqbt,False,t3_tpby52,False,True,t3_tpby52,/r/haskell/comments/tpby52/recursive_factorial_function_error/i29yqbt/,1648354101,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
131.0,[],False,,BrunoBasher,,,[],,,,text,t2_k39yslmw,False,False,Thx ill see if it works,cc2279282aa8b4daddbe49b21e81e0e125f2e3e4,True,False,,,,,0,1648353310,,0,{},i29xg4f,True,t3_tpa9t2,False,True,t1_i29wccj,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i29xg4f/,1648353322,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
132.0,[],False,,SolaTotaScriptura,,,[],,,,text,t2_5dpnr08,False,False,"Perhaps you want this?

    listProduct :: [Int] -&gt; [Int] -&gt; Int
    listProduct xs ys = sum $ zipWith (*) xs ys",aeacbed6c645669362500aca113082abdce335cd,True,False,,,,,0,1648352662,,0,{},i29wccj,False,t3_tpa9t2,False,True,t3_tpa9t2,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i29wccj/,1648352675,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
133.0,[],False,,AshleyYakeley,,,[],,,,text,t2_92cbu,False,False,"Besides the unmatched patterns, I would recommend using pattern-matching rather than `== []`. It's more Haskelly.",25c5bce3cc80ae0ce40eedb64a5c0f55433dbcd4,True,False,,,,,0,1648352329,,0,{},i29vrs1,False,t3_tpa9t2,False,True,t3_tpa9t2,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i29vrs1/,1648352342,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
134.0,[],False,,BrunoBasher,,,[],,,,text,t2_k39yslmw,False,False,Thank you so much! It makes so much more sense now. Cheers mate.,b59a42b38d8d0036785854704eda81beccfeb69d,True,False,,,,,0,1648351739,,0,{},i29uq6l,True,t3_tpa9t2,False,True,t1_i29s9oo,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i29uq6l/,1648351753,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
135.0,[],False,,BrunoBasher,,,[],,,,text,t2_k39yslmw,False,False,"    listProduct :: [Int] -&gt; [Int] -&gt; Int
listProduct [] [_] = 0
listProduct [_] [] = 0
listProduct (x:xs) (y:ys)
    | xs == [] = x * y
    | ys == [] = y * y 
    | otherwise = x * y + listProduct xs ys

I tried your suggestion and then did this but it still doesn't work.",7428f347734d8b75218f7fd9a96cb8e2049b65a3,True,False,,,,,0,1648351490,,0,{},i29uaxg,True,t3_tpa9t2,False,True,t3_tpa9t2,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i29uaxg/,1648351504,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
136.0,[],False,,[deleted],,,,,,dark,,,,,[deleted],228f7d207920fb84335fac5b2b06ed7b472ece9e,True,False,,,,,0,1648351346,,0,{},i29u1po,False,t3_tpa9t2,False,True,t1_i29s6bz,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i29u1po/,1648351364,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
137.0,[],False,,lctr,,,[],,,,text,t2_bz7l3,False,False,"when it comes to matching over list patterns, you have to take into account the empty list patterns on top of list constructor patterns. basically you’ll need to include `[]` as separate arguments. in this case, since you have two arguments and any could be empty, you’ll have to cover at least four cases (this can be generalized to the case where *any* of the list arguments is empty). An incomplete example would be adding 
``` listProduct [] [] = 0```",839711df9b70ab523e63b545c794eec90a9135f2,True,False,,,,,0,1648350351,,0,{},i29s9oo,False,t3_tpa9t2,False,True,t3_tpa9t2,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i29s9oo/,1648350370,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
138.0,[],False,,cholly97,,,[],,,,text,t2_dq1ex,False,False,"add a second line like

`listProduct [] [] = 0`",f6da2a1102bd1eba57b96b89fe3bb22e8da769cd,True,False,,,,,0,1648350302,,0,{},i29s6bz,False,t3_tpa9t2,False,True,t1_i29qd4l,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i29s6bz/,1648350327,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
139.0,[],False,,bedobi,,,[],,,,text,t2_k155g,False,False,"this particular email column is from an ancient 90s microsoft sql server db with ""latin1 accent sensitive"" collation + all kinds of other added validation on the way to the db, none of it makes much sense to anyone :) 

but you've just made me realize we can probably relax a lot of these requirements now, I've just added a ticket for it in our system :P",1f47abeb5ed9651b95c9bacfbf2b6209ebce98fd,True,False,,,,,0,1648349655,,0,{},i29qzrr,True,t3_tjxh34,False,True,t1_i266l09,/r/haskell/comments/tjxh34/property_testing_am_i_missing_something/i29qzrr/,1648349666,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
140.0,[],False,,BrunoBasher,,,[],,,,text,t2_k39yslmw,False,False,How can I make it so the input can be empty?,74c1f0b52ddb1dc70b907ec7a7fb876db23f4d12,True,False,,,,,0,1648349320,,0,{},i29qd4l,True,t3_tpa9t2,False,True,t1_i29ml2x,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i29qd4l/,1648349336,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
141.0,[],False,,BrunoBasher,,,[],,,,text,t2_k39yslmw,False,False,should be 0,e2e3e7a2567fe642ea33ed94853f25498eedf3b0,True,False,,,,,0,1648349128,,0,{},i29q01v,True,t3_tpa9t2,False,True,t1_i29mokg,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i29q01v/,1648349139,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
142.0,[],False,,ss7m,,,[],,,,text,t2_b0icyhpo,False,False,What is the result of `listProduct [] []`?,6251e5cccc0ef2fa55f040e6689bcb0ba2f7e055,True,False,,,,,0,1648347394,,0,{},i29mokg,False,t3_tpa9t2,False,True,t3_tpa9t2,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i29mokg/,1648347405,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
143.0,[],False,,faiface,,,[],,,,text,t2_jw23d,False,False,Empty lists as either argument to `listProduct`. `x:xs` matches only when the list is not empty.,8696e013d35528c56888fb5c582a7eec252573e9,True,False,,,,,0,1648347341,,0,{},i29ml2x,False,t3_tpa9t2,False,True,t3_tpa9t2,/r/haskell/comments/tpa9t2/what_patterns_have_i_not_met_in_this_code/i29ml2x/,1648347355,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
144.0,[],False,,logan-diamond,,,[],,,,text,t2_12mgsf,False,False,"""I think many Haskell programmers are quite extraordinary and write code that I can’t make head or tail off."" ~SPJ",3875e0f250f5cc66aa300439867447771e634f24,True,False,,,,,0,1648347330,,0,{},i29mkbn,False,t3_tnrsg7,False,True,t3_tnrsg7,/r/haskell/comments/tnrsg7/the_haskell_interlude_11_simon_peyton_jones/i29mkbn/,1648347341,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
145.0,[],False,,tom-md,,,[],,,,text,t2_7b2si,False,False,There aren't any good mongo Haskell libraries.,0ad356c14714a272677c107067de1081941a769d,True,False,,,,,0,1648336799,,0,{},i291c5p,False,t3_toj7lo,False,True,t1_i27fkg4,/r/haskell/comments/toj7lo/which_nosql/i291c5p/,1648336819,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
146.0,[],False,,fridofrido,,,[],,,,text,t2_bsx3a,False,False,"Unfortunately this only _seems to work at first_, but it does not actually work like old-style Cabal worked (which is what every casual user wants). This advice will only deepen the confusion. The right solution would be `cabal-env`, except that it isn't documented. Or manually create the whatever files GHC needs.",f3d4a4a00a0d5cc76efff25c2baa65d6d8eff8c1,True,False,,,,,0,1648333691,,0,{},i28uq0r,False,t3_tnxhwf,False,True,t1_i241vg2,/r/haskell/comments/tnxhwf/i_need_some_beginner_help_with_actually_compiling/i28uq0r/,1648333704,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
147.0,[],False,,MorrowM_,,,[],,,,text,t2_6l7exkda,False,False,I go through both approaches in a [blog post](https://www.morrowm.com/posts/2021-06-26-assoc.html).,9371c55bac1ea5b10e462095476cd900bb3c989b,True,False,,,,,0,1648332413,,0,{},i28s0nf,False,t3_tnmkpe,False,True,t1_i2708ns,/r/haskell/comments/tnmkpe/defining_the_eq_instance_for_a_class/i28s0nf/,1648332432,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
148.0,[],False,,peargreen,,,[],,,,text,t2_istrr,False,False,"...Or to take the list of the essential libraries by u/mordae_with_box as an example — literally all of those will probably survive for the next 5–10 years. Yet:

* I almost never use `binary`, `network`, `warp`, `criterion`;
* only use very few functions from `bytestring` or `vector`;
* probably used `wai` only once when doing a [tricky hack for a client](https://monadfix.com/#2018-10-15-servant-mocking);
* the last time I needed `attoparsec` was probably three years ago.

So.. eh. I don't know.

If you want to spend some time learning Haskell libraries that will be useful to you later (which is a genuinely fun activity), I really recommend picking a domain you like — backend, frontend, data pipelines, databases, parsing, graphics, ... — and asking Reddit about which libraries / library sets work well for people. Then you don't have to learn `stm` and end up never using it.

And if you want to land a Haskell job, I'd say becoming really proficient with *any* stack would be more important. E.g. [IHP](https://ihp.digitallyinduced.com/) might not be around in five years but you can use it to make web/backend projects even for clients who don't care about Haskell, and if I was hiring a backend engineer I would happily hire someone proficient with IHP even though my actual Haskell stack would be entirely different.",652fddbd8e349c36f8e1892e8a166b7c1123d7fe,True,False,,,,,0,1648332019,,0,{},i28r62a,False,t3_tmpfct,False,True,t1_i28mlqp,/r/haskell/comments/tmpfct/haskell_important_libraries/i28r62a/,1648332030,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
149.0,[],False,,Limp_Step_6774,,,[],,,,text,t2_6wlxzw83,False,False,"Yeah, it's awesome - I don't know why I didn't try it before. Especially with VSCode supporting jupyter notebooks",2d11513d164fed524040f8506492db081a9320bf,True,False,,,,,0,1648330014,,0,{},i28msq8,True,t3_tncf7m,False,True,t1_i24kbxe,/r/haskell/comments/tncf7m/plotting_libraries/i28msq8/,1648330024,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
150.0,[],False,,peargreen,,,[],,,,text,t2_istrr,False,False,"I have a list of libraries I recommend: &lt;https://toolbox.brick.do/&gt;. Some of the usecases are obscure and some of the recommendations are not the most popular ones, but it still might be useful.

Tbh I also think ""libraries that will be around in 5-10 years"" is a very tricky requirement and I'm not sure it's so useful. E.g. `vector` is more likely to survive than `aeson` in the next 5 years but you probably need `aeson` more than you need `vector`.",fbfb45cd45c9b3e29abb864a3dd0d0cc023b000a,True,False,,,,,0,1648329925,,0,{},i28mlqp,False,t3_tmpfct,False,True,t3_tmpfct,/r/haskell/comments/tmpfct/haskell_important_libraries/i28mlqp/,1648329941,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
151.0,[],False,,Faucelme,,,[],,,,text,t2_6ofev,False,False,"Sometimes, when creating records-of-functions for use with the ""ReaderT pattern"".",a4a8bdc58e33113a39254463e18eef9e5286d1aa,True,False,,,,,0,1648325831,,0,{},i28dh9g,False,t3_tm900v,False,True,t1_i1zax87,/r/haskell/comments/tm900v/new_largerecords_release_now_with_100_fewer_quotes/i28dh9g/,1648325842,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
152.0,[],False,,zsome,,,[],,,,text,t2_gvnql7,False,False,"I have experience with mongodb with c#, I would like to give a try for a new nosql db.  
I think redis is the best for me.",1a73bc59acb20043256a3378f965aced96aa970d,True,False,,,,,0,1648322889,,0,{},i286xez,True,t3_toj7lo,False,True,t1_i27fkg4,/r/haskell/comments/toj7lo/which_nosql/i286xez/,1648322905,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
153.0,[],False,,mikerob215,,,[],,,,text,t2_q0xno,False,False,I really wish intellij had a plugin that used hls. The Haskell plugin worked fine for me with stack projects but I end up just using emacs to do haskell stuff now.,c49d7cde2412ade6136d127983d50aa908804fcc,True,False,,,,,0,1648322602,,0,{},i286a77,False,t3_tkpt4c,False,True,t1_i1syxy2,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i286a77/,1648322618,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
154.0,[],False,,Competitive_Ad2539,,,[],,,,text,t2_8g6liftg,False,False,"digit n x =  length $ (filter (== n) . show) =&lt;&lt; [1..x] -- here n  is a digit, not a number",d59983da370350c5d682025272155d265e451a9a,True,False,,,,,0,1648319954,,0,{},i280fkv,False,t3_tou97i,False,True,t3_tou97i,/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i280fkv/,1648319970,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
155.0,[],False,,ittsopu,,,[],,,,text,t2_5c1a9yed,False,False,"ok ,thank you",0eaa28199224e2cdbdf1c24ead3b3b2d8624bd7b,True,False,,,,,0,1648319366,,0,{},i27z39z,True,t3_tou97i,False,True,t1_i27xwaz,/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i27z39z/,1648319380,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
156.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"`$` just saves me from writing parentheses. `f $ x` is like `(f) (x)`, even when `f` and `x` are expressions containing most other operators.

`elem` tests to see if a value is an `elem`ent of a list / if a list contains a value.

`show` converts a value to a `String`.  `1` -&gt; `""1""`; `3.14159` -&gt; `""3.14159""`; `'c'` -&gt; `""'c'""`; `""foo""` -&gt; `""\""foo\""""`.  In  Haskell `String` is the same as `[Char]`, so I/we/you/one can use list functions on them directly.

`.` is function composition. `(f . g) x` = `f (g x)`.

All of these are part of the standard Prelude, so are documented in the report, can be found via hoogle, and have documentation on hackage in the ""base"" package.",b3f3f80df9812cef79c626f474924f203a8c5b4b,True,False,,,,,0,1648318838,,0,{},i27xwaz,False,t3_tou97i,False,True,t1_i27wrqh,/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i27xwaz/,1648318855,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
157.0,[],False,,ittsopu,,,[],,,,text,t2_5c1a9yed,False,False,"I have a question about your code , what does $ do and what does elem d . show do ?",fd32cd935acc5752e6f6f17446931a0ca1858d05,True,False,,,,,0,1648318349,,0,{},i27wrqh,True,t3_tou97i,False,True,t1_i27vckm,/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i27wrqh/,1648318366,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
158.0,[],False,,AmbroseHaskell,,,[],,,,text,t2_ioythzj0,False,False,Yeah but the goal seems to be to learn. And Redis is well worth learning. Great docs too.,1a1afe46644c8a3b740c59b0154154b859e1f110,True,False,,,,,0,1648318275,,0,{},i27wlkm,False,t3_toj7lo,False,True,t1_i2733q2,/r/haskell/comments/toj7lo/which_nosql/i27wlkm/,1648318293,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
159.0,[],False,,Swordlash,,,[],,,,text,t2_2fpxe4mw,False,False,"Isn't `acid-state-repair` a usecase for this? I have had a few incidents in production when acid-state crashed due to out of memory on a server, and it worked. I know that it may not be fit for all purposes, but cutting out the last partially saved event is the only option I can think of.",8aae9cb6929dbf553597750a5b0ac41779aa1d7f,True,False,,,,,0,1648318256,,0,{},i27wk1h,False,t3_toj7lo,False,True,t1_i27najz,/r/haskell/comments/toj7lo/which_nosql/i27wk1h/,1648318271,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
160.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"Write `countIf :: (a -&gt; Bool) -&gt; [a] -&gt; Int`.

Write `containsDigit :: Char -&gt; Int -&gt; Bool`.  I suggest using `show` and `elem` functions; though you could use your `countIf` function instead of `elem`.

Count you want is `countIf (containsDigit digitFromUser) [1.. xFromUser]`",35b731877f78df9119783f0d573071fd31f7f348,True,False,,,,,0,1648318234,,0,{},i27wi71,False,t3_tou97i,False,True,t1_i27h0rn,/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i27wi71/,1648318249,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
161.0,[],False,,nictytan,,,[],,,,text,t2_nevm3,False,False,"I’d say to give CouchDB a try, but I don’t know what the haskell library offerings are like for it.",11aa64380dc4c3e3893e1563e35dec031b8befef,True,False,,,,,0,1648318005,,0,{},i27vz8v,False,t3_toj7lo,False,True,t3_toj7lo,/r/haskell/comments/toj7lo/which_nosql/i27vz8v/,1648318020,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
162.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"So, do you want us to do your homework for you?  Or do you actually have some questions about the homework?  Have you have _any_ attempt to solve even a part of the problem yourself?

    f d x = length $ filter (elem d . show) [1..x]

-

    GHCi&gt; f '2' 34
    13",c59c2824599def7a5df7c8e3d85ec5a09683d4ef,True,False,,,,,0,1648317741,,0,{},i27vckm,False,t3_tou97i,False,True,t1_i27i41h,/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i27vckm/,1648317759,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
163.0,[],False,,layaryerbakar,,,[],,,,text,t2_2ioyxvrr,False,False,"If you already have function that check whether a number has a  certain digit, you could try to look what `filter` does

I don't if you're allowed to use built in function, if not maybe try to make your own `filter` function that filter the list which follow a requirement",0de7b3f0403a3d0ec628a9becd539981c50f4a67,True,False,,,,,0,1648317328,,0,{},i27ucv6,False,t3_tou97i,False,True,t1_i27okoq,/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i27ucv6/,1648317345,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
164.0,[],False,,Irish-Green,,,[],,,,text,t2_jg1yr5z0,False,False,"never again would I use it, I had no hassle before with it. However, when I bought the new laptop last month and started using OneDrive, it just seemed to take priority over everything. 

If I want to go to my actual documents folder, I must go into the C:/ drive and to user  etc.... its a pain in the ass.",d3a3f4d22d2666252ec19437e494f87133ca6823,True,False,,,,,0,1648315859,,0,{},i27qtvr,True,t3_tnipf5,False,True,t1_i21uvgq,/r/haskell/comments/tnipf5/im_trying_to_learn_how_to_use_haskell_and_not/i27qtvr/,1648315872,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
165.0,[],False,,moi2388,,,[],,,,text,t2_4uz9hvt8,False,False,Which is why I suggested the book 🙂,c0b14c92ba9d26c4b50e8b5875ec18ff8944ccd6,True,False,,,,,0,1648315364,,0,{},i27plu8,False,t3_toj7lo,False,True,t1_i26owqg,/r/haskell/comments/toj7lo/which_nosql/i27plu8/,1648315377,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
166.0,[],False,,r0ck0,,,[],,,,text,t2_43cuz,False,False,"&gt; The fact that F#'s type system is very much first-order.

Can anyone explain what this means?",4cea56ebcbcdcafc133e081f9c6befdd97e256df,True,False,,,,,0,1648315339,,0,{},i27pjp2,False,t3_4wmba0,False,True,t1_d68recr,/r/haskell/comments/4wmba0/learning_f_as_a_haskell_enthuastic/i27pjp2/,1648315362,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
167.0,[],False,,dougburke,,,[],,,,text,t2_dlo8g,False,False,The permissive typing - aka everything is essentially JSON with a little-bit of sugar on top - is something I've struggled to improve in `hvega` but have just not had the time/energy to do anything about. If people have ideas please head on over to [https://github.com/DougBurke/hvega](https://github.com/DougBurke/hvega) or to [https://gitter.im/dataHaskell/Lobby](https://gitter.im/dataHaskell/Lobby) (although I'm not on there often).,7fc8b199b44af2f12048009d2a4401bd3a7cff7c,True,False,,,,,0,1648315330,,0,{},i27pitn,False,t3_tncf7m,False,True,t3_tncf7m,/r/haskell/comments/tncf7m/plotting_libraries/i27pitn/,1648315342,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
168.0,[],False,,ittsopu,,,[],,,,text,t2_5c1a9yed,False,False,I can do it for a specific number but I dont know how to work with a list of number and to check every number from the list for the specific digit,be38a5cd8d8984fe1edf24ef6093650452353131,True,False,,,,,0,1648314926,,0,{},i27okoq,True,t3_tou97i,False,True,t1_i27o2ww,/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i27okoq/,1648314946,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
169.0,[],False,,dun-ado,,,[],,,,text,t2_ihltqlra,False,False,Find a solution to count the occurrences of a digit for any number?,5e9735e687353d649500fbe1128337ed09db965d,True,False,,,,,0,1648314713,,0,{},i27o2ww,False,t3_tou97i,False,True,t1_i27nm45,/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i27o2ww/,1648314724,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
170.0,[],False,,ittsopu,,,[],,,,text,t2_5c1a9yed,False,False,"I am not sure I understand the question , do you mean do I have a solution for the number from 1 to 9?",2bc4c3ad678011d29dec3c951f1c918caed2f7bc,True,False,,,,,0,1648314512,,0,{},i27nm45,True,t3_tou97i,False,True,t1_i27mmhu,/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i27nm45/,1648314531,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
171.0,[],False,,enobayram,,,[],,,,text,t2_90u7a,False,False,"acid-state is very cool, it's one of the main things that made me fall in love with Haskell back in the day. However, with this issue still open 6 years after its creation, I don't think it's fit for any real production use: https://github.com/acid-state/acid-state/issues/79",830c206c2fa39347996ddfffd118e6c149a1f61d,True,False,,,,,0,1648314372,,0,{},i27najz,False,t3_toj7lo,False,True,t1_i267qvn,/r/haskell/comments/toj7lo/which_nosql/i27najz/,1648314390,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
172.0,[],False,,Leading_Dog_1733,,,[],,,,text,t2_hs4uamcx,False,False,"I know this is an old post but Python has a lot more than slow and steady; it is easy to use and has an incredible standard library and set of libraries. 

It's standard library is better than JavaScript's for instance, which is its main competitor as a high level scripting language. 

And, there are more production ready libraries for Python than I can almost care to name, for a huge range of functions, libraries that will be around in 5 years so you don't feel bad investing 3 months of your time into learning them.",55c12f83da3cb31bcf2278079c00ca1d80ca3f4a,True,False,,,,,0,1648314277,,0,{},i27n2lm,False,t3_py8u24,False,True,t1_heu7cmx,/r/haskell/comments/py8u24/why_did_haskell_not_succeed/i27n2lm/,1648314295,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
173.0,[],False,,ludvikgalois,,,[],,,,text,t2_dul9o,False,False,"Can you define a function to count the number of even numbers in a list of `Int`? Hint: the `even` function in the `Prelude` can tell you if a number is even or not.

    countEvens :: [Int] -&gt; Int
    &lt;solution goes here&gt;

    -- &gt; countEvens [4, 7, 52]
    -- 3
    -- &gt; countEvens [2, 2, 2, 2]
    -- 4

If you can't solve this, then you'll want to revise whatever notes you have on lists before trying to solve your original problem.",1ad4a4626cf93299d6e86a9615b5255e93d43fac,True,False,,,,,0,1648314210,,0,{},i27mx2z,False,t3_tou97i,False,True,t1_i27ltax,/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i27mx2z/,1648314229,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
174.0,[],False,,dun-ado,,,[],,,,text,t2_ihltqlra,False,False,Do you have a solution for for a single digit?,d022ca4c7b70897d47ab8de5292cb43267769754,True,False,,,,,0,1648314084,,0,{},i27mmhu,False,t3_tou97i,False,True,t1_i27mgyj,/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i27mmhu/,1648314098,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
175.0,[],False,,ittsopu,,,[],,,,text,t2_5c1a9yed,False,False,"We learned about lists a week ago so I am not very good at them ,but my problem is how to I go through every single element and check for the specific digit",387ed7b939097c2c65028e7d88200c81eefb1345,True,False,,,,,0,1648314020,,0,{},i27mgyj,True,t3_tou97i,False,True,t1_i27m4u7,/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i27mgyj/,1648314058,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
176.0,[],False,,dun-ado,,,[],,,,text,t2_ihltqlra,False,False,Where are you stuck?,0ff8f6ce2d0cc6801e90bc1c0a7947318e296041,True,False,,,,,0,1648313874,,0,{},i27m4u7,False,t3_tou97i,False,True,t1_i27ltax,/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i27m4u7/,1648313887,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
177.0,[],False,,ittsopu,,,[],,,,text,t2_5c1a9yed,False,False,It is a homework problem but I am having a really hard time thinking of a way to solve it since when we are in class we solve basic tasks and then they give us questions like this for homework. Can you think of a similar problem I can try to solve because I really can not do this one? Or if you can give me a clue on how to aprouch this one that would be great.,da6438974dceb84aab8c24397203d0b950a81f09,True,False,,,,,0,1648313733,,0,{},i27ltax,True,t3_tou97i,False,True,t1_i27j8h9,/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i27ltax/,1648313747,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
178.0,[],False,,FreeVariable,,,[],,,,text,t2_16uihwda,False,False,I can only second that. Plus it's not difficult to expand to add a cloud database to your redis-based application with little refactoring.,e289fc67fa409eb7a9dd88afbfcb5f284f75457d,True,False,,,,,0,1648313026,,0,{},i27k63k,False,t3_toj7lo,False,False,t1_i266fay,/r/haskell/comments/toj7lo/which_nosql/i27k63k/,1648313039,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
179.0,[],False,,dun-ado,,,[],,,,text,t2_ihltqlra,False,False,"This sounds exactly like a homework question. By solving problems, you’ll build intuition on Haskell and computational problems. Why not sit down and try to solve a simpler yet related problem?",071e5782f495a25350e8ded87452f3121b059082,True,False,,,,,0,1648312624,,0,{},i27j8h9,False,t3_tou97i,False,True,t1_i27i41h,/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i27j8h9/,1648312637,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
180.0,[],False,,ittsopu,,,[],,,,text,t2_5c1a9yed,False,False,"Ok ,let me explain it better. You have a digit ( between 0 and 9) that you enter in the program and you have a list going from 1 to x (you enter x in the program) ,then your program has to count the number of numbers between 1 and x that have the digit in them. 
So for example if you have the digit 2 and x=34 your program should print out 13 ,because 2 is found in (2,12, 20,21,22,23 ,24,25,26,27 ,28,29,32) from the list of numbers going from 1 to 34. 
Does that make thing more understandable?",4aeeb46fba0ed2361c590b75cb24cf0117ea09c3,True,False,,,,,0,1648312143,,0,{},i27i41h,True,t3_tou97i,False,True,t1_i27gbb0,/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i27i41h/,1648312157,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
181.0,[],False,,ittsopu,,,[],,,,text,t2_5c1a9yed,False,False,"First I tried to do a simple ""How many times does a digits from 0 to 9 appear in a bigger number but I have no idea how to do it with a list of numbers. I tried to do it with a pattern list [n, n+10 , n+20 .. x] but that didnt compile and even if it did it would be wrong because it would count the times in which the digit n would be the first digit of the number instead of only the times it would be the last digit. So I am just sitting here wondering how to count every single time the digit appears in a number. Also something I am not sure is specified is that if the digit is 2 and the list is [1 .. 737] the number 222 for example counts as one occurence ,so I should not count the occurences of the digit 2, instead I should count the amound of numbers that have the digit 2 in them.",29c4c89967d52b89efd55c4927a02034ac42bef1,True,False,,,,,0,1648311664,,0,{},i27h0rn,True,t3_tou97i,False,True,t1_i27epxr,/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i27h0rn/,1648311679,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
182.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"    digit :: Char

    x :: Int

    occurences :: Int
    occurences = length . filter (digit ==) $ concatMap show [1..x]

I doubt that helps, but I also share the questions asked by [/u/ludvikgalois](https://www.reddit.com/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i27epxr/).",160f8d33fbc0450583c81164333e07db83b5af10,True,False,,,,,0,1648311357,,0,{},i27gbb0,False,t3_tou97i,False,True,t3_tou97i,/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i27gbb0/,1648311374,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
183.0,[],False,,binaryblade,,,[],,,,text,t2_b4v22,False,False,Noone has said mongo yet.,07ba6af424e4bf3e244b9805220ec2c361ac95fd,True,False,,,,,0,1648311035,,0,{},i27fkg4,False,t3_toj7lo,False,True,t3_toj7lo,/r/haskell/comments/toj7lo/which_nosql/i27fkg4/,1648311054,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
184.0,[],False,,ludvikgalois,,,[],,,,text,t2_dul9o,False,False,"Can you flesh out the question a bit more? For example, what have you tried so far, and what problems have you encountered?",c007c4ee2b79aa13537596ee14e10a5d63438f62,True,False,,,,,0,1648310669,,0,{},i27epxr,False,t3_tou97i,False,True,t3_tou97i,/r/haskell/comments/tou97i/how_do_you_count_the_occurences_of_a_digit_n_in_a/i27epxr/,1648310688,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
185.0,[],False,,xeltius,,,[],,,,text,t2_4mwj7,False,False,That makes sense. Thank you!,8224231897a5545b580fa05cf3d665cd9267bb53,True,False,,,,,0,1648310311,,0,{},i27dwfb,True,t3_tjl2sg,False,True,t1_i259icq,/r/haskell/comments/tjl2sg/what_does_your_workflow_look_like/i27dwfb/,1648310328,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
186.0,[],False,,ludvikgalois,,,[],,,,text,t2_dul9o,False,False,"To me functional dependencies (fundeps) always seemed like a hack, but that's not a very convincing reason.

The truth is, they're not that different. It's slightly less work for the compiler, and you don't have to mention the Id type if you don't need it.

You can make it even more ergonomic if you do something like

    class (Eq (Id a)) =&gt; Entity a where
      type Id a
      getId :: a -&gt; Id a

which allows you to completely avoid mentioning the type of the id in something like

    (===) :: (Entity a) =&gt; a -&gt; a -&gt; Bool
    x === y = getId x == getId y

whilst when you have a functional dependency, you always have to write `Entity a b`, even when you don't care about `b` and already enforced `Eq` on `b` in the `class` definition.

It becomes slightly more awkward when you want to restrict something to having Ids of a given type. With fundeps

    foo :: (Entity a T) =&gt; a -&gt; S

but with type families

    foo :: (Entity a, T ~ Id a) =&gt; a -&gt; S",e96e5e2b366876499a3e77655871fa7073d24237,True,False,,,,,0,1648308492,,0,{},i279st8,False,t3_tnmkpe,False,True,t1_i2708ns,/r/haskell/comments/tnmkpe/defining_the_eq_instance_for_a_class/i279st8/,1648308506,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
187.0,[],False,,LordGothington,,,[],,,,text,t2_1s8lhray,False,False,"acid-state + ixset-typed is nice because it is all Haskell code all the way down. There is no clunkiness of trying to match Haskell types with the restrictive types of foreign library.

And, acid-state is a small enough code base that you can actually read the entire codebase and understand exactly how it works.

If you are willing to use lenses then you can get some pretty elegant looking query and update methods as well.",2e387802f253bf665b04a498139002650699c1ec,True,False,,,,,0,1648308350,,0,{},i279heh,False,t3_toj7lo,False,True,t3_toj7lo,/r/haskell/comments/toj7lo/which_nosql/i279heh/,1648308365,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
188.0,[],False,,Dykam,,,[],,,,text,t2_3sfo0,False,True,Isn't it discouraged to use Redis for persistence?,0e6c2d4b9ca9ab5b80c2693cd4f5b17731038d93,True,False,,,,,0,1648305493,,0,{},i2733q2,False,t3_toj7lo,False,True,t1_i266fay,/r/haskell/comments/toj7lo/which_nosql/i2733q2/,1648305506,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
189.0,[],False,,g_difolco,,,[],,,,text,t2_735ekc4l,False,False,"It really depends on your access patterns, we've used AWS DynamoDB (a Cassandra-like managed by AWS, with a good support in amazonka) for 1 year and a half.

We are migrating to PostGreSQL through squeal, and we may move to riak in few months.",b6b11f9d6f0084a0fd78f3394060e34844f5fc21,True,False,,,,,0,1648304943,,0,{},i271wq0,False,t3_toj7lo,False,False,t3_toj7lo,/r/haskell/comments/toj7lo/which_nosql/i271wq0/,1648304956,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
190.0,[],False,,cjduncana,,,[],,,,text,t2_75wvr,False,False,What would be the difference between this solution and @MorrowM_ solution?,2835dd200d90a4bcfd637013801ba8e3c95d6bae,True,False,,,,,0,1648304159,,0,{},i2708ns,True,t3_tnmkpe,False,True,t1_i26efwg,/r/haskell/comments/tnmkpe/defining_the_eq_instance_for_a_class/i2708ns/,1648304172,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
191.0,[],False,,simonmic,,,[],,,,text,t2_3a0g0,False,False,"Perhaps slightly dated, but good content: https://www.fpcomplete.com/haskell/learn/#libraries",1dec7db76704dceeefa435b19ef9938eaa23d36d,True,False,,,,,0,1648303494,,0,{},i26yv7p,False,t3_tmpfct,False,True,t3_tmpfct,/r/haskell/comments/tmpfct/haskell_important_libraries/i26yv7p/,1648303512,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
192.0,[],False,,johnorford,,,[],,,,text,t2_14ajvp,False,False,Love the mention of liquid Haskell. Seems like the future,55dce5527c18130d7efd36ce73a320f4b4c8b83f,True,False,,,,,0,1648301055,,0,{},i26u4lx,False,t3_tnrsg7,False,True,t3_tnrsg7,/r/haskell/comments/tnrsg7/the_haskell_interlude_11_simon_peyton_jones/i26u4lx/,1648301071,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
193.0,[],False,,UnicornLock,,,[],,,,text,t2_38ccrnim,False,False,"Yes, redis has actual usages beside not being sql. It is often used in combination with an sql db.",dd3bd151f5165ad7f0153959f882c223dd293ac5,True,False,,,,,0,1648299100,,0,{},i26qp9s,False,t3_toj7lo,False,True,t1_i266fay,/r/haskell/comments/toj7lo/which_nosql/i26qp9s/,1648299114,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
194.0,[],False,,r0ck0,,,[],,,,text,t2_43cuz,False,False,"&gt; does it matter?

Does it matter if it matters?

They still have to make a decision regardless of that.",810e7d745ee8a5cd7fc623443c79c55478790467,True,False,,,,,0,1648298021,,0,{},i26owqg,False,t3_toj7lo,False,True,t1_i2655cd,/r/haskell/comments/toj7lo/which_nosql/i26owqg/,1648298033,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
195.0,[],False,,masklinn,,,[],,,,text,t2_d5sb,False,False,"&gt; It looks like the difference stems from (:) being ""productive"".

Yes, or more specifically from `(:)` being lazy in its second argument. `+` is strict in both arguments, so there's no laziness for `foldr` to work with, therefore `foldl'` (but importantly *not `foldl`) is the fold to use.",4c0e9f1971f08ad6ab81c8bed8bfde19b4ffda4f,True,False,,,,,0,1648296393,,0,{},i26me1k,False,t3_tkpt4c,False,True,t1_i26li9q,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i26me1k/,1648296407,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
196.0,[],False,,zaabson,,,[],,,,text,t2_2j0k07a1,False,False,"This is how I imagine it is:  
  - `foldr (+) [1..n]` works in O(n) space as the resulting sum results from an expression 1+(2+..+n)..) and there is nothing we can calculate having 1+(2+x) and waiting for x. Am I right?
  - `foldlr (:) [] [1..n]` (= id) is productive that is at every step we get a new element of a list. Such a foldr inside a chain of functions works in O(1) space, producing new elements of the list on demand. Again is it right? It looks like the difference stems from (:) being ""productive"".

I would enjoy someone commenting on this. Also I think in the first example strictness analysis can't do anything, the compiler would have use associativity of `+` - essentialy transforming foldr to foldl.",65ab6de0c57ec23dfa73ff6b78edeeb9300a0a88,True,False,,,,,0,1648295784,,0,{},i26li9q,False,t3_tkpt4c,False,True,t1_i1wb8tx,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i26li9q/,1648295796,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
197.0,[],False,,magthe0,,,[],,,,text,t2_eofkc,False,False,"I've used the following configuration thing to get the Go tools to work with private repos:

```
[url ""ssh://git@github.com/organisation""]
        insteadof = https://github.com/organisation
```

Our CI works fine with the HTTPS URL, but on my dev box I have SSH set up of course so then I'd rather use that. The above works with the Go tools, and with nix/niv, so I suspect it'll work with `cabal` too.",8bddb2f79aad174235ccd3e43ee0ba3c9e40409d,True,False,,,,,0,1648291777,,0,{},i26ga79,False,t3_tfgxnv,False,True,t1_i0zkh5x,/r/haskell/comments/tfgxnv/use_authenticated_git_with_cabal/i26ga79/,1648291792,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
198.0,[],False,,ludvikgalois,,,[],,,,text,t2_dul9o,False,False,"I'd suggest considering `TypeFamiles` instead of including the type of the id in the typeclass.

    {-# Language TypeFamilies #-}
    {-# Language FlexibleContexts #-}
    import Prelude hiding (id)

    class Entity a where
      type Id a
      getId :: a -&gt; Id a

    data Person = Person
      { id :: Int,
        name :: String
      }

    instance Entity Person where
      type Id Person = Int
      getId = id

    (===) :: (Entity a, Eq (Id a)) =&gt; a -&gt; a -&gt; Bool
    x === y = getId x == getId y",7ac718c58397fa0f165c5a0000494df406e92756,True,False,,,,,0,1648290231,,0,{},i26efwg,False,t3_tnmkpe,False,True,t3_tnmkpe,/r/haskell/comments/tnmkpe/defining_the_eq_instance_for_a_class/i26efwg/,1648290243,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
199.0,[],False,,i-eat-kittens,,,[],,,,text,t2_z290n,False,False,"&gt; If it’s just for learning, does it matter?

I think it does. I'm staying far away from tech I don't consider up to scratch, or with poor licensing terms. Bad experience can be worse than none.

I've seen plenty of people pick up a lousy RDBMS, for instance, and then sticking with it because that's what they knew.",d46f7e4c837ed7378a7060da468b55f5aa3f8bb7,True,False,,,,,0,1648290099,,0,{},i26ea8x,False,t3_toj7lo,False,True,t1_i2655cd,/r/haskell/comments/toj7lo/which_nosql/i26ea8x/,1648290111,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
200.0,[],False,,Swordlash,,,[],,,,text,t2_2fpxe4mw,False,False,"When it comes to nosql, I recommend acid-state with ixset-typed for fast querying. 

You may also try persistent+sqlite, it is SQL under the hood, but you wouldn't have to write much sql by hand or care about db setup.",641dd6fcfbf2550a0dc22ad5b41c9e04e4c11e4d,True,False,,,,,0,1648284356,,0,{},i267qvn,False,t3_toj7lo,False,True,t3_toj7lo,/r/haskell/comments/toj7lo/which_nosql/i267qvn/,1648284367,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
201.0,[],False,,unhammer,,,[],,,,text,t2_99da7,False,False,"Kind of off-topic, but why have extra length and char requirements on emails? (I like https://stackoverflow.com/a/202528/69663 – just send an e-mail to validate it, too many hand-rolled validators fail to e.g. allow `+` and yet don't catch typos)",3cfa8076dc3f4337556c8432a22d0f7989397597,True,False,,,,,0,1648283304,,0,{},i266l09,False,t3_tjxh34,False,True,t3_tjxh34,/r/haskell/comments/tjxh34/property_testing_am_i_missing_something/i266l09/,1648283315,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
202.0,[],False,,AmbroseHaskell,,,[],,,,text,t2_ioythzj0,False,False,"if you don't know redis, use redis + `hedis`. It's a very useful piece of infra. And the Haskell library is pretty nice.",f2a89f23d2be50996a8c659a34ead791a76dfb01,True,False,,,,,0,1648283158,,0,{},i266fay,False,t3_toj7lo,False,True,t3_toj7lo,/r/haskell/comments/toj7lo/which_nosql/i266fay/,1648283168,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
203.0,[],False,,ocramz_,,,[],,,,text,t2_jaolcjrr,False,False,mtl and stm are both essential in larger systems,4d82555ce5d9a36be434998b466506bc4ebd1046,True,False,,,,,0,1648282397,,0,{},i265l99,False,t3_tmpfct,False,True,t1_i1yksqq,/r/haskell/comments/tmpfct/haskell_important_libraries/i265l99/,1648282413,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
204.0,[],False,,moi2388,,,[],,,,text,t2_4uz9hvt8,False,False,"If it’s just for learning, does it matter?

If you want to learn about different dbs I’d recommend the book 7 database in 7 weeks.",0e179c6ecaad97ea1d69c6df92737836d7933542,True,False,,,,,0,1648281998,,0,{},i2655cd,False,t3_toj7lo,False,False,t3_toj7lo,/r/haskell/comments/toj7lo/which_nosql/i2655cd/,1648282010,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
205.0,[],False,,AmbroseHaskell,,,[],,,,text,t2_ioythzj0,False,False,"`cabal repl -b` is a good way to use but not ""install"" them",f8c01c3045f488659b28daa90967730ab63bbfcf,True,False,,,,,0,1648269567,,0,{},i25pbnh,False,t3_tnxhwf,False,True,t1_i241vg2,/r/haskell/comments/tnxhwf/i_need_some_beginner_help_with_actually_compiling/i25pbnh/,1648269579,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
206.0,[],False,,SolaTotaScriptura,,,[],,,,text,t2_5dpnr08,False,False,"It's not very interesting really, it's just out-of-order implementation.

This is what a module might look like ""in-motion"":

    module Main (main) where
    
    main :: IO ()
    main = _
    
    data Expr
      = And Expr Expr
      | Or Expr Expr
      | Not Expr
      | T
      | F
    
    parse :: String -&gt; Expr
    parse = _
    
    eval :: Expr -&gt; Bool
    eval = \case
      And x y -&gt; eval x &amp;&amp; eval y
      Or x y -&gt; eval x || eval y
      Not x -&gt; not $ eval x
      T -&gt; True
      F -&gt; False

I knew I wanted a `main`, but I didn't really care about its implementation.

What I did care about was my `Expr` data structure, so I defined it.

I also wanted some way to parse user input into an `Expr`, so I defined `parse`, but again I didn't really care about how it's defined. I just wanted a function `String -&gt; Expr`.

Then I wanted some way to evaluate an `Expr`, and I knew exactly what I wanted so I gave a full definition.

This is all just to say ""I define things in order of how much I care about them"".

In this example the top of the tunnel is `main` and the bottom is `eval`. `main` is called but isn't defined, whereas `eval` is defined but isn't called. `parse` is kind of in between.",29e3e7905b0cf3a7b8a082cea6aa6c6b0e581ddb,True,False,,,,,0,1648260789,,0,{},i259icq,False,t3_tjl2sg,False,True,t1_i22ssrh,/r/haskell/comments/tjl2sg/what_does_your_workflow_look_like/i259icq/,1648260807,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
207.0,[],False,,vaibhavsagar,,,[],,,,text,t2_44j1,False,False,Glad you are having a good time with IHaskell!,654f3711d9989837964c8b628b0b033d52915af3,True,False,,,,,0,1648248790,,0,{},i24kbxe,False,t3_tncf7m,False,True,t3_tncf7m,/r/haskell/comments/tncf7m/plotting_libraries/i24kbxe/,1648248807,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
208.0,[],False,,theKGS,,,[],,,,text,t2_eubyx,False,False,Thanks. I think I'll end up going the project route.,36da8af2cbebfafc15e58bc5d17602315b2fd048,True,False,,,,,0,1648244888,,0,{},i24bhue,True,t3_tnxhwf,False,True,t1_i245tjs,/r/haskell/comments/tnxhwf/i_need_some_beginner_help_with_actually_compiling/i24bhue/,1648244907,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
209.0,[],False,,fridofrido,,,[],,,,text,t2_bsx3a,False,False,"So old versions of Cabal worked differently from the new versions. The new versions are theoretically a better approach, but in practice a pain in the ass, exactly because of what you experience.

There are essentially three ways (which I know) out of this problem:

- use an old GHC+Cabal combo. I think GHC 8.6.5 + Cabal 2.4.1 are the latest versions which work the old ways.
- get used to the new workflow. This means that you cannot just create a `.hs` file anywhere and run it, but you have set up a real project, in a subdirectory, with `.cabal` files and whatever, and use `cabal repl` instead of `ghci` etc. It's a pain in the ass for casual use, but that's the direction the community decided to go on with.
- there is an experimental tool called `cabal-env` which apparently can kind-of replicate the old workflow, but as it is claimed to be very experimental by its author and has exactly zero amount of documentation, I never figured it how to use it...

There is a tool called `ghcup`, which can be used to install and switch between different versions of GHC and Cabal and these days even HLS. I definitely recommend to use it whatever path you choose.

Most of the time I'm still on GHC 8.6.5 + Cabal 2.4 exactly because of the above issue, but I can just change to a newer version in a few seconds if necessary for any reason, and then switch back the same way later.",04c7fde4d13cac59675f93701813e2bd78445493,True,False,,,,,0,1648242454,,0,{},i245tjs,False,t3_tnxhwf,False,True,t3_tnxhwf,/r/haskell/comments/tnxhwf/i_need_some_beginner_help_with_actually_compiling/i245tjs/,1648242469,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
210.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"If you have a list of packages you want to use then you can install them using `cabal install --lib your list of packages here`. However if you later want to install more packages, then this approach quickly leads to conflicts. And you can't just install all packages up front, because that would take way too much compile time and disk space.

I still think the easiest way is to just set up cabal projects. That is really not hard at all. [Here's the getting started guide](https://cabal.readthedocs.io/en/latest/getting-started.html).",2c57762faae5fa0cedc451f5434cee8baab3a0ac,True,False,,,,,0,1648240821,,0,{},i241vg2,False,t3_tnxhwf,False,True,t3_tnxhwf,/r/haskell/comments/tnxhwf/i_need_some_beginner_help_with_actually_compiling/i241vg2/,1648240834,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
211.0,[],False,,CnCDarkVoid,,,[],,,,text,t2_7e9zsner,False,False,"Do you have a `package.yaml` file? If so, the error should also specify which package the missing module comes from. Adding that package to your `build-depends` list may solve your problem.",3b9b66c53372915098e97696f5d820c992702188,True,False,,,,,0,1648240580,,0,{},i241ab5,False,t3_tnxhwf,False,True,t3_tnxhwf,/r/haskell/comments/tnxhwf/i_need_some_beginner_help_with_actually_compiling/i241ab5/,1648240594,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
212.0,[],False,,cjduncana,,,[],,,,text,t2_75wvr,False,False,"This works, thanks 🙌🏻",8e2dd70feb581264205abe537eae865f607653b6,True,False,,,,,0,1648239959,,0,{},i23zrn7,True,t3_tnmkpe,False,True,t1_i22fseg,/r/haskell/comments/tnmkpe/defining_the_eq_instance_for_a_class/i23zrn7/,1648239972,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
213.0,[],False,,Alarmed-Bluejay-9459,,,[],,,,text,t2_b4i8ydtb,False,False,Ghcup,598789d8ffe7b87eea80262e34ececdd6a417587,True,False,,,,,0,1648239187,,0,{},i23xvc1,False,t3_tnxhwf,False,True,t3_tnxhwf,/r/haskell/comments/tnxhwf/i_need_some_beginner_help_with_actually_compiling/i23xvc1/,1648239200,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,True
214.0,[],False,,theKGS,,,[],,,,text,t2_eubyx,False,False,Linux. Lubuntu specifically.,8fbe39c3c5e229cc3f75d73e10eaf1e322033eda,True,False,,,,,0,1648238934,,0,{},i23x8uw,True,t3_tnxhwf,False,True,t1_i23x4tt,/r/haskell/comments/tnxhwf/i_need_some_beginner_help_with_actually_compiling/i23x8uw/,1648238944,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
215.0,[],False,,increasing-sequence,,,[],,,,text,t2_67zlpkqv,False,False,What operating system do you use?,ad43dd287de7cf2b3c922688edd7bdf0d77ee86d,True,False,,,,,0,1648238886,,0,{},i23x4tt,False,t3_tnxhwf,False,True,t3_tnxhwf,/r/haskell/comments/tnxhwf/i_need_some_beginner_help_with_actually_compiling/i23x4tt/,1648238901,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
216.0,[],False,,jumper149,,,[],,,,text,t2_rglr6,False,False,"I really enjoyed the ""Usually we ask interviewees how they got into Haskell"" :D",34c164454650383fc47e95f0e4c2a64fceeaddb0,True,False,,,,,0,1648235817,,0,{},i23pkvj,False,t3_tnrsg7,False,True,t3_tnrsg7,/r/haskell/comments/tnrsg7/the_haskell_interlude_11_simon_peyton_jones/i23pkvj/,1648235832,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
217.0,[],False,,xeltius,,,[],,,,text,t2_4mwj7,False,False,"I eventually moved to Scotty because of this. The problem with scaffolded code bases is that they hold your hand too much and when you need to deviate or go off path, you (as a newer Haskeller) don’t know enough to perform surgery on the codebase. Yesod is a tool for absolute beginners or  extremely experienced Haskellers. If you’re somewhere in the middle, you need to implement the stuff yourself to learn.",3739bee3cade634f1cdeafde9003069ae3a18293,True,False,,,,,0,1648234110,,0,{},i23ldk7,False,t3_tigsot,False,True,t1_i1gqp3d,/r/haskell/comments/tigsot/confused_about_design_of_yesod_form_api/i23ldk7/,1648234128,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
218.0,[],False,,Opposite-Platypus-99,,,[],,,,text,t2_clsnehel,False,False,"turns out you can, doesn't mean you should.",96a5dbbe42825396e55b39a7e7a6a106c026b486,True,False,,,,,0,1648233262,,0,{},i23j8iq,False,t3_tnjnrz,False,True,t1_i222p1k,/r/haskell/comments/tnjnrz/does_a_reverse_of_tuple_sections_exist/i23j8iq/,1648233277,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
219.0,[],False,,brandonchinn178,,,[],,,,text,t2_ognt1qc,False,False,"What's wrong with making everything IO? At some point, you're going to have to execute the thing thats either IO or not, so you might as well store everything in the lowest common denominator. And since the non-IO thing is a function, it's not introspectable, so you're not losing introspectability when storing as IO",85deb61cc3a4c8c8b3cf063e2951a22222a07bbd,True,False,,,,,0,1648231277,,0,{},i23e90h,False,t3_tnmpe1,False,True,t3_tnmpe1,/r/haskell/comments/tnmpe1/commands_mapped_to_some_functions_in_a_repl/i23e90h/,1648231289,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
220.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,I think you want the `Last` monoid / semigroup.,2c42a94a3062866d170d1d928c0239cdb83a1e21,True,False,,,,,0,1648223655,,0,{},i22ujlh,False,t3_tngqtp,False,True,t3_tngqtp,/r/haskell/comments/tngqtp/parsing_with_parsec_command_line_arguments_of/i22ujlh/,1648223669,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
221.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"    data Imp m a = Pure a | Impure (m a)

    instance Functor m =&gt; Functor (Imp m) where
      fmap f (Pure x) = Pure (f x)
      fmap f (Impure mx) = Impure (fmap f mx)

    instance Monad m =&gt; Monad (Imp m) where
      pure = Pure
      ...

    lift :: m a -&gt; Imp m a
    lift = Impure

    lower :: Monad m =&gt; Imp m a -&gt; m a
    lower (Pure x) = pure x
    lower (Impure mx) = mx

... and use `Map String (String -&gt; Imp IO (Either String (String, Core)))`, maybe?",7e7c8906291340fab631862223d36af344ede3f5,True,False,,,,,0,1648223316,,0,{},i22to1b,False,t3_tnmpe1,False,True,t3_tnmpe1,/r/haskell/comments/tnmpe1/commands_mapped_to_some_functions_in_a_repl/i22to1b/,1648223343,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
222.0,[],False,,xeltius,,,[],,,,text,t2_4mwj7,False,False,Could you go into a bit more detail on this?,d12a2c7dc6be1f58478c67ca7f1280b59f822122,True,False,,,,,0,1648222979,,0,{},i22ssrh,True,t3_tjl2sg,False,True,t1_i1r0b5v,/r/haskell/comments/tjl2sg/what_does_your_workflow_look_like/i22ssrh/,1648222993,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
223.0,[],False,,edsko,,,[],,,,text,t2_3bgfn,False,False,"Good question! I checked, and no, they are currently discarded. I think that's fixable. I've opened a ticked at [https://github.com/well-typed/large-records/issues/80](https://github.com/well-typed/large-records/issues/80) .",cbab4c6fa5a3547da54d15d76df8cb56e7ae3126,True,False,,,,,0,1648222281,,0,{},i22r0sd,False,t3_tm900v,False,True,t1_i21eds1,/r/haskell/comments/tm900v/new_largerecords_release_now_with_100_fewer_quotes/i22r0sd/,1648222298,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
224.0,[],False,,dskippy,,,[],,,,text,t2_2nw9r,False,False,"Thank you so much, Brent! I'm still working on playing around with the library and learning it. It's a big one but I really appreciate that it has good documentation.",851f9ac39581b0d075a3c7aae87e59438a4431d7,True,False,,,,,0,1648220478,,0,{},i22mhl5,True,t3_tlvopj,False,True,t1_i22larw,/r/haskell/comments/tlvopj/looking_for_svg_library_recommendations/i22mhl5/,1648220495,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
225.0,[],False,,byorgey,,,[],,,,text,t2_304zb,False,False,Ask and ye shall receive!  https://hackage.haskell.org/package/diagrams-input-0.1,96c931f016649f977c0368a75cf227673944d0b4,True,False,,,,,0,1648220001,,0,{},i22larw,False,t3_tlvopj,False,True,t1_i1z48u4,/r/haskell/comments/tlvopj/looking_for_svg_library_recommendations/i22larw/,1648220015,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
226.0,[],False,,jberryman,,,[],,,,text,t2_32bha,False,False,"There are a few proposals it seems. I think the first question is whether you want strict-by-default with local opt out (this proposal), or vice versa. I think a local annotation that means ""I intend to use all the fields"" (as in https://github.com/ghc-proposals/ghc-proposals/pull/436) is more useful; ime that's a special case.

A third (complementary) option might be to have this decision made at the site of the data declaration (e.g. `data Foo = Foo {{a::Int, b::Int}}` means we want a warning or error whenever we bind only one of those fields in a pattern... not sure I'd really use this, but interesting to think about",1878f5564b50d77f5897b188c2f1b8425445529e,True,False,,,,,0,1648219726,,0,{},i22klqo,False,t3_tma69s,False,True,t1_i1zt6vt,/r/haskell/comments/tma69s/ghc_proposal_wincompletefieldbinds_and/i22klqo/,1648219745,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
227.0,[],False,,MorrowM_,,,[],,,,text,t2_6l7exkda,False,False,"So here, for example, we have `a -&gt; id` which means that `a` uniquely determines `id`. Meaning that if the compiler can infer what `a` is, then it can immediately know what `id` is. So for example you couldn't write a second `instance Entity Person Bool` since then the corresponding `id` type for a `Person` isn't unique.

What you get out of this is that type inference is much better, and you can write functions like `(===)`. Without the functional dependency the compiler has no way of knowing which instance to use for the comparison since it has no idea which `id` type you want to use. You'd have to add a way for the caller to specify which `id` to use (e.g via a `Proxy` argument, or maybe `TypeApplications`). With the functional dependency the compiler can now say ""oh, I know what `id` is, it's just the unique `id` for the given `a`"".",ac496f5d5924deaa0e654a2fc9008c589630c2e5,True,False,,,,,0,1648219632,,0,{},i22kda7,False,t3_tnmkpe,False,True,t1_i22g2ps,/r/haskell/comments/tnmkpe/defining_the_eq_instance_for_a_class/i22kda7/,1648219648,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
228.0,[],False,,Kaligule,,,[],,,,text,t2_8s7hc,False,False,"Another way to go about this would be to write 2 helper functions:

```haskell
-- None if the element was not in there in the first place
removeElementFromListOnce :: (Eq a) =&gt; [a] -&gt; a -&gt; Maybe([a])

-- None if any element of the second list was not in the first one.
removeMultipleElementsFromListOnce :: (Eq a) =&gt; [a] -&gt; [a] -&gt; Maybe([a])
```

This might help you with the `numPizza`",53b3003ba2c566710b37a5821eb9f1f8d2ddeceb,True,False,,,,,0,1648219625,,0,{},i22kcpq,False,t3_tnbd4r,False,True,t3_tnbd4r,/r/haskell/comments/tnbd4r/haskell_beginner_issue_with_learning_recursion/i22kcpq/,1648219641,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
229.0,[],False,,Iceland_jack,,,[],,,,text,t2_3qjdu,False,False,"The GHC type-checking plugin has a [SystemF showcase](https://github.com/sheaf/ghc-tcplugin-api/tree/main/examples/SystemF), you might be interested",8b9db1438633b3b2901cb549bacdaf666a1d38ff,True,False,,,,,0,1648218138,,0,{},i22gq0k,False,t3_tng0a9,False,True,t3_tng0a9,/r/haskell/comments/tng0a9/embedding_system_f_omega_with_gadts/i22gq0k/,1648218155,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
230.0,[],False,,cjduncana,,,[],,,,text,t2_75wvr,False,False,"First time knowing of functional dependencies. What is it, and how should I interpret that concept in code?",1d76512b8df465ce4eb18d3df694f620b4785129,True,False,,,,,0,1648217869,,0,{},i22g2ps,True,t3_tnmkpe,False,True,t1_i22fseg,/r/haskell/comments/tnmkpe/defining_the_eq_instance_for_a_class/i22g2ps/,1648217887,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
231.0,[],False,,MorrowM_,,,[],,,,text,t2_6l7exkda,False,False,"One thing I will note is you probably want a functional dependency on your class, like

    class Entity a id | a -&gt; id where
      getId :: a -&gt; id

which means that every entity has a unique id type.

As far as your main question, you can just write a polymorphic function:

    (===) :: (Entity a id, Eq id) =&gt; a -&gt; a -&gt; Bool
    a === b = getId a == getId b

(this requires using a functional dependency since otherwise there's no way to know which id type to use in general)",ccf49e88fba5185e575150e369110a9686fcfcfe,True,False,,,,,0,1648217747,,0,{},i22fseg,False,t3_tnmkpe,False,True,t3_tnmkpe,/r/haskell/comments/tnmkpe/defining_the_eq_instance_for_a_class/i22fseg/,1648217761,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
232.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"I think you can do things with OverlappingInstances or DerivingVia, but neither is worth it in this case. Just writing those instances is not a lot of work.",c6593e72217eed541edab1b85eb69f07ecfe046c,True,False,,,,,0,1648217070,,0,{},i22e729,False,t3_tnmkpe,False,True,t3_tnmkpe,/r/haskell/comments/tnmkpe/defining_the_eq_instance_for_a_class/i22e729/,1648217088,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
233.0,[],False,,ramin-honary-xc,,,[],,,,text,t2_8mof715w,False,False,"Recursion is just looping, sort of like using ""goto"", but in a more organized way. In Haskell, you can make any function loop by calling itself. A function call tells the program, ""when you get here, go to this function,"" but Haskell doesn't care if the function you call is the same as the function that is running right now, the function evaluation will jump to the top of itself and keep going on happily.

A conditional like an `if` or `case` statement can prevent the loop from running forever, for example, the `length` function:

    length :: [a] -&gt; Int
    length aList = case aList of
        []       -&gt; 0
        _ : more -&gt; 1 + length more -- length calls itself, it loops

So `length` calls itself but with different arguments that were passed in, specifically, the tail of the `aList` (which is called `more` here). Whatever value length returns for `more` is added to 1. In this way, length can loop over all items in the list, and it keeps calling itself with the tail of it's input list until there is an empty tail.

Here is another famous function called `map`:

    map :: (a -&gt; b) -&gt; [a] -&gt; [b]
    map f aList = case aList of
        [] -&gt; []
        a : more -&gt; f a : map f more

Here we change a list of `a` to a list of `b` by applying the `a -&gt; b` function to every element. If the list is empty, the result is also empty. If the list has an item, change that item from an `a` to a `b`, then create a list with that `b` in the head, and call itself with the `more` (tail of the list) to change the rest of the items in the list.

You can also build lists using recursion:

    repeat :: a -&gt; [a]
    repeat a = a : repeat a

Here `repeat` calls itself forever and creates an infinite list. It creates a list with `a` in the head, then calls itself to create the tail (which will be another list with `a` in the head). You can do this in Haskell without crashing the computer because Haskell is lazy, it wont add more elements to the list until you actually look into the list. Running `length` on an infinite list will freeze the computer because you will be counting a number to infinity, however you can use a function like `take` on an infinite list just fine:

    take 5 (repeat ""hello"") -- creates a list with 5 ""hello""s in it.
    take 1000000 (repeat ""spam"") -- creates a list with a million ""spam""s in it.

Neither of the above functions will enter into an infinite loop, since `repeat` only creates as many elements as you inspect.

Other functions that might be useful to you are `group` and `map`, and possibly `sort` as well.",95a4429744fb41c0adc825874105b5bf7d351661,True,False,,,,,0,1648217021,,0,{},i22e2y3,False,t3_tnbd4r,False,True,t3_tnbd4r,/r/haskell/comments/tnbd4r/haskell_beginner_issue_with_learning_recursion/i22e2y3/,1648217035,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
234.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"It's not missing, it's just in the comments on the first image.  You could do the dividing at the end, or you could call `comsumeIngredients` multiple times in `cookPizza`.",6d1f048c43848854145d321281da26cc62caa89d,True,False,,,,,0,1648215353,,0,{},i22aayd,False,t3_tnbd4r,False,True,t1_i21j9ln,/r/haskell/comments/tnbd4r/haskell_beginner_issue_with_learning_recursion/i22aayd/,1648215369,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
235.0,[],False,,ddellacosta,,,[],,,,text,t2_ph0a63q,False,False,I think [`mtl`](https://hackage.haskell.org/package/mtl) should be on any list of important Haskell libraries.,d267bccb01bf8ab156c1a46948018dd8edbe99b6,True,False,,,,,0,1648214419,,0,{},i228ah0,False,t3_tmpfct,False,True,t1_i1yksqq,/r/haskell/comments/tmpfct/haskell_important_libraries/i228ah0/,1648214434,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
236.0,[],False,,chiraagnataraj,,,[],,,,text,t2_30fkjui2,False,False,"Yes, see [this list of operators](https://www.reddit.com/r/haskell/comments/jvwmlk/hilariously_useless_operators/) for examples of what you shouldn't do 🤣",d2026d80213b060fc53151d7c39da51a8de48bc1,True,False,,,,,0,1648213339,,0,{},i2262ns,False,t3_tnjnrz,False,True,t1_i223d93,/r/haskell/comments/tnjnrz/does_a_reverse_of_tuple_sections_exist/i2262ns/,1648213356,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
237.0,[],False,,manpacket,,,[],,,,text,t2_9wf33,False,False,Just remember that you need to be able to read it back later. It's not about writing shortest possible code.,398c61d3b3c1bf6a86c76a03179785c655f49b22,True,False,,,,,0,1648211952,,0,{},i223d93,False,t3_tnjnrz,False,True,t3_tnjnrz,/r/haskell/comments/tnjnrz/does_a_reverse_of_tuple_sections_exist/i223d93/,1648211966,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
238.0,[],False,,jippiedoe,,,[],,,,text,t2_7fs14,False,False,https://hackage.haskell.org/package/tuple-0.3.0.2/docs/Data-Tuple-Curry.html#v:curryN,b1690ebef9a0703b410f60b3154387960debbba3,True,False,,,,,0,1648211593,,0,{},i222p1k,False,t3_tnjnrz,False,True,t3_tnjnrz,/r/haskell/comments/tnjnrz/does_a_reverse_of_tuple_sections_exist/i222p1k/,1648211605,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
239.0,[],False,,theeJoker11,,,[],,,,text,t2_2dc9hpiq,False,False,got it thankyou.,28ce26fcc1761363187ccd8dcd573c43b64efccb,True,False,,,,,0,1648210911,,0,{},i221fyl,True,t3_tm53ap,False,True,t1_i21lqpq,/r/haskell/comments/tm53ap/help_in_understanding_the_cause_of_error_while/i221fyl/,1648210923,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
240.0,[],False,,dagit,,,[],,,,text,t2_lj2p,False,False,"I've only thought about this for a few minutes so maybe I'm wrong, but I think you can overcome this limitation by creating type constructors in Haskell that correspond to the type formers for your embedded system f. For example start off with a type constructor for sums, one for products, and one for arrow types.

You could probably even reuse the haskell ones, but it might be clearer to make your own. Then your parser would look for things like a pair constructor and translate to whatever your designated pair type constructor is.

That will give you a sort of structural type equality instead of nominal type equality. If you want nominal types maybe you could combine the above with `KnownSymbol`? Basically associating each type with a user supplied identifier.",6ea94b20bbdedfb1f4fd56a60b6ddc7f43badc11,True,False,,,,,0,1648210406,,0,{},i220jlr,False,t3_tng0a9,False,False,t1_i21pilj,/r/haskell/comments/tng0a9/embedding_system_f_omega_with_gadts/i220jlr/,1648210421,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
241.0,[],False,,MapaRaccoon,,,[],,,,text,t2_7pphr5wd,False,False,"I wouldn't blame you, I've heard from a friend that onedrive is a nightmare lol",52dcc4cfefb251794ffd58e56396001ef407d432,True,False,,,,,0,1648206913,,0,{},i21uvgq,False,t3_tnipf5,False,True,t1_i21t7dz,/r/haskell/comments/tnipf5/im_trying_to_learn_how_to_use_haskell_and_not/i21uvgq/,1648206923,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
242.0,[],False,,Irish-Green,,,[],,,,text,t2_jg1yr5z0,False,False,Works! Thanks so much. I was so focused on what I was doing wrong with the code that I didn't even think look at the external factors that was affecting it!,4e3437b861e46c4d9677135525e774a8edb5d332,True,False,,,,,0,1648206166,,0,{},i21tsbf,True,t3_tnipf5,False,True,t1_i21rx2m,/r/haskell/comments/tnipf5/im_trying_to_learn_how_to_use_haskell_and_not/i21tsbf/,1648206182,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
243.0,[],False,,Irish-Green,,,[],,,,text,t2_jg1yr5z0,False,False,"I am sure I am anyway, wouldn't see why I can run the first function but none of the others? Anything after the function inc will work and I can't figure out why.",1d2fb1bf0fa090a0f7a19267f7575b82369cd3e6,True,False,,,,,0,1648205751,,0,{},i21t7dz,True,t3_tnipf5,False,True,t1_i21rx2m,/r/haskell/comments/tnipf5/im_trying_to_learn_how_to_use_haskell_and_not/i21t7dz/,1648205763,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
244.0,[],False,,boa_deconstructor,,,[],,,,text,t2_gkmmtcx,False,False,Are you sure you're editing the same file you're running? The paths look different to me.,8472afa95170393f59d49dc32e383ebf1aa89084,True,False,,,,,0,1648204812,,0,{},i21rx2m,False,t3_tnipf5,False,True,t3_tnipf5,/r/haskell/comments/tnipf5/im_trying_to_learn_how_to_use_haskell_and_not/i21rx2m/,1648204826,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
245.0,[],False,,juhp,,,[],,,,text,t2_3h495,False,False,Maybe you want to reformat or put your code up somewhere?,36e8a36b1b2263d9819533c8d17363e471974c51,True,False,,,,,0,1648204618,,0,{},i21rnq0,False,t3_tng0a9,False,True,t3_tng0a9,/r/haskell/comments/tng0a9/embedding_system_f_omega_with_gadts/i21rnq0/,1648204635,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
246.0,[],False,,Competitive_Ad2539,,,[],,,,text,t2_8g6liftg,False,False,It should be the way you did it,0a66aa17a2791b5f8fff8969a6b9b2c75f71a8aa,True,False,,,,,0,1648204397,,0,{},i21rd1h,False,t3_tnbd4r,False,True,t1_i21fnyv,/r/haskell/comments/tnbd4r/haskell_beginner_issue_with_learning_recursion/i21rd1h/,1648204412,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
247.0,[],False,,CnCDarkVoid,,,[],,,,text,t2_7e9zsner,False,False,"You don't seem to have your module defined. Your `inc` may be coming from somewhere else.

Try renaming your file to `Closure.hs` and adding this at the very top:

```haskell
module Closure where
```

And have your `Main.hs` import this module:

```haskell
import Closure
```",ee7da5c6e18deebb1cc5d36d7b869dda552d57e5,True,False,,,,,0,1648204282,,0,{},i21r7jl,False,t3_tnipf5,False,True,t3_tnipf5,/r/haskell/comments/tnipf5/im_trying_to_learn_how_to_use_haskell_and_not/i21r7jl/,1648204299,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
248.0,[],False,,rbrucesp,,,[],,,,text,t2_cascywq,False,False,"I've seen this but as far as I understand it is not understand to parse expressions and convert them to the typed ASTs used in this paper, because the type-constructors for types have to be defined previously.",485e91b0a2f0ec5e90adbb51288f691c1577b8af,True,False,,,,,0,1648202958,,0,{},i21pilj,True,t3_tng0a9,False,True,t1_i21o856,/r/haskell/comments/tng0a9/embedding_system_f_omega_with_gadts/i21pilj/,1648202971,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
249.0,[],False,,effectfully,,,[],,,,text,t2_svn83,False,False,Are you looking for [Embedding F](https://homepages.inf.ed.ac.uk/slindley/papers/embedding-f.pdf)?,5f74955197ff291a7073e665a80a2ee0fb911483,True,False,,,,,0,1648201923,,0,{},i21o856,False,t3_tng0a9,False,True,t3_tng0a9,/r/haskell/comments/tng0a9/embedding_system_f_omega_with_gadts/i21o856/,1648201934,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
250.0,[],False,,ChrisWohlert,,,[],,,,text,t2_v8h3i,False,False,"If you are not familiar with type searches on hoogle, you can sometimes find what you are looking for, by searching by type.

https://hoogle.haskell.org/?hoogle=%5Ba%5D%20-%3E%20Int",f0a3643a1215a6c0a5e424f8fbf730651f9ef51a,True,False,,,,,0,1648201663,,0,{},i21nwo0,False,t3_tnbd4r,False,True,t3_tnbd4r,/r/haskell/comments/tnbd4r/haskell_beginner_issue_with_learning_recursion/i21nwo0/,1648201676,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
251.0,[],False,,ChrisWohlert,,,[],,,,text,t2_v8h3i,False,False,Nothing wrong at all,bb7595f2a9ad09544f08410aaa98fe04bb260ae1,True,False,,,,,0,1648201562,,0,{},i21ns90,False,t3_tnbd4r,False,True,t1_i21fnyv,/r/haskell/comments/tnbd4r/haskell_beginner_issue_with_learning_recursion/i21ns90/,1648201575,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
252.0,[],False,,arjuna93,,,[],,,,text,t2_onnorb2,False,False,"Wow, GCC 2.95 is *antique!*",1919000db91ee91de926c97ef3557ba5e902fdf7,True,False,,,,,0,1648201262,,0,{},i21nfe2,False,t3_a600zp,False,True,t1_ebrwo1o,/r/haskell/comments/a600zp/thoughts_on_bootstrapping_ghc/i21nfe2/,1648201275,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
253.0,[],False,,arjuna93,,,[],,,,text,t2_onnorb2,False,False,"Did you get any further? I want to get GHC on a PPC Mac, and I got stuck on 7.6.3: https://www.reddit.com/r/haskell/comments/svwkv0/haskell\_for\_powerpc\_mac/",5ae179f41896085b53634ee8e7b1fc6d8df776e7,True,False,,,,,0,1648201203,,0,{},i21nctx,False,t3_a600zp,False,True,t1_ebu37ee,/r/haskell/comments/a600zp/thoughts_on_bootstrapping_ghc/i21nctx/,1648201217,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
254.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"If you write

    dropWhile (== ' ') . dropWhile (/= ' ') a

Then it will be parsed as:

    dropWhile (== ' ') . (dropWhile (/= ' ') a)

That `dropWhile (/= ' ') a` is just a list (or string), but the `.` operator expects that both its arguments are functions.

To fix that you can use parentheses like this:

    (dropWhile (== ' ') . dropWhile (/= ' ')) a

Then both arguments of `.` are functions and the actual list `a` is applied to that whole ""pipeline"".

Alternatively you can drop the `.` operator like this:

    dropWhile (== ' ') (dropWhile (/= ' ') a)

Then that left `dropWhile (== ' ')` is applied directly to the list `dropWhile (/= ' ') a`.",fde7f25518b2900c6cd3748f409980064e858632,True,False,,,,,0,1648199828,,0,{},i21lqpq,False,t3_tm53ap,False,True,t1_i20wj1x,/r/haskell/comments/tm53ap/help_in_understanding_the_cause_of_error_while/i21lqpq/,1648199844,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
255.0,[],False,,Fendor_,,,[],,,,text,t2_22in0g32,False,False,"Currently, unfortunately not.

I looked into it a couple of years ago, the issue is that IHaskell doesn't follow normal Haskell rules in regard to parsing statements and expressions.
I believe it is doable to get HLS to understand that (or at least a fork of HLS), but I don't think it is a feature in high demand to support HLS in IHaskell, *yet*.",bce9a3b5873a65a87c0e8ddd009faa251ac405e4,True,False,,,,,0,1648198736,,0,{},i21khby,False,t3_tnch6b,False,True,t3_tnch6b,/r/haskell/comments/tnch6b/ihaskell_integration_with_hls/i21khby/,1648198748,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
256.0,[],False,,ludvikgalois,,,[],,,,text,t2_dul9o,False,False,"There's missing information about ingredient consumption here - medium uses two of each ingredient and large uses three of each ingredient. Of course, that can be easily handled by dividing by 2 or 3 at the end.",b9fe066be5a13eb122e556e30b4565e7e5e80a4f,True,False,,,,,0,1648197691,,0,{},i21j9ln,False,t3_tnbd4r,False,True,t1_i2103f9,/r/haskell/comments/tnbd4r/haskell_beginner_issue_with_learning_recursion/i21j9ln/,1648197703,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
257.0,[],False,,adamgundry,,,[],,,,text,t2_6g0pn,False,False,"In GHC 9.2, `NoFieldSelectors` will still incur the cost of generating accessor functions for record datatypes, because they are needed for the built-in `HasField` class. However it doesn't generate anything for pattern synonyms, which might provide a workaround (i.e. define a non-record type and then a pattern synonym for it).

I'm slowly working on a GHC proposal that could make `NoFieldSelectors` do this more directly. But having that finished and implemented is some way off, alas.",30b65958c8014fc1d4b926eb011ba8a36a5b758c,True,False,,,,,0,1648196643,,0,{},i21i2gq,False,t3_tm900v,False,True,t1_i21dwzj,/r/haskell/comments/tm900v/new_largerecords_release_now_with_100_fewer_quotes/i21i2gq/,1648196656,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
258.0,[],False,,CoAnalyticSet,,,[],,,,text,t2_8hsjqz5m,False,False,"Complete beginner here as well, is there anything wrong with simplying hawaiian to 

&gt; hawaiian :: Size -&gt; Pizza  
&gt; hawaiian sz = Pizza sz [Ham, Pineapple]

?",10e78239083e90b419f85da858308146f0abe445,True,False,,,,,0,1648194561,,0,{},i21fnyv,False,t3_tnbd4r,False,True,t3_tnbd4r,/r/haskell/comments/tnbd4r/haskell_beginner_issue_with_learning_recursion/i21fnyv/,1648194574,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
259.0,[],False,,brnhy,,,[],,,,text,t2_jhxia,False,False,"Are Haddock comments supported on the record/individual fields, or are they discarded?",2f31e4a96eb2ed69d89991aca77e1b9cbdfeac2c,True,False,,,,,0,1648193480,,0,{},i21eds1,False,t3_tm900v,False,True,t3_tm900v,/r/haskell/comments/tm900v/new_largerecords_release_now_with_100_fewer_quotes/i21eds1/,1648193491,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
260.0,[],False,,brnhy,,,[],,,,text,t2_jhxia,False,False,"Regarding /u/adamgundry’s cunning trick:

&gt; ghc won’t generate field accessors for fields with an existential type (avoiding quadratic blow-up)

Does (or could) `NoFieldSelectors` have a similar benefit?",0cb8022df46eede3deb94f55dd221f467c84043a,True,False,,,,,0,1648193094,,0,{},i21dwzj,False,t3_tm900v,False,True,t3_tm900v,/r/haskell/comments/tm900v/new_largerecords_release_now_with_100_fewer_quotes/i21dwzj/,1648193105,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
261.0,[],False,,bewakes,,,[],,,,text,t2_peh4x,False,False,Check out What I wish I knew when learning haskell: http://dev.stephendiehl.com/hask/,730ced7b066a3949138844d6fcf80406ddae214e,True,False,,,,,0,1648189886,,0,{},i219xoe,False,t3_tmpfct,False,True,t3_tmpfct,/r/haskell/comments/tmpfct/haskell_important_libraries/i219xoe/,1648189898,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
262.0,[],False,,Opposite-Platypus-99,,,[],,,,text,t2_clsnehel,False,False,"microlens has the same interface as lens but it's much lighter, so I always use it",c035919276e1a834d0e22d3502360d91d959bebc,True,False,,,,,0,1648188317,,0,{},i217x8k,False,t3_tmpfct,False,True,t1_i202tio,/r/haskell/comments/tmpfct/haskell_important_libraries/i217x8k/,1648188330,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
263.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"There are other ways to do it, but if I were you I'd write a helper function like:

    cookPizza :: Pizza -&gt; [Ingredient] -&gt; Maybe [Ingredient]

that either gives back `Nothing` if there are not enough input ingredients OR gives back `Just leftovers` when there are enough ingredients (leftovers might be empty).

* `cookPizza (hawaiian Small) [Onion]` -&gt; `Nothing`
* `cookPizza (hawaiian Small) [Pineapple, Ham]` -&gt; `Just []`
* `cookPizza (hawaiian Small) [Onion, Ham, Mozzarella, Pineapple, Chilli]` -&gt; `Just [Onion, Mozzarella, Chilli]`
* `cookPizza (hawaiian Small) [Ham, Pineapple, Pineapple, Ham]` -&gt; `Just [Pineapple, Ham]`

Then `numPizza` can look like:

    numPizza p i = case cookPizza p i of
      Nothing -&gt; 0
      Just lo -&gt; succ (numPizza p lo)

---

What is `numPizza (Pizza Small []) [Onion]` is supposed to return?

---

If you can't figure out `cookPizza`, either.  You might try a helper like `consumeIngredients :: [Ingredient] -&gt; [Ingredient] -&gt; Maybe [Ingredient]` or even `consumeIngredient :: Ingredient -&gt; [Ingredient] -&gt; Maybe [Ingredient]`.  You should be able to build `cookPizza` from `consumeIngredients` and `consumeIngredients` from `consumeIngredient`.

`consumeIngredient` should be fairly simple pattern matching on a list for your implementation.  Here's my implementation, but you shouldn't submit this as part of your homework:

    consumeIngredient x = snd . foldr alg ([], Nothing)
     where
      alg y (xs, _) | x == y = (y:xs, Just xs)
      alg y (xs, ys) = (y:xs, fmap (y:) ys)",6f7ceab427deaf857b2feaa7c94136a8a2d36482,True,False,,,,,0,1648182969,,0,{},i2103f9,False,t3_tnbd4r,False,True,t3_tnbd4r,/r/haskell/comments/tnbd4r/haskell_beginner_issue_with_learning_recursion/i2103f9/,1648182984,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
264.0,[],False,,sclv,,,[],,,,text,t2_30zir,False,False,"Any time you're auto-generating structures to match protobufs, database tables, or anything else similar.",7eae8c1c045481b913cef87ddcf5028c2dc0c917,True,False,,,,,0,1648182265,,0,{},i20yviz,False,t3_tm900v,False,True,t1_i1zax87,/r/haskell/comments/tm900v/new_largerecords_release_now_with_100_fewer_quotes/i20yviz/,1648182277,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
265.0,[],False,,theeJoker11,,,[],,,,text,t2_2dc9hpiq,False,False,"sorry, I did not understand the last line can you please explain a little more?",91e84a0d0b5d165efb95d95ecfa881483247eec1,True,False,,,,,0,1648180970,,0,{},i20wj1x,True,t3_tm53ap,False,False,t1_i1xd8ij,/r/haskell/comments/tm53ap/help_in_understanding_the_cause_of_error_while/i20wj1x/,1648180980,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
266.0,[],False,,lbseale,,,[],,,,text,t2_4kixys0o,False,False,I'm writing a sophisticated financial model in Haskell and it's excellent for that! Specifically using the State type to manage the complexity of the calculation.,9af45931989e273dd33524f7518d7f6bdddd6d7c,True,False,,,,,0,1648180872,,0,{},i20wc6n,False,t3_tax9uc,False,True,t3_tax9uc,/r/haskell/comments/tax9uc/what_is_haskell_good_for/i20wc6n/,1648180887,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
267.0,[],False,,joehh2,,,[],,,,text,t2_2uzbgcq,False,False,"I used Chart (https://hackage.haskell.org/package/Chart) a lot in a previous role. It is lacking for interactivity, but great otherwise. I was particularly impressed with the date axis labeling.",c6705e74d7c7dc4d5956c90dfc812548cb513c5c,True,False,,,,,0,1648178801,,0,{},i20sa7y,False,t3_tncf7m,False,True,t3_tncf7m,/r/haskell/comments/tncf7m/plotting_libraries/i20sa7y/,1648178817,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
268.0,[],False,,charukiewicz,,,[],,,,text,t2_r67pz,False,False,"From a [talk I gave](https://www.youtube.com/watch?v=6RCe0bB6LHU) on using Haskell for Production ([slide 48](https://www.foxhound.systems/files/why-consider-haskell-for-production.pdf)):

|Category | Mature Packages Available |
| -------- | ---------- |
| Common Parsers | aeson (JSON), yaml, tagsoup (XML/HTML) |
| Databases | persistent + esqueleto, mysql-simple, postgresql-simple, sqlite-simple |
| Custom Parsers/Regex | attoparsec, megaparsec, regex-pcre |
| HTML Generation | blaze-html, lucid, shakespeare |
| Data Structures | containers, vector, semigroups |
| Terminal/CLI | Development optparse-applicative, shelly, brick |
| Web yesod, scotty, wai-extra, warp, http-api-data |
| Other Common Libraries | text, bytestring, time, network, directory, filepath, unix |",d0a7a1cfcba14398012d4a3c34d6eec5247ed779,True,False,,,,,0,1648177934,,0,{},i20qjgd,False,t3_tmpfct,False,True,t3_tmpfct,/r/haskell/comments/tmpfct/haskell_important_libraries/i20qjgd/,1648177946,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
269.0,[],False,,brandonchinn178,,,[],,,,text,t2_ognt1qc,False,False,"This is mentioned in the corresponding PR, but to echo it here: I wrote a separate proposal to solve the same problem: https://github.com/ghc-proposals/ghc-proposals/pull/436",9e646d56b7b5c13cce4bc2a31ea75de288972f24,True,False,,,,,0,1648176350,,0,{},i20n9ce,False,t3_tma69s,False,True,t3_tma69s,/r/haskell/comments/tma69s/ghc_proposal_wincompletefieldbinds_and/i20n9ce/,1648176363,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
270.0,[],False,,logan-diamond,,,[],,,,text,t2_12mgsf,False,False,"Is there a linear comonad package? If not, why? 

I'm in a circumstance where I'd like a linear functor + comonad instance .",f5e73f5d55c01686bac716199a12f5a34475d4bc,True,False,,,,,0,1648176280,,0,{},i20n3w5,False,t3_t3zw0x,False,True,t3_t3zw0x,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i20n3w5/,1648176291,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
271.0,[],False,,nainax,,,[],,,,text,t2_2yh9trzb,False,False,"Hello there!  
You might want to check some info about [pattern matching](https://en.wikibooks.org/wiki/Haskell/Pattern_matching). You are already checking for the case where the ingredients list is empty, but there are other ways to match the contents of a list.",40f288cb341424e5461b86c705414ee6d5fdb873,True,False,,,,,0,1648175771,,0,{},i20m03r,False,t3_tnbd4r,False,True,t3_tnbd4r,/r/haskell/comments/tnbd4r/haskell_beginner_issue_with_learning_recursion/i20m03r/,1648175787,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
272.0,[],False,,SSchlesinger,,,[],,,,text,t2_jggeg,False,False,Don’t forget stm! Maybe in “solves something really well” but it’s also kind of essential maybe idk,e12e7c21d150a9ee0d6a37f074570893d47cca7d,True,False,,,,,0,1648174546,,0,{},i20jc76,False,t3_tmpfct,False,True,t1_i1yksqq,/r/haskell/comments/tmpfct/haskell_important_libraries/i20jc76/,1648174560,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
273.0,[],False,,fast4shoot,,,[],,,,text,t2_aaf2u,False,False,"Dude, this is completely unrelated to your problem, but this comment of yours is basically unreadable.

Some more punctuation would definitely help.

Some context would help too - why do you want to replace . by $? What's the error you're getting? How is it different from the one in the OP? Have you tried, you know, actually reading it? What don't you understand about it? Have you tried simplifying the problem?

Sorry if this comes off as rude, but I honestly believe that your writing, the way you convey information and the way you analyze information that's available to you needs some improvement.

Out of curiosity, what were you trying to say with this?

&gt; the result will be pasted to the second last and so on

Like, I get it, you're talking about the chain of function applications and how the result of one is going to be used as the argument to another. But I have no idea what ""the second last"" is. Also, why would you choose the verb ""paste"" here?",e477b6bfb06084f6b7cd71425b306988d36cbf48,True,False,,,,,0,1648168783,,0,{},i206j5o,False,t3_tm53ap,False,True,t1_i1x9220,/r/haskell/comments/tm53ap/help_in_understanding_the_cause_of_error_while/i206j5o/,1648168795,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
274.0,[],False,,r3dnaz,,,[],,,,text,t2_2ornf0zo,False,False,"some of the libraries you mention have alternatives so popular that i find it unapproriate not to mention them.

* `tasty` is a popular alternative to `hspec`.
* [`optics`](https://hackage.haskell.org/package/optics) is a popular alternative to `lens`.
* a vulnaribility in `aeson` has brought the design of having an intermediate representation into question and prompted the development of alternatives like [`autodocodec`](https://hackage.haskell.org/package/autodocodec) and [`jordan`](https://hackage.haskell.org/package/jordan).
* [there are haskell foundation board members](https://www.snoyman.com/blog/2021/03/haskell-base-proposal-2/) who work towards disposing of `text` and `bytestring`.",7989c88fa2fa3c6109a2ccf2237fa0ce00c62688,True,False,,,,,0,1648167113,,0,{},i202tio,False,t3_tmpfct,False,True,t1_i1yksqq,/r/haskell/comments/tmpfct/haskell_important_libraries/i202tio/,1648167130,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
275.0,[],False,,sunnyata,,,[],,,,text,t2_4lxh3lrv,False,False,"Usually spend as much time thinking as using the keyboard with Haskell (not always the case with other languages), and as much time experimenting in the repl as editing modules. If I get stuck the best thing I can do is put it down and do something else, can be hard to do but it's worth it.",e59bed5c43b652b25233f37094bf37698c47ba5f,True,False,,,,,0,1648163254,,0,{},i1zu29v,False,t3_tjl2sg,False,True,t3_tjl2sg,/r/haskell/comments/tjl2sg/what_does_your_workflow_look_like/i1zu29v/,1648163283,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
276.0,[],False,,ChrisPenner,,,[],,,,text,t2_14oqdg,False,False,"Love this, I often find myself stuck between the dangers of mis-ordering unnamed bindings or using field punning and risk forgetting to update that place when the type changes, this would give the best of both 👍🏼",34ff43472ad84b454ff9d8d9aecb382eaaa2e644,True,False,,,,,0,1648162873,,0,{},i1zt6vt,False,t3_tma69s,False,True,t3_tma69s,/r/haskell/comments/tma69s/ghc_proposal_wincompletefieldbinds_and/i1zt6vt/,1648162890,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
277.0,[],False,,dissatisfiedspoon,,,[],,,,text,t2_w18i2,False,False,[State of the Haskell Ecosystem](https://github.com/Gabriel439/post-rfc/blob/main/sotu.md) lists libraries for many of its domains.,0a666fe6ee0adf82f81dc9e5b383750103f1bf2f,True,False,,,,,0,1648161956,,0,{},i1zr2k3,False,t3_tmpfct,False,True,t3_tmpfct,/r/haskell/comments/tmpfct/haskell_important_libraries/i1zr2k3/,1648161974,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
278.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"Apparently, Juspay has a lot of large records:

&gt; [We wrote this library because Juspay recently engaged Well-Typed’s services, and one of their requests to us was to try and improve compilation time and compilation memory requirements for their code base. Juspay very generously allowed us to make large-records open source, and it is now available on Hackage.](https://well-typed.com/blog/2021/08/large-records/)",839e93831c4a5a2a1cfbf11bca9e7c6c1466157a,True,False,,,,,0,1648155892,,0,{},i1zc5s5,False,t3_tm900v,False,True,t1_i1zax87,/r/haskell/comments/tm900v/new_largerecords_release_now_with_100_fewer_quotes/i1zc5s5/,1648155909,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
279.0,[],False,,gcross,,,[],,,,text,t2_572z0,False,True,"Strictly out of curiosity, when does one encounter such large records in practice?",e63933796a04156c68733bc7116a83d9a71e488a,True,False,,,,,0,1648155400,,0,{},i1zax87,False,t3_tm900v,False,True,t3_tm900v,/r/haskell/comments/tm900v/new_largerecords_release_now_with_100_fewer_quotes/i1zax87/,1648155419,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
280.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"Yes, the online parsing means that it can produce results before it has seen all the input. [Here's a constant space parser for IP addresses I wrote](https://discourse.haskell.org/t/memory-usage-for-backtracking-in-infinite-stream-parsing/1384/12?u=jaror).",016c72d7985fb909dfe6db7eabbbe98bd49ebbda,True,False,,,,,0,1648154616,,0,{},i1z8xw2,False,t3_tmpfct,False,True,t1_i1z6fs5,/r/haskell/comments/tmpfct/haskell_important_libraries/i1z8xw2/,1648154628,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
281.0,[],False,,Thomasvoid,,,[],,,,text,t2_14v06h,False,False,"I've never hear of uu-parsinglib, do you know what it means by ""online parser"" in the title? And I agree with the MegaParsec point, it's really good. I find that Flatparse is better than attoparsec, but Flatparse uses a lot of QQs, though the performance is insane.",ae8a7da9dfacd613591f4cea3a18720709662f2d,True,False,,,,,0,1648153630,,0,{},i1z6fs5,False,t3_tmpfct,False,True,t1_i1yvbc9,/r/haskell/comments/tmpfct/haskell_important_libraries/i1z6fs5/,1648153649,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
282.0,[],False,,dskippy,,,[],,,,text,t2_2nw9r,False,False,Oh that's great to hear. I would love it if it got released as is since it would just make my life easier scripting a diagrams program with stack and knowing that it'll likely be growing and supported more in the future. I will give it a try asap and report back with my experience and the versions I'm using.,18e269a0036203b45e300d1914c9552eb11fa282,True,False,,,,,0,1648152773,,0,{},i1z48u4,True,t3_tlvopj,False,True,t1_i1z3qlj,/r/haskell/comments/tlvopj/looking_for_svg_library_recommendations/i1z48u4/,1648152787,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
283.0,[],False,,byorgey,,,[],,,,text,t2_304zb,False,False,"I think the only reason it's not released is that the original author had a bunch more things they wanted to add and hence did not consider it ""finished"".  But if people are finding it useful I'd be happy to release it to Hackage and officially support it as-is. (I've already been doing occasional updates to make sure it still builds with the latest GHC.)  If you do give it a try let me know!",4794d53d202da2103415323c3b33bfd67338dc65,True,False,,,,,0,1648152573,,0,{},i1z3qlj,False,t3_tlvopj,False,True,t1_i1yoopw,/r/haskell/comments/tlvopj/looking_for_svg_library_recommendations/i1z3qlj/,1648152592,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
284.0,[],False,,AisRauli,,,[],,,,text,t2_4mvi7,False,False,"Nothing like inline-csharp, unfortunately..

So I would use something like Conari to generate the C-compatible exports: https://github.com/3F/Conari

Then I would just bind to those exported functions with Haskell's FFI: https://wiki.haskell.org/Foreign_Function_Interface",b029dec9cf0742b877cb59bba6527ce277947b5b,True,False,,,,,0,1648151670,,0,{},i1z1fa0,False,t3_tdz3dr,False,True,t3_tdz3dr,/r/haskell/comments/tdz3dr/state_of_net_for_haskell/i1z1fa0/,1648151689,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
285.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,I just found the tradeoffs mentioned in [the conclusions of the original blog post about `large-records`](https://well-typed.com/blog/2021/08/large-records/#conclusions). I guess that explains the roadblocks.,a2e4943e135b8d5e8babf649783cfb81ecd23543,True,False,,,,,0,1648150275,,0,{},i1yxuwp,False,t3_tm900v,False,True,t1_i1ywh39,/r/haskell/comments/tm900v/new_largerecords_release_now_with_100_fewer_quotes/i1yxuwp/,1648150289,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
286.0,[],False,,proper_chad,,,[],,,,text,t2_4573ajy4,False,False,Looks that way to me too.,fc2f06fc69171c24a64103d26aebf40ceda0fc05,True,False,,,,,0,1648150116,,0,{},i1yxgkq,False,t3_tmr5g3,False,True,t1_i1yuliq,/r/haskell/comments/tmr5g3/by_changing_the_vector_definition_to_use_a_clever/i1yxgkq/,1648150132,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
287.0,[],False,,arjunswaj,,,[],,,,text,t2_8y0ip,False,False,Isn’t it time they swap implementation of foldl with foldl’,bbd94b4d7b3a6cb567d66d8a157bcf5b2f5ff76b,True,False,,,,,0,1648149878,,0,{},i1ywv8h,False,t3_tkpt4c,False,True,t1_i1u3v7z,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1ywv8h/,1648149892,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
288.0,[],False,,adamgundry,,,[],,,,text,t2_6g0pn,False,False,"I don't think there is currently a plan to implement this in GHC itself. There might well be scope for improving GHC's performance on large record types, but it's not trivial to achieve, and one would probably not want to make the trade-offs `large-records` does.",597f57d916f3e8c44da1ab4d3551861500c16223,True,False,,,,,0,1648149719,,0,{},i1ywh39,False,t3_tm900v,False,True,t1_i1xi1lj,/r/haskell/comments/tm900v/new_largerecords_release_now_with_100_fewer_quotes/i1ywh39/,1648149733,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
289.0,[],False,,adamgundry,,,[],,,,text,t2_6g0pn,False,False,"Roughly, yes. Actually `large-records` is designed to be used with [`record-dot-preprocessor`](https://hackage.haskell.org/package/record-dot-preprocessor), because it targets older GHC versions. But hopefully once `OverloadedRecordUpdate` is properly implemented they will wind up being more or less compatible.",07eeead6e098e1a06ede78bac8fa64f1a001c7a3,True,False,,,,,0,1648149602,,0,{},i1yw6f4,False,t3_tm900v,False,True,t1_i1xlsnd,/r/haskell/comments/tm900v/new_largerecords_release_now_with_100_fewer_quotes/i1yw6f4/,1648149613,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
290.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"I have been exclusively using [`tasty-bench`](https://hackage.haskell.org/package/tasty-bench) instead of `criterion`. It is really a lot smaller. It doesn't have the pretty HTML reports, but I've never really found those very useful. And more importantly it has the ability to compare benchmarks, so you can do performance regression tests.

Also, I'd say [`megaparsec`](https://hackage.haskell.org/package/megaparsec) is more generally useful than `attoparsec`. Both can achieve good speeds if you write your parsers correctly, but `megaparsec` just has more features. Although, I personally am very fond of [`uu-parsinglib`](https://hackage.haskell.org/package/uu-parsinglib), which is a whole other beast.

Maybe some prettyprinter library should also be added to complete the full compiler package. I don't have much experience with that, but it seems like [`prettyprinter`](https://hackage.haskell.org/package/prettyprinter) is the most popular pretty printing library on Hackage.",f79aee2b62c5820555d0ecb630786680fb0683f6,True,False,,,,,0,1648149264,,0,{},i1yvbc9,False,t3_tmpfct,False,True,t1_i1yksqq,/r/haskell/comments/tmpfct/haskell_important_libraries/i1yvbc9/,1648149279,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
291.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"Has this tweet been deleted? I'm getting:

&gt; Hmm... this page doesn’t exist. Try searching for something else.",f759bd396bc42b65d957d55b2862163662363a80,True,False,,,,,0,1648148982,,0,{},i1yuliq,False,t3_tmr5g3,False,True,t3_tmr5g3,/r/haskell/comments/tmr5g3/by_changing_the_vector_definition_to_use_a_clever/i1yuliq/,1648149000,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
292.0,[],False,,dskippy,,,[],,,,text,t2_2nw9r,False,False,"Oh this is very helpful, thank you! Do you know if this is ever likely to be fully supported or if it's on its way out the door eventually?",ffeb4314eccb74bc9ffef92a3b2d0ff2c598ef43,True,False,,,,,0,1648146670,,0,{},i1yoopw,True,t3_tlvopj,False,True,t1_i1xzaq2,/r/haskell/comments/tlvopj/looking_for_svg_library_recommendations/i1yoopw/,1648146687,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
293.0,[],False,,mordae_with_box,,,[],,,,text,t2_jlgh3,False,False,"The essential ones:

* [base](https://hackage.haskell.org/package/base/)
* [binary](https://hackage.haskell.org/package/binary/)
* [bytestring](https://hackage.haskell.org/package/bytestring/)
* [containers](https://hackage.haskell.org/package/containers/)
* [directory](https://hackage.haskell.org/package/directory/)
* [filepath](https://hackage.haskell.org/package/filepath/)
* [network](https://hackage.haskell.org/package/network/)
* [text](https://hackage.haskell.org/package/text/)
* [time](https://hackage.haskell.org/package/time/)
* [transformers](https://hackage.haskell.org/package/transformers/)
* [unordered-containers](https://hackage.haskell.org/package/unordered-containers/)
* [vector](https://hackage.haskell.org/package/vector/)

Other indispensable ones:

* [aeson](https://hackage.haskell.org/package/aeson/)
* [hspec](https://hackage.haskell.org/package/hspec/)

Solves something really well:

* [criterion](https://hackage.haskell.org/package/criterion/)
* [deepseq](https://hackage.haskell.org/package/deepseq/)
* [lens](https://hackage.haskell.org/package/lens/)
* [unliftio](https://hackage.haskell.org/package/unliftio/)
* [wai](https://hackage.haskell.org/package/wai/)
* [warp](https://hackage.haskell.org/package/warp/)

Super handy:

* [attoparsec](https://hackage.haskell.org/package/attoparsec/)",92def71a54616ce85ac7136c3dfa0e8173a29029,True,False,,,,,0,1648145138,,0,{},i1yksqq,False,t3_tmpfct,False,True,t3_tmpfct,/r/haskell/comments/tmpfct/haskell_important_libraries/i1yksqq/,1648145153,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
294.0,[],False,,Opposite-Platypus-99,,,[],,,,text,t2_clsnehel,False,False,Very nice!   A legend with the various contour types would be also much appreciated I guess,be0f5b7f2ca1da8cac8b0f7864a4fc318c4eb234,True,False,,,,,0,1648144387,,0,{},i1yivt3,False,t3_tl228c,False,True,t3_tl228c,/r/haskell/comments/tl228c/haskell_type_visualizer/i1yivt3/,1648144404,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
295.0,[],False,,sintrastes,,,[],,,,text,t2_i9tjx,False,False,"Can someone explain to me what this means and what sort of implications it has? Reading that issue and some of the links there is not helping.

I thought monomorphization was a compilation technique to convert parametrically polymorphic code into multiple specializations of that code for the relevant concrete types. As such, I thought this happened automatically for any data type with type parameters (at least if they're being used in a certain way). How does that relate to Data.List, and how/why would this be a breaking change?",c1c8dcdd03587e828dc1b6e989b6130828ba3672,True,False,,,,,0,1648140314,,0,{},i1y8com,False,t3_tjqw7a,False,True,t3_tjqw7a,/r/haskell/comments/tjqw7a/seeking_community_feedback_on_datalist/i1y8com/,1648140330,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
296.0,[],False,,byorgey,,,[],,,,text,t2_304zb,False,False,"https://github.com/diagrams/diagrams-input/ can read SVGs into diagrams, although it is unreleased and possibly slightly bitrotted -- YMMV.",9cca617b69ad73726219a25d304226bc7eedf190,True,False,,,,,0,1648136860,,0,{},i1xzaq2,False,t3_tlvopj,False,True,t1_i1xovge,/r/haskell/comments/tlvopj/looking_for_svg_library_recommendations/i1xzaq2/,1648136877,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
297.0,[],False,,dskippy,,,[],,,,text,t2_2nw9r,False,False,You're absolutely right. I realized that about a minute after posting that when I tried to write some test code with this. But I have not yet found a way to read in SVG into the SVG parent. Only anything but. Which is odd. I feel like I must be missing something obvious here.,0c56a48bc274eb1902d1e1820b03a5e1c4dc78b6,True,False,,,,,0,1648132727,,0,{},i1xovge,True,t3_tlvopj,False,True,t1_i1wr0dw,/r/haskell/comments/tlvopj/looking_for_svg_library_recommendations/i1xovge/,1648132738,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
298.0,[],False,,george_____t,,,[],,,,text,t2_el1wqq2,False,False,"Worth noting that `reanimate-svg` is essentially just a much more actively-maintained fork of `svg-tree`. I was hoping it would be merged upstream at some point, but it would already be a pretty big set of breaking changes.

Some background [here](https://github.com/Twinside/svg-tree/issues/23).",5417b274a8948d9950227c7f76a3733481447404,True,False,,,,,0,1648131690,,0,{},i1xmbwz,False,t3_tlvopj,False,True,t1_i1vuv2b,/r/haskell/comments/tlvopj/looking_for_svg_library_recommendations/i1xmbwz/,1648131705,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
299.0,[],False,,ocharles,,,[],,,,text,t2_9ojk6,False,False,"My understanding of the internals is a behavior should update whenever a dependency changes, but in this case b1 and b2 aren't changing at all, so I would expect things to not change here. Now that we have a bug report, I'll see if I can fix it!",e3239ced85bcd7481beeb55cd8841dd1018e47d3,True,False,,,,,0,1648131608,,0,{},i1xm4wh,False,t3_tk1khp,False,True,t1_i1xbwnb,/r/haskell/comments/tk1khp/reactivebanana_controlling_behavior_caching/i1xm4wh/,1648131620,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
300.0,[],False,,george_____t,,,[],,,,text,t2_el1wqq2,False,False,"There are references to `RecordDotSyntax`, the originally proposed name for an extension which was then split in to two, with that name never actually being used.

I assume we can read ""`RecordDotSyntax`"" as ""`OverloadedRecordDot` _and_ OverloadedRecordUpdate`""?",ee0c1307f527aaf37a1cd9be9a85bf0831d4a341,True,False,,,,,0,1648131468,,0,{},i1xlsnd,False,t3_tm900v,False,True,t3_tm900v,/r/haskell/comments/tm900v/new_largerecords_release_now_with_100_fewer_quotes/i1xlsnd/,1648131484,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
301.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,It sounds like we're getting close to having this implemented directly in the compiler. Are there any remaining roadblocks ore disadvantages that prevent that from happening?,70a0ee7a3448d5796c2318e23e94b3032777bd61,True,False,,,,,0,1648129876,,0,{},i1xi1lj,False,t3_tm900v,False,True,t3_tm900v,/r/haskell/comments/tm900v/new_largerecords_release_now_with_100_fewer_quotes/i1xi1lj/,1648129887,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
302.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"&gt; second example is parsed like this ([...] ++ createList) . ...

I initially thought that as well, but I don't think that is true now. `++` has a lower precedence than `.`, so it should just be parsed as `[...] ++ (createList . ...)`. The problem is that `... . dropWhile (/= ' ') a` at the end which tries to compose a function with a list.",70e890e00d0b77560a12550aaf9a87c604842892,True,False,,,,,0,1648127694,,0,{},i1xd8ij,False,t3_tm53ap,False,True,t1_i1xa58x,/r/haskell/comments/tm53ap/help_in_understanding_the_cause_of_error_while/i1xd8ij/,1648127706,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
303.0,[],False,,rainbyte,,,[],,,,text,t2_hh844,False,False,"In Haskell the `-&gt;` means function, an functions always take one thing an produce another thing.

When you see `a -&gt; b` it means a function which consumes an `a` and produces a `b`

Sometimes we see something like `a -&gt; b -&gt; c`, bit we know that a function in Haskell consumes only one thing and produces only one thing, so there is an implicit association, that expression really means `a -&gt; (b -&gt; c)`, ie. the function consumes the `a` and produces all the thing to the right, the `b -&gt; c`, which has another `-&gt;` inside, so it is a function from `b` to `c`

In some situations we need to pass a function as parameter, but because of the way `-&gt;` makes associations we need to tell it that everything to the left is a single thing, that's why we uses parentheses, so in `(a -&gt; b) -&gt; c` we are saying that `a -&gt; b` is a single thing which should be consumed to produce the `c`

I hope this explanation was useful :)",c09f67e59a73c8922614a68f412856728774a2c4,True,False,,,,,0,1648127188,,0,{},i1xc71y,False,t3_tjc9qw,False,False,t3_tjc9qw,/r/haskell/comments/tjc9qw/basic_funtions_types/i1xc71y/,1648127204,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
304.0,[],False,,gilgamec,,,[],,,,text,t2_10h5agrx,False,False,"Thanks! I wasn't really clear what the expected behaviour was here.  (It's plausible that `Behavior`s were implemented with something like a free Applicative, leading to a re-evaluation every time the endpoint changes.)",9e5a58b808fda09acca91f656d62bea4d39627ec,True,False,,,,,0,1648127048,,0,{},i1xbwnb,True,t3_tk1khp,False,True,t1_i1x1xst,/r/haskell/comments/tk1khp/reactivebanana_controlling_behavior_caching/i1xbwnb/,1648127060,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
305.0,[],False,,theeJoker11,,,[],,,,text,t2_2dc9hpiq,False,False,thanks for the help,1c47760e627fca44d8ff93f99033f183d7ab5f69,True,False,,,,,0,1648126611,,0,{},i1xb0tw,True,t3_tm53ap,False,True,t1_i1xa58x,/r/haskell/comments/tm53ap/help_in_understanding_the_cause_of_error_while/i1xb0tw/,1648126631,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
306.0,[],False,,theeJoker11,,,[],,,,text,t2_2dc9hpiq,False,False,got it thanks for the help,7a096296e88b11c323bbf51b0a9e22081faf37ee,True,False,,,,,0,1648126599,,0,{},i1xb00h,True,t3_tm53ap,False,True,t1_i1x9mc8,/r/haskell/comments/tm53ap/help_in_understanding_the_cause_of_error_while/i1xb00h/,1648126613,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
307.0,[],False,,SheepySheev,,,[],,,,text,t2_24y6j8mq,False,False,"I am on mobile, so don't really want to type too much code, but the underlying issue has already been outlined in the other answer you've got. Basically your top example is parsed like this: [...] ++ (tempTest a) and your second example is parsed like this ([...] ++ createList) . ...
If that makes sense. Again, sorry for lack of formatting. Changing . to $ does not help with that.",d9309e506a4c18f2acc9a2f9405ecdc646999ecf,True,False,,,,,0,1648126171,,0,{},i1xa58x,False,t3_tm53ap,False,True,t1_i1x84bo,/r/haskell/comments/tm53ap/help_in_understanding_the_cause_of_error_while/i1xa58x/,1648126189,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
308.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"If you really want to use `$` you can do it like this:

     createList a = [takeWhile (/= ' ') a] ++ createList (dropWhile (== ' ') $ dropWhile (/= ' ') a)",a70f8ef91616a780e62094990407dba18876ad36,True,False,,,,,0,1648125901,,0,{},i1x9mc8,False,t3_tm53ap,False,True,t1_i1x9220,/r/haskell/comments/tm53ap/help_in_understanding_the_cause_of_error_while/i1x9mc8/,1648125920,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
309.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,Don't use `$` here.,cf574a3479e28c7a5e04095e145070b049a2c926,True,False,,,,,0,1648125805,,0,{},i1x9fsy,False,t3_tm53ap,False,True,t1_i1x9220,/r/haskell/comments/tm53ap/help_in_understanding_the_cause_of_error_while/i1x9fsy/,1648125820,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
310.0,[],False,,theeJoker11,,,[],,,,text,t2_2dc9hpiq,False,False,"
hi,
if I replace all the . with $ then first the rightmost function call will run and the result will be pasted to the second last and so on then also the error is coming can you help why is this happening",ad74cba02de40f716cd6ec3b05481d053a4259b4,True,False,,,,,0,1648125606,,0,{},i1x9220,True,t3_tm53ap,False,True,t1_i1x8p2z,/r/haskell/comments/tm53ap/help_in_understanding_the_cause_of_error_while/i1x9220/,1648125619,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
311.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"Your expression

     createList a = [takeWhile (/= ' ') a] ++ createList . dropWhile (== ' ') . dropWhile (/= ' ') a

Will be parsed as follows:

     createList a = ([takeWhile (/= ' ') a] ++ createList) . dropWhile (== ' ') . dropWhile (/= ' ') a

Because `++` has greater precedence than `.`. 

You can solve this by adding parentheses as /u/SheepySheev suggests:

     createList a = [takeWhile (/= ' ') a] ++ (createList . dropWhile (== ' ') . dropWhile (/= ' ') a)",0534ee4f70a85690aa0cac4a8044275cbb37f9a6,True,False,,,,,0,1648125416,,0,{},i1x8p2z,False,t3_tm53ap,False,True,t3_tm53ap,/r/haskell/comments/tm53ap/help_in_understanding_the_cause_of_error_while/i1x8p2z/,1648125431,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
312.0,[],False,,theeJoker11,,,[],,,,text,t2_2dc9hpiq,False,False,if I replace all the . with $ then first the rightmost function call will run and the result will be pasted to the second last and ao on then also the error is coming can you help why is this happening,e9b48a419a03ce7195fc49a21fb38803bb35eff1,True,False,,,,,0,1648125112,,0,{},i1x84bo,True,t3_tm53ap,False,True,t1_i1x7g5b,/r/haskell/comments/tm53ap/help_in_understanding_the_cause_of_error_while/i1x84bo/,1648125128,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
313.0,[],False,,SheepySheev,,,[],,,,text,t2_24y6j8mq,False,False,I am guessing it will work if you put parentheses around the code you are pasting in (when you're replacing function name with its definition),795e701e8e393713483de2bf603a7062f8ae97ab,True,False,,,,,0,1648124747,,0,{},i1x7g5b,False,t3_tm53ap,False,True,t3_tm53ap,/r/haskell/comments/tm53ap/help_in_understanding_the_cause_of_error_while/i1x7g5b/,1648124758,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
314.0,[],False,,circleglyph,,,[],,,,text,t2_557783ba,False,False,"I use lucid and optics to do that sort of thing, in https://hackage.haskell.org/package/chart-svg",6810c99133495b2e474af9b80d22a5cf4afc43d6,True,False,,,,,0,1648123203,,0,{},i1x4pto,False,t3_tlvopj,False,True,t1_i1vvv1w,/r/haskell/comments/tlvopj/looking_for_svg_library_recommendations/i1x4pto/,1648123216,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
315.0,[],False,,Philoustic,,,[],,,,text,t2_92rllbcy,False,False,"Left or right was just an image. What I mean is that iterate could find a path which is not necessary the shortest one. And once found , it stops investigating further... So I suppose",4b5587d0237ef3e8f124a14c48d6831e7ad14ff6,True,False,,,,,0,1648122859,,0,{},i1x44pt,False,t3_tkpt4c,False,True,t1_i1wq9g9,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1x44pt/,1648122875,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
316.0,[],False,,ocharles,,,[],,,,text,t2_9ojk6,False,False,"Ok, I think I can reproduce this problem:

{-# language BlockArguments #-}

module Main where

import Data.Bool
import Data.Functor
import Debug.Trace
import Reactive.Banana
import Reactive.Banana.Frameworks

main :: IO ()
main = do
  (onSliderChanged, setSlider) &lt;- newAddHandler
  (onChangeCheckbox, changeCheckbox) &lt;- newAddHandler
  (printAH, doPrint) &lt;- newAddHandler

  actuate =&lt;&lt; compile do
    let xs = [True, False, True]

    n &lt;- fromChanges 0 onSliderChanged
    onToggle &lt;- fromAddHandler onChangeCheckbox
    onPrint &lt;- fromAddHandler printAH

    let b :: Behavior String
        b = n &lt;&amp;&gt; \x -&gt; replicate x '.'

    let mk1 vs = trace ""sampling 1"" . length $ vs
    let mk2 vs = trace ""sampling 2"" . (* 2) . length $ vs

    let b1 = mk1 &lt;$&gt; b
    let b2 = mk2 &lt;$&gt; b

    b' &lt;- switchB b1 $ bool b1 b2 &lt;$&gt; onToggle

    bChanges &lt;- changes b
    reactimate' $ pure (putStrLn ""b changed"") &lt;$ bChanges

    b1Changes &lt;- changes b1
    reactimate' $ pure (putStrLn ""b1 changed"") &lt;$ b1Changes

    b2Changes &lt;- changes b2
    reactimate' $ pure (putStrLn ""b2 changed"") &lt;$ b2Changes

    b'Changes &lt;- changes b'
    reactimate' $ pure (putStrLn ""b' changed"") &lt;$ b'Changes

    reactimate $ print &lt;$&gt; b' &lt;@ onPrint

    return ()

  putStrLn ""Setting slider""
  setSlider 10
  doPrint ()

  putStrLn ""Toggling checkbox""
  changeCheckbox True
  doPrint ()

  putStrLn ""Toggling checkbox""
  changeCheckbox False
  doPrint ()

  putStrLn ""Toggling checkbox""
  changeCheckbox True
  doPrint ()

  putStrLn ""Done""
  return ()

Prints

    Setting slider
    b changed
    b1 changed
    b2 changed
    b' changed
    sampling 1
    10
    Toggling checkbox
    b' changed
    sampling 2
    20
    Toggling checkbox
    b' changed
    sampling 1
    10
    Toggling checkbox
    b' changed
    sampling 2
    20
    Done

Which I think is a bug.",4bcc4dda31a37e1ef61776f5111634c072c5eb29,True,False,,,,,0,1648121532,,0,{},i1x1xst,False,t3_tk1khp,False,True,t1_i1s6zz5,/r/haskell/comments/tk1khp/reactivebanana_controlling_behavior_caching/i1x1xst/,1648121552,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
317.0,[],False,,ocharles,,,[],,,,text,t2_9ojk6,False,False,"I'm not sure I have enough information to reproduce this still. I put this together:

```
{-# language BlockArguments #-}

module Main where

import Data.Bool
import Data.Functor
import Debug.Trace
import Reactive.Banana
import Reactive.Banana.Frameworks

main :: IO ()
main = do
  (onSliderChanged, setSlider) &lt;- newAddHandler
  (onChangeCheckbox, changeCheckbox) &lt;- newAddHandler

  actuate =&lt;&lt; compile do
    let xs = [True, False, True]

    n &lt;- fromChanges 0 onSliderChanged
    onToggle &lt;- fromAddHandler onChangeCheckbox

    let b :: Behavior String
        b = n &lt;&amp;&gt; \x -&gt; replicate x '.'

    let mk1 vs = trace ""sampling 1"" . length $ vs
    let mk2 vs = trace ""sampling 2"" . (* 2) . length $ vs

    let b1 = mk1 &lt;$&gt; b
    let b2 = mk2 &lt;$&gt; b

    b' &lt;- switchB b1 $ bool b1 b2 &lt;$&gt; onToggle

    bChanges &lt;- changes b
    reactimate' $ pure (putStrLn ""b changed"") &lt;$ bChanges

    b1Changes &lt;- changes b1
    reactimate' $ pure (putStrLn ""b1 changed"") &lt;$ b1Changes

    b2Changes &lt;- changes b2
    reactimate' $ pure (putStrLn ""b2 changed"") &lt;$ b2Changes

    b'Changes &lt;- changes b'
    reactimate' $ pure (putStrLn ""b' changed"") &lt;$ b'Changes

    return ()

  putStrLn ""Setting slider""
  setSlider 10

  putStrLn ""Toggling checkbox""
  changeCheckbox True

  putStrLn ""Toggling checkbox""
  changeCheckbox False

  putStrLn ""Toggling checkbox""
  changeCheckbox True

  putStrLn ""Done""
  return ()
```

Which prints:

```
ghci&gt; main
Setting slider
b changed
b1 changed
b2 changed
b' changed
Toggling checkbox
b' changed
Toggling checkbox
b' changed
Toggling checkbox
b' changed
Done
```

Which I think is what you want, but not what you're seeing.

Could you show me what `mkSlider` is? But really I need something I can run to really be able to nail this.",85fd938c4f852bf96ad10d0e6a29207cc4dfb965,True,False,,,,,0,1648121283,,0,{},i1x1jkf,False,t3_tk1khp,False,True,t1_i1s6zz5,/r/haskell/comments/tk1khp/reactivebanana_controlling_behavior_caching/i1x1jkf/,1648121299,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
318.0,[],False,,tkx68,,,[],,,,text,t2_56gja,False,False,This is certainly just a first step. But having a visual language for functional languages with a rich type system would be really interesting.,06e3773fd663fab02e5574a6f04d5a41e8b9dad5,True,False,,,,,0,1648116639,,0,{},i1wv3s3,False,t3_tl228c,False,True,t3_tl228c,/r/haskell/comments/tl228c/haskell_type_visualizer/i1wv3s3/,1648116653,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
319.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,Types are usually not evaluated.,926cff23e8cd1a727a045346421ce2625776b868,True,False,,,,,0,1648115301,,0,{},i1wthwe,False,t3_tl228c,False,True,t1_i1vwv4f,/r/haskell/comments/tl228c/haskell_type_visualizer/i1wthwe/,1648115313,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
320.0,[],False,,uncleglitch,,,[],,,,text,t2_89ejiow,False,False,Nice idea!,711a7730f5669165ac0c4b1238061bfaf7f6226c,True,False,,,,,0,1648114267,,0,{},i1ws8sg,False,t3_tl228c,False,True,t3_tl228c,/r/haskell/comments/tl228c/haskell_type_visualizer/i1ws8sg/,1648114282,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
321.0,[],False,,fegu,,,[],,,,text,t2_1v9b,False,False,"I think the unfortunately named loadImageSVG only supports loading bitmaps into an SVG, not loading SVG.",48fe23af018e8e5daaa2d23d38b40803e2be578e,True,False,,,,,0,1648113215,,0,{},i1wr0dw,False,t3_tlvopj,False,True,t1_i1w5twz,/r/haskell/comments/tlvopj/looking_for_svg_library_recommendations/i1wr0dw/,1648113231,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
322.0,[],False,,DmitryTsepelev,,,[],,,,text,t2_21cqe56c,False,False,"The thing is that iterate not goes left or right, it goes to all possible directions. For instance we need a way from b3 to g5:

```
[
-- step 0
[('b','3')],
-- step 1
[('a','1'),('a','5'),('c','1'),('c','5'),('d','2'),('d','4')],
-- step 2
[('b','3'),('c','2'),('b','3'),('b','7'),('c','4'),('c','6'),('b','3'),('a','2'),('d','3'),('e','2'),('b','3'),('b','7'),('a','4'),('a','6'),('d','3'),('d','7'),('e','4'),('e','6'),('c','4'),('b','1'),('b','3'),('e','4'),('f','1'),('f','3'),('c','2'),('c','6'),('b','3'),('b','5'),('e','2'),('e','6'),('f','3'),('f','5')],
-- step 3 (take while finds g5 and stops here not returning this step
[('a','1'),('a','5'),('c','1'),('c','5'),('d','2'),('d','4'),('b','4'),('a','1'),('a','3'),('d','4'),('e','1'),('e','3'),('a','1'),('a','5'),('c','1'),('c','5'),('d','2'),('d','4'),('a','5'),('c','5'),('d','6'),('d','8'),('b','2'),('b','6'),('a','3'),('a','5'),('d','2'),('d','6'),('e','3'),('e','5'),('b','4'),('b','8'),('a','5'),('a','7'),('d','4'),('d','8'),('e','5'),('e','7'),('a','1'),('a','5'),('c','1'),('c','5'),('d','2'),('d','4'),('b','4'),('c','1'),('c','3'),('c','1'),('c','5'),('b','2'),('b','4'),('e','1'),('e','5'),('f','2'),('f','4'),('d','4'),('c','1'),('c','3'),('f','4'),('g','1'),('g','3'),('a','1'),('a','5'),('c','1'),('c','5'),('d','2'),('d','4'),('a','5'),('c','5'),('d','6'),('d','8'),('b','2'),('b','6'),('c','3'),('c','5'),('b','4'),('b','8'),('c','5'),('c','7'),('c','1'),('c','5'),('b','2'),('b','4'),('e','1'),('e','5'),('f','2'),('f','4'),('c','5'),('b','6'),('b','8'),('e','5'),('f','6'),('f','8'),('d','2'),('d','6'),('c','3'),('c','5'),('f','2'),('f','6'),('g','3'),('g','5'),('d','4'),('d','8'),('c','5'),('c','7'),('f','4'),('f','8'),
-- here it is!!!!
('g','5'),
('g','7'),('b','2'),('b','6'),('a','3'),('a','5'),('d','2'),('d','6'),('e','3'),('e','5'),('a','3'),('c','3'),('d','2'),('a','1'),('a','5'),('c','1'),('c','5'),('d','2'),('d','4'),('d','2'),('d','6'),('c','3'),('c','5'),('f','2'),('f','6'),('g','3'),('g','5'),('e','3'),('d','2'),('g','3'),('h','2'),('e','1'),('e','5'),('d','2'),('d','4'),('g','1'),('g','5'),('h','2'),('h','4'),('b','4'),('a','1'),('a','3'),('d','4'),('e','1'),('e','3'),('b','4'),('b','8'),('a','5'),('a','7'),('d','4'),('d','8'),('e','5'),('e','7'),('a','1'),('a','5'),('c','1'),('c','5'),('d','2'),('d','4'),('a','3'),('a','7'),('c','3'),('c','7'),('d','4'),('d','6'),('d','4'),('c','1'),('c','3'),('f','4'),('g','1'),('g','3'),('d','4'),('d','8'),('c','5'),('c','7'),('f','4'),('f','8'),('g','5'),('g','7'),('e','1'),('e','5'),('d','2'),('d','4'),('g','1'),('g','5'),('h','2'),('h','4'),('e','3'),('e','7'),('d','4'),('d','6'),('g','3'),('g','7'),('h','4'),('h','6')]
]
```",d7aba5bb4495feac341c1291af463529e20178aa,True,False,,,,,0,1648112571,,0,{},i1wq9g9,True,t3_tkpt4c,False,False,t1_i1wpjcq,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1wq9g9/,1648112587,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
323.0,[],False,,Philoustic,,,[],,,,text,t2_92rllbcy,False,False,"That's the point... Suppose the shortest path is to your right. And suppose that the first steps of iterate go to the left and find the final position after going all around the board... takeWhile will stop when he find this path. There is no garantee that he will explore the right path,  is there ?

I don't claim to be $ right, I'm not an expert either, but this behavior of the algo always remains  mysterious to me :-)",e685da63dded8c01709cfd325151dc7d6708970c,True,False,,,,,0,1648111924,,0,{},i1wpjcq,False,t3_tkpt4c,False,True,t1_i1svtov,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1wpjcq/,1648111940,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
324.0,[],False,,DmitryTsepelev,,,[],,,,text,t2_21cqe56c,False,False,"good point, I'll rephrase this sentence 🙂",2a4e636a4f82bacc59f066f22c779dfbc2dc5603,True,False,,,,,0,1648111520,,0,{},i1wp2vv,True,t3_tkpt4c,False,True,t1_i1wnw8q,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1wp2vv/,1648111536,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
325.0,[],False,,contextualMatters,,,[],,,,text,t2_16xbk9,False,False,"Stackage is the only synchronization point for the haskell ecosystem as a whole AFAIU. This provides a compatibility target to library author and reliable builds for users.

Ocaml ecosystem is synchronized around the compiler version which is even simpler to aim but less flexible.

Stackage provides a great practical value to the ecosystem. I wonder how many other languages have this match of flexibility/reliability.


PS : Are there any tutorial on how to use Stackage from Haskell.nix infrastructure ? Now that would be very reliable.",9cb3da749f413b24604c57149c134d6933ee6e7a,True,False,,,,,0,1648110525,,0,{},i1wnyz3,False,t3_tj0496,False,True,t3_tj0496,/r/haskell/comments/tj0496/stack_lts_19_release_and_nightly_on_ghc92/i1wnyz3/,1648110536,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
326.0,[],False,,riftdc,,,[],,,,text,t2_10kz2q,False,False,"Cool! My 2 cents: You mention the type checking as “guesses”; type checking isn’t a guess, but rather inference — “a guess” reads to me as something that could be wrong, but an inferred type will never be wrong",435b242534114367d44fc120a54de3fdba434709,True,False,,,,,0,1648110457,,0,{},i1wnw8q,False,t3_tkpt4c,False,True,t3_tkpt4c,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1wnw8q/,1648110473,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
327.0,[],False,,Competitive_Ad2539,,,[],,,,text,t2_8g6liftg,False,False,"Yeah, this app slaughters the semantics of any given type, because it doesn't understand shit. It depicts a pair, an Either, a bifunctor, a profunctor, and an arrow in the same way, wtf? It just operates on type signature and the kinds of all the type variables it has.",11ce3eb5ec28560ce2a24292363529808099457b,True,False,,,,,0,1648109961,,0,{},i1wnc40,False,t3_tl228c,False,True,t1_i1wkg0b,/r/haskell/comments/tl228c/haskell_type_visualizer/i1wnc40/,1648109975,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
328.0,[],False,,enobayram,,,[],,,,text,t2_90u7a,False,False,"It doesn't seem to care about concrete types or type constructors, so (,,) and Either behave the same as some parametric `f :: Type -&gt; Type -&gt; Type`. The same goes for Int vs. Bool vs. `a :: Type`. It also completely ignores constraints.

Still a cool project, but I think it could be actually useful if there were customisations so that Int were represented with a symbol that intuitively represents Int, also for Bool etc. And then type classes could also have special intuitively representations, like `Monoid a =&gt; a` would appear as a &lt;&gt; symbol, or a `Functor f` would have some special border or background. Then who knows, these visualisations could actually help understanding a complex type at a glance after a certain amount of exposure?",98bd53733da4ab5a4ccd8e5ea00a0867bfef4d06,True,False,,,,,0,1648107476,,0,{},i1wkg0b,False,t3_tl228c,False,True,t1_i1wer4g,/r/haskell/comments/tl228c/haskell_type_visualizer/i1wkg0b/,1648107493,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
329.0,[],False,,Competitive_Ad2539,,,[],,,,text,t2_8g6liftg,False,False,"Bruh, it depicts a pair as a Black circle with 2 points, and the dual data type - Either as a Blue circle with 2 points. Smh",61aff715f8d6defc12e6096551351a45593fed8e,True,False,,,,,0,1648102836,,0,{},i1wer4g,False,t3_tl228c,False,True,t3_tl228c,/r/haskell/comments/tl228c/haskell_type_visualizer/i1wer4g/,1648102847,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
330.0,[],False,,masklinn,,,[],,,,text,t2_d5sb,False,False,"&gt; Foldr has a simmilar characteristic to foldl in that it also works in O(n) space. 

It’s been years since i last did some haskell but IIRC the entire point of recommending foldr is it works *with* laziness to achieve O(1) space, including when accumulating to a (lazy) list, foldr does not accumulate more than one thunk. That’s why Haskell is fairly unique in recommending foldr over foldl as the “default” fold. 

Foldl, on the other hand, has to accumulate a pile of all the thunks before it can start returning.",b9a70cfeb9b258c9f2d590bca9516c02b1815b6e,True,False,,,,,0,1648100210,,0,{},i1wb8tx,False,t3_tkpt4c,False,True,t1_i1u3v7z,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1wb8tx/,1648100223,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
331.0,[],False,,sleepisafunnything,,,[],,,,text,t2_adab4,False,False,No worries!,619391f4eb879bdd4127b80650378d1f17aa6589,True,False,,,,,0,1648098138,,0,{},i1w89od,False,t3_tlvopj,False,True,t1_i1w5twz,/r/haskell/comments/tlvopj/looking_for_svg_library_recommendations/i1w89od/,1648098154,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
332.0,[],False,,dskippy,,,[],,,,text,t2_2nw9r,False,False,"Oh wow \*this\* might really be what I need. I totally forgot about this library. Someone present on this at my local Haskell meetup years ago too. It has real documentation, which is pretty huge and I think Diagrams.Backend.SVG.loadImageSVG might give me the ability to import that I need to have. Thanks so much for the reply. I'm going to go try playing with this.",d1fa19b7cff805dc641c3e4fbea258e0a8b8567d,True,False,,,,,0,1648096558,,0,{},i1w5twz,True,t3_tlvopj,False,True,t1_i1w4xpl,/r/haskell/comments/tlvopj/looking_for_svg_library_recommendations/i1w5twz/,1648096575,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
333.0,[],False,,sleepisafunnything,,,[],,,,text,t2_adab4,False,False,Diagrams?,ea2b1e6423f795e90e2f92202b52de10d5d2380e,True,False,,,,,0,1648096022,,0,{},i1w4xpl,False,t3_tlvopj,False,True,t3_tlvopj,/r/haskell/comments/tlvopj/looking_for_svg_library_recommendations/i1w4xpl/,1648096037,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
334.0,[],False,,hoainam150399,,,[],,,,text,t2_15kyxd,False,False,"Sorry, I’m afraid not.

That aside, it seems that `svg-tree` doesn’t support filter elements, so I recommend `reanimate-svg`. You can join the Discord server for [Reanimate](https://discord.gg/Qs28Dv6) and ask for help. It’s an active place.

Can you show some example SVGs that you’re trying to generate using Haskell?",c4796c37b4ab8f3f2c26cb81044de71309181b1e,True,False,,,,,0,1648093229,,0,{},i1w01th,False,t3_tlvopj,False,True,t1_i1vvv1w,/r/haskell/comments/tlvopj/looking_for_svg_library_recommendations/i1w01th/,1648093244,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
335.0,[],False,,hoainam150399,,,[],,,,text,t2_15kyxd,False,False,"Sorry, I’m afraid not.

That aside, it seems that `svg-tree` doesn’t support filter elements, so I recommend `reanimate-svg`. You can join the Discord server for [Reanimate](https://discord.gg/Qs28Dv6) and ask for help. It’s an active place.

Can you also show some example SVGs that you’re trying to generate using Haskell?",f319464591e3a7a6c68460fb78146253018dfae4,True,False,,,,,0,1648093152,,0,{},i1vzwnu,False,t3_tlvopj,False,True,t1_i1vvv1w,/r/haskell/comments/tlvopj/looking_for_svg_library_recommendations/i1vzwnu/,1648093167,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
336.0,[],False,,hoainam150399,,,[],,,,text,t2_15kyxd,False,False,"Sorry, I’m afraid not.

That aside, it seems that `svg-tree` doesn’t support filter elements, so I recommend `reanimate-svg`. You can join the Discord server for [Reanimate](https://reanimate.github.io) and ask for help. Good luck.",7c874fe48391b724966f33130bbc0cd7fb6dd212,True,False,,,,,0,1648091741,,0,{},i1vx8b8,False,t3_tlvopj,False,True,t1_i1vvv1w,/r/haskell/comments/tlvopj/looking_for_svg_library_recommendations/i1vx8b8/,1648091755,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
337.0,[],False,,SolaTotaScriptura,,,[],,,,text,t2_5dpnr08,False,False,Cool. I'm now imagining how the visualisation could be animated to depict evaluation...,a3f6f13ea7fa1417cd7ea6234072628c94c79e19,True,False,,,,,0,1648091554,,0,{},i1vwv4f,False,t3_tl228c,False,True,t3_tl228c,/r/haskell/comments/tl228c/haskell_type_visualizer/i1vwv4f/,1648091569,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
338.0,[],False,,dskippy,,,[],,,,text,t2_2nw9r,False,False,Yeah it's currently seeming like the only library that really supports it all. I can just build up my own abstractions around making the drawing easier. Do you have your lens and SVG code shared anywhere?,cb18a16993500749639920fd5b3a15856eef877b,True,False,,,,,0,1648091047,,0,{},i1vvv1w,True,t3_tlvopj,False,True,t1_i1vuv2b,/r/haskell/comments/tlvopj/looking_for_svg_library_recommendations/i1vvv1w/,1648091062,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
339.0,[],False,,hoainam150399,,,[],,,,text,t2_15kyxd,False,False,I recommend `svg-tree` and `lens`. I’m currently using `reanimate-svg` (very similar to `svg-tree`) and lenses from `lens` to create SVG-based animations.,0781fa37fa5bbb23b869436d9e2c73902540508c,True,False,,,,,0,1648090543,,0,{},i1vuv2b,False,t3_tlvopj,False,True,t3_tlvopj,/r/haskell/comments/tlvopj/looking_for_svg_library_recommendations/i1vuv2b/,1648090558,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
340.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"`a` takes a function and returns a number; you might see it called like `a id`, `a succ`, `a (*2)`, or `a (^2)`.  An implementation might be `a f = f 420`.

`b` takes a number and returns a (function that takes a number and returns a number); you might see it called like `b 3 8` or `b 42 69`.  An implementation might be `b x y = x + y`.

`c` takes a (function that takes a number and returns a number) and returns a (function that take a number and returns a number); you might see it called like `c succ 69`.  An implementation might be `c f = f . f . f`.

---

`Int -&gt; Int -&gt; Int` is the same as `Int -&gt; (Int -&gt; Int)`; it is distinctly different from `(Int -&gt; Int) -&gt; Int`.",7643b7f9e6c1cb8a27dc8ba2a7eed7e6ea23a559,True,False,,,,,0,1648088155,,0,{},i1vpwwd,False,t3_tjc9qw,False,True,t3_tjc9qw,/r/haskell/comments/tjc9qw/basic_funtions_types/i1vpwwd/,1648088171,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
341.0,[],False,,c_wraith,,,[],,,,text,t2_7kbl2,False,False,"But that's not the type of traverse.  https://www.type-depict.io/traverse%20::%20%28Traversable%20t,%20Applicative%20f%29%20=%3E%20%28a%20-%3E%20f%20b%29%20-%3E%20t%20a%20-%3E%20f%20%28t%20b%29 is",67ef31e5275c8239c705795e18cb53eef953a062,True,False,,,,,0,1648087166,,0,{},i1vns6l,False,t3_tl228c,False,True,t1_i1vmc5c,/r/haskell/comments/tl228c/haskell_type_visualizer/i1vns6l/,1648087182,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
342.0,[],False,,taylorfausak,,,[],,,,text,t2_4hurx,False,False,"Here's a working link to that example: &lt;https://www.type-depict.io/traverse%20::%20(Traversable%20t,%20Applicative%20f)%20=%3E%20(a%20-%3E%20f%20b)%20-%3E%20t%20a%20-%3E%20f%20(t%20b)%20=%3E%20(a%20-%3E%20f%20b)%20-%3E%20t%20a%20-%3E%20f%20(t%20b))&gt;",86375fb37efbed7dccda993ccc8079d98d6128cd,True,False,,,,,0,1648086510,,0,{},i1vmc5c,False,t3_tl228c,False,True,t3_tl228c,/r/haskell/comments/tl228c/haskell_type_visualizer/i1vmc5c/,1648086529,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
343.0,[],False,,Endicy,,,[],,,,text,t2_mz4isnd,False,False,"Just realized `takeWhile` and `filter` are technically the same thing in this situation, so you can be even more succint like so:

    apm b c (x, y) =
      takeWhile checker $ (x, y .+ 1) : [(x, y .+ 2) | isPawnStart]
     where
      -- Basically the ""move forward"" operator
      (.+) = if c == Black then (+) else (-)
      isPawnStart =
        (c, y) == (Black, 1) || (c, y) == (White, 6)",d59587fc8e8cd1b12f82b67a5ef984b7fbc016ce,True,False,,,,,0,1648082631,,0,{},i1vdn3z,False,t3_tjforr,False,True,t1_i1rdhvr,/r/haskell/comments/tjforr/writing_proper_haskell_code/i1vdn3z/,1648082643,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
344.0,[],False,,affinehyperplane,,,[],,,,text,t2_12xogr,False,False,"There is no reason to use `foldl` for the usual cons list `[]`. But if you work with snoc lists for some reason, `foldl` (and `foldr'`) are perfectly reasonable to use (and dually, `foldr` and `foldl'` are not).

    -- data [] a = [] | a : [a]
    data ConsList a = EmptyConsList | Cons a (ConsList a)
    data SnocList a = EmptySnocList | Snoc (SnocList a) a",ba2af61bf8531554ffea23bbf3a8e7aa33d53b86,True,False,,,,,0,1648071002,,0,{},i1um1on,False,t3_tkpt4c,False,True,t1_i1ryu4z,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1um1on/,1648071016,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
345.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"If `seq` doesn't to anything to your result type (for example, using `foldl` to build a function), there's no advantage and some cost to `foldl'`.

But, that's pretty rare, usually `foldr` or `foldl'` are what you want.",3dbbcce12359c383e8cf6579414495a10d93f68e,True,False,,,,,0,1648066550,,0,{},i1uaihw,False,t3_tkpt4c,False,True,t1_i1u3v7z,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1uaihw/,1648066566,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
346.0,[],False,,Iceland_jack,,,[],,,,text,t2_3qjdu,False,False,`foldr` vs `foldl'` is the really advanced topic in Haskell,7c2fb931573f59f5a6960ed82ca11f388e8334af,True,False,,,,,0,1648065938,,0,{},i1u8wwo,False,t3_tkpt4c,False,True,t1_i1u3v7z,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1u8wwo/,1648065959,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
347.0,[],False,,ysangkok,,,[],,,,text,t2_4qktt,False,False,I am not the author of this post so the submission of it here does not necessarily mean that Brendan Hay would appreciate comments on the GitHub issue that are not related to Amazonka.,40c2c4c74b3169042fbebdc844857ea9b0affc88,True,False,,,,,0,1648064565,,0,{},i1u59r0,True,t3_tl9zhp,False,True,t3_tl9zhp,/r/haskell/comments/tl9zhp/usability_of_smart_constructors_and_large_records/i1u59r0/,1648064583,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
348.0,[],False,,zaabson,,,[],,,,text,t2_2j0k07a1,False,False,"i think more accurate is : You should never use foldl instead of foldl'. Foldr has a simmilar characteristic to foldl in that it also works in O(n) space. Probably it plays better with list fusion, but I will let others comment on it.",e1fb98fe7fe9351c8f5a5e37a10467aeb3d9e846,True,False,,,,,0,1648064026,,0,{},i1u3v7z,False,t3_tkpt4c,False,True,t1_i1ryu4z,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1u3v7z/,1648064041,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
349.0,[],False,,lgastako,,,[],,,,text,t2_1mp2i,False,False,"I think that if you hadn't done any programming at all before it might be possible to pick up the basics in a week, but if you've done programming in other languages before there's simply too much to unlearn first.",aa412e4ab0d65f87a802dfcfd40d6fd3a0551f5a,True,False,,,,,0,1648063462,,0,{},i1u2edc,False,t3_tjsna2,False,True,t3_tjsna2,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1u2edc/,1648063477,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
350.0,[],False,,brandonchinn178,,,[],,,,text,t2_ognt1qc,False,False,foldr or foldl' (the strict version of foldl),dda7ac40a2f36aeca79eff805bf4006aa01da007,True,False,,,,,0,1648062435,,0,{},i1tzpzv,False,t3_tkpt4c,False,True,t1_i1ryu4z,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1tzpzv/,1648062449,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
351.0,[],False,,dun-ado,,,[],,,,text,t2_ihltqlra,False,False,"It's extremely unlikely you're going to learn Haskell in a week unless you're comfortable with some other FP language like OCaml/SML, F#.

But if a compiler class is going to use to implement a compiler, you may not need to as you can learn it in class as you learn about compilers.",4e6dfb0d3079871f74b22a8af23db07c313532b1,True,False,,,,,0,1648060604,,0,{},i1tuy0o,False,t3_tjsna2,False,True,t3_tjsna2,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1tuy0o/,1648060616,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
352.0,[],False,,dun-ado,,,[],,,,text,t2_ihltqlra,False,False,I'm sorry for that comment. Please ignore me and carry on.,e358792bfb5b282c8f1e023395651cc903fb2629,True,False,,,,,0,1648060029,,0,{},i1ttffh,False,t3_tk6kxo,False,True,t1_i1qmglf,/r/haskell/comments/tk6kxo/can_the_haskell_ffi_pass_functions_on_lists_to_c/i1ttffh/,1648060043,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
353.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"&gt; Haskell plugin for IntelliJ

If you want to get the best Haskell tooling you will have to use something that supports the Language Server Protocol, which is a standard that is completely separate from Haskell. [Here's a list of editors which support this protocol](https://microsoft.github.io/language-server-protocol/implementors/tools/). You can try [this plugin for IntelliJ](https://plugins.jetbrains.com/plugin/10209-lsp-support), but I don't know how good that is.

&gt; Several gigabytes of cache and ~20 minutes for a small/medium project seems a bit too much for me

I don't think those numbers are typical. I would expect numbers like that for large projects like Pandoc, but not for small projects. Could you show the cabal/package.yaml file of your project? Also note that the most time is often spent during compilation of dependencies, so you will probably only have to sit through it once every few months.",debec54351904a0396e949273328d7d59684f895,True,False,,,,,0,1648053404,,0,{},i1tbloq,False,t3_tkpt4c,False,True,t1_i1syxy2,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1tbloq/,1648053422,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
354.0,[],False,,maerwald,,,[],,,,text,t2_t8qgl,False,False,"Yeah, stack doesn't provide GHC bindists on alpine. ghcup does.",0f5eccfdc76fad97776cc137546b46db05c99194,True,False,,,,,0,1648052291,,0,{},i1t8luh,False,t3_tkpt4c,False,True,t1_i1t5bji,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1t8luh/,1648052302,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
355.0,[],False,,monnef,,,[],,,,text,t2_c7cq0,False,False,"Maybe Stack doesn't work on Alpine? Or maybe it was my fault. I tried it few months back and hand't had much luck. I'll add it to my todo list then, since it should produce significantly smaller images.",8cad8de474e252c3c28d3e93872265438355ea76,True,False,,,,,0,1648051055,,0,{},i1t5bji,False,t3_tkpt4c,False,True,t1_i1szetl,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1t5bji/,1648051069,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
356.0,[],False,,maerwald,,,[],,,,text,t2_t8qgl,False,False,"&gt; I also believe GHC doesn't work (and I think doesn't produce binaries working) in Alpine, so that's another size bump by a gig or more.

It does work fine. There are bindists for GHC and many programs (such as ghcup and HLS) are built on Alpine.",93847c038a925c9a0e54abae35c7a30e0fd73879,True,False,,,,,0,1648048806,,0,{},i1szetl,False,t3_tkpt4c,False,True,t1_i1syxy2,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1szetl/,1648048823,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
357.0,[],False,,monnef,,,[],,,,text,t2_c7cq0,False,False,"I am not a total newbie, but very far from working in Haskell full time (maybe like 1/10 time).

Just now, I am trying to fix broken Haskell plugin for IntelliJ (""it gets stuck in REPL couldn't be started for 30 seconds""). The plugin broke after updating the project to last LTS resolver (the stack thing). *When* the plugin was working (it worked fine for months), it was alright. Not many intentions and refactoring available compared to some mainstream languages like TypeScript or Scala, a bit cumbersome to create a new project, but it was ok. Sometimes it got very slow (e.g. waiting 10 seconds to show type or refresh errors in code). The plugin only supports Stack, so I can't even try things like GHCJS (not that I want to use anything else than Stack; wasted dozens of hours few years back in vain attempts at getting GHCJS working and I am not giving it another shot any time soon unless Stack is supported / supports it).

From ""users"" perspective, compiling even smaller Haskell project including Stack setup takes too much time and space. Several gigabytes of cache and ~20 minutes for a small/medium project seems a bit too much for me (on M2 SSD, 32GB ram, 3800x). This gets pretty bad when you want to distribute your project via docker (each build takes like 4-5GB, splitting build container got it to barely acceptable 1.8GB). I also believe GHC doesn't work (and I think doesn't produce binaries working) in Alpine, so that's another size bump by a gig or more.

Because of lack of cross compilation, Haskell cannot be used on weaker hw with different arch like RPi 4 (just hello world in stack took I think 5 hours).

I like the language (it has some minor warts, but it's being worked on, e.g. records). But for me (an IntelliJ IDEA user) the tooling is far from ideal, it's barely usable and sadly doesn't come close to what I am used to :/.",8997f4dd150aee1958e9f3e02979eff47ba51127,True,False,,,,,0,1648048627,,0,{},i1syxy2,False,t3_tkpt4c,False,True,t1_i1s0x45,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1syxy2/,1648048643,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
358.0,[],False,,Bob-The-One,,,[],,,,text,t2_40ytr8v2,False,False,"Thanks, I'll give it a try.",ba8690a75b25aa8c698024d7c5e6d892d22f1b3b,True,False,,,,,0,1648047439,,0,{},i1svwys,False,t3_tkpt4c,False,True,t1_i1stn5u,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1svwys/,1648047461,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
359.0,[],False,,DmitryTsepelev,,,[],,,,text,t2_21cqe56c,False,False,"Hi! I might be wrong, but when we use iterate, we get a list of lists, where each list contains all possible positions that can be achieved from the previous step, i.e. \`\[\[initial position\], \[all positions from initial\], \[all positions from the previous step\], ...\]. takeWhile will stop when we find a step containing the position we look for, so it should be at least one of shortest paths, right?",1328b3f6ebf66f2a6afc9305df4ba0cc4fda35d1,True,False,,,,,0,1648047404,,0,{},i1svtov,True,t3_tkpt4c,False,True,t1_i1sh69l,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1svtov/,1648047417,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
360.0,[],False,,sunnyata,,,[],,,,text,t2_4lxh3lrv,False,False,I've never used stack for more than toy things so I can't compare but I find cabal plenty fast enough. The problems you've heard about are likely to be from the past and now solved.,12ea4b1001f9876e9081dc62ba10daa06d2fda86,True,False,,,,,0,1648046545,,0,{},i1stn5u,False,t3_tkpt4c,False,True,t1_i1sn5fc,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1stn5u/,1648046562,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
361.0,[],False,,simonmic,,,[],,,,text,t2_3a0g0,False,False,"Haskell Tutorial and Cookbook
https://www.fpcomplete.com/haskell/#get-started-with-haskell
Haskell wikibook 
Other things you like the look of at https//extrema.is/books",ad3d3741699c3816eb449b34e609cd0f40bf3eb0,True,False,,,,,0,1648046462,,0,{},i1stfif,False,t3_tjsna2,False,True,t3_tjsna2,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1stfif/,1648046479,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
362.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"&gt; property testing as a version of fuzzing

Agreed.  Property testing tends toward white-box and fuzzing tends toward black-box.  Property testing tends toward internal testers/tooling and fuzzing tends toward external testers/tooling.  Property tests tend to be framed around what success looks like and fuzzing tests to be framed around how fault are controlled.  But, there's still quite a bit in common between the practices.",b039bdabad2071c9c97304ce0837fed63414e883,True,False,,,,,0,1648044393,,0,{},i1soc39,False,t3_tjxh34,False,True,t1_i1rkqs0,/r/haskell/comments/tjxh34/property_testing_am_i_missing_something/i1soc39/,1648044406,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
363.0,[],False,,Bob-The-One,,,[],,,,text,t2_40ytr8v2,False,False,"Yeah, that's fair. It's all trade-offs.",e929cc0e497b882cdd7021c233d1a8637cffbc14,True,False,,,,,0,1648044191,,0,{},i1snv35,False,t3_tkpt4c,False,True,t1_i1snnrl,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1snv35/,1648044207,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
364.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"I mainly mean to say that the main alternative to stack, namely cabal, will unfortunately probably not solve those performance issues either. I believe there is something you can do with nix and [cachix](https://www.cachix.org/), but that is pretty advanced.

Also, I think this is more of a fundamental issue for high-level programming languages. The compiler just simply has to do more work and therefore it takes longer. You can disable optimizations, but then running your programs will be slow. 

I think as a library writer you can do some things to speed up the compilation. For example, the `vector` library takes a long time to compile, because it uses a lot of type classes and abstraction layers. I think it can be made much faster if it was programmed in a more direct style. The similar `primitive` package is much faster to compile (also because it has less features, but I don't think that is the only reason).",02752fa4ffaecaa6f185590b3b8de5c590c05ae8,True,False,,,,,0,1648044106,,0,{},i1snnrl,False,t3_tkpt4c,False,True,t1_i1slikh,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1snnrl/,1648044118,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
365.0,[],False,,Bob-The-One,,,[],,,,text,t2_40ytr8v2,False,False,I've heard it has its own issues. Is it any faster at least?,da506b8d0723c386bb7bb07e88fcec798419a821,True,False,,,,,0,1648043889,,0,{},i1sn5fc,False,t3_tkpt4c,False,False,t1_i1smjif,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1sn5fc/,1648043905,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
366.0,[],False,,tom-md,,,[],,,,text,t2_7b2si,False,False,It is maintained,8317588eb70e945fad4f983f49bd8aed0cc51aa6,True,False,,,,,0,1648043758,,0,{},i1smuis,False,t3_t3zw0x,False,True,t1_i1rqjlq,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1smuis/,1648043773,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
367.0,[],False,,sunnyata,,,[],,,,text,t2_4lxh3lrv,False,False,"&gt; Stack (which is what I'm apparently supposed to be using)

You don't have to, just use cabal instead.",3fa4ae55babebc290d30b0b5368b0b3193894ede,True,False,,,,,0,1648043628,,0,{},i1smjif,False,t3_tkpt4c,False,True,t1_i1s7rz2,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1smjif/,1648043641,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
368.0,[],False,,Bob-The-One,,,[],,,,text,t2_40ytr8v2,False,False,"I have issues with stack as well, I've seen it work by itself, on things other than the compilation. If you want, i could take another look and describe my issues more in-depth, but to be fair i will complain about tools that are even a bit slower than very fast, so this may not be an issue for most.",0a7583ac5964da958522df3970a0a80ec3eb90dc,True,False,,,,,0,1648043192,,0,{},i1slikh,False,t3_tkpt4c,False,True,t1_i1shwsk,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1slikh/,1648043205,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
369.0,[],False,,Competitive_Ad2539,,,[],,,,text,t2_8g6liftg,False,False,It doesn't get any faster than instant 🤷‍♂️,94aa9c709dd1514a91ec78a1644d8887f088bec8,True,False,,,,,0,1648041872,,0,{},i1sij4o,False,t3_tkpt4c,False,True,t1_i1shr3v,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1sij4o/,1648041883,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
370.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,It's not stack that is slow but GHC in general. Do note that it is usually only slow on the first run when you also need to build all dependencies. After the first run the built dependencies are cached.,a6368501b34691beac763c76db421d0918f80ca5,True,False,,,,,0,1648041590,,0,{},i1shwsk,False,t3_tkpt4c,False,True,t1_i1s7rz2,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1shwsk/,1648041601,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
371.0,[],False,,Bob-The-One,,,[],,,,text,t2_40ytr8v2,False,False,Yes but that doesn't make stack any faster \:),859521b4e1ee1b8ec3bf1ccc86c4d9aaba4fc917,True,False,,,,,0,1648041516,,0,{},i1shr3v,False,t3_tkpt4c,False,True,t1_i1shlen,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1shr3v/,1648041529,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
372.0,[],False,,Competitive_Ad2539,,,[],,,,text,t2_8g6liftg,False,False,"In Stack you just add package name into the ""package.yaml"" file and you're done",e66a120d3ad0f50b7ab144bbb8db78276ec456b0,True,False,,,,,0,1648041443,,0,{},i1shlen,False,t3_tkpt4c,False,True,t1_i1sfwoo,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1shlen/,1648041459,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
373.0,[],False,,Philoustic,,,[],,,,text,t2_92rllbcy,False,False,"Hello,  
Great work :-)  
Just a question.

That you find a path for the Knight, I've no doubt about...  
But how can you say that it is the *shortest* one ?",511ac66d569ac82b8b0a46344f1a3c20a2850de5,True,False,,,,,0,1648041244,,0,{},i1sh69l,False,t3_tkpt4c,False,True,t3_tkpt4c,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1sh69l/,1648041261,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
374.0,[],False,,ocharles,,,[],,,,text,t2_9ojk6,False,False,"Thanks, now I better understand the problem. Let me try and put together something standalone and see if I can reproduce this and get back to you.",b13f07f76de20c1ca635437e19a48c7dbbc02cf2,True,False,,,,,0,1648040992,,0,{},i1sgmwn,False,t3_tk1khp,False,False,t1_i1s6zz5,/r/haskell/comments/tk1khp/reactivebanana_controlling_behavior_caching/i1sgmwn/,1648041004,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
375.0,[],False,,Bob-The-One,,,[],,,,text,t2_40ytr8v2,False,False,"Oh, i have no idea. I am interested in something like this, but i haven't stopped using stack (yet). I tried making a shell script to build but it got a bit annoying as i haven't figured out how to change the location of the object files, so i just didn't.

When I'm writing C i can usually write a little script to build whatever dependency i need, but i don't know how to do that with Haskell.",295431bde3b14f060455f5aac9ab0d64ba3dfd00,True,False,,,,,0,1648040640,,0,{},i1sfwoo,False,t3_tkpt4c,False,True,t1_i1sfktl,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1sfwoo/,1648040655,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
376.0,[],False,,Competitive_Ad2539,,,[],,,,text,t2_8g6liftg,False,False,"Let's say for the sake of giving an example, I want to import [this](https://hackage.haskell.org/package/lens) into my project. How do I do that without stack? I'm used to how easy and quick it is to do in stack, I'm not being sarcastic here.",7910632c52d78b5f4b1de353660b312223dfe03e,True,False,,,,,0,1648040481,,0,{},i1sfktl,False,t3_tkpt4c,False,True,t1_i1sdcey,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1sfktl/,1648040501,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
377.0,[],False,,Competitive_Ad2539,,,[],,,,text,t2_8g6liftg,False,False,"    HLS   1.6.1.0         latest,recommended 
    GHC   9.0.2           base-4.15.1.0                 hls-powered",7ab594eccc1d0d1c3a610bf64fa9ca1b825fbace,True,False,,,,,0,1648039454,,0,{},i1sdij6,False,t3_tkpt4c,False,True,t1_i1s223p,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1sdij6/,1648039469,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
378.0,[],False,,Competitive_Ad2539,,,[],,,,text,t2_8g6liftg,False,False,"I would recommend getting acquainted with [Stack](https://docs.haskellstack.org/en/stable/README/) for easy package installations, testing and building.",1c2839fbc01adeadf8366da636c96a823bd57813,True,False,,,,,0,1648039372,,0,{},i1sdcv2,False,t3_tkpt4c,False,True,t1_i1s17vd,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1sdcv2/,1648039383,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
379.0,[],False,,Bob-The-One,,,[],,,,text,t2_40ytr8v2,False,False,What do you mean?,c0ce14ad7f8d6951d59a3cdd7db2e3e97e45f14e,True,False,,,,,0,1648039365,,0,{},i1sdcey,False,t3_tkpt4c,False,False,t1_i1sd8wx,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1sdcey/,1648039376,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
380.0,[],False,,Competitive_Ad2539,,,[],,,,text,t2_8g6liftg,False,False,How do you install packages then?,faef84c1f257b5fa8325421d6f88dcf031ea6a0f,True,False,,,,,0,1648039313,,0,{},i1sd8wx,False,t3_tkpt4c,False,True,t1_i1s7rz2,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1sd8wx/,1648039325,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
381.0,[],False,,Bob-The-One,,,[],,,,text,t2_40ytr8v2,False,False,"I'll throw my two cents in here's since I'm not particularly used to Haskell tooling.

Stack (which is what I'm apparently supposed to be using) is _slow_. It's so slow it somehow out-slows C++ tooling. It's really annoying. Not sure what can be done about this though.

I don't really use language servers anymore, but the first time i tried Haskell i used vscode, and installing the extension and getting completion was a piece of cake.

The repl is awesome, i really enjoy using it (it's so nice that i got used to just opening a repl and loading random modules to test them out, which i never do with any other languages. It feels 'right' in ghc).

That's about it. Overall, a very good experience. Was very disappointed with the speed of stack.",d1df7c98a9be57768ae5382a146b86f662e8c103,True,False,,,,,0,1648036259,,0,{},i1s7rz2,False,t3_tkpt4c,False,False,t1_i1s0x45,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1s7rz2/,1648036274,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
382.0,[],False,,gilgamec,,,[],,,,text,t2_10h5agrx,False,False,"I've simplified it down to show much the same behaviour. Rather than building an entire mesh, it samples noise functions to generate one of two color maps. (The biggest difference is that changing the display parameters, `colorRangeSlider` in this case, also triggers a regeneration of the color maps.)

    -- Build a sphere by subdividing an icosahedron
    divSlider &lt;- mkSlider ""subdivisions"" initIcosDivs (0,5)
    let divLevel = _sliderValue divSlider
        mesh = icoSphere &lt;$&gt; divLevel

    -- Update the mesh in OpenGL when it changes
    let updateSphere m = doOnce $
          (updateMeshGL m &lt;$&gt; readIORef meshGLRef) &gt;&gt;= id &gt;&gt;= atomicWriteIORef meshGLRef
    changes (updateSphere &lt;$&gt; mesh) &gt;&gt;= reactimate'

    -- Build two fields of Floats on the mesh's surface
    let mkField1 vs = Debug.Trace.trace ""sampling field 1"" $ noise1 &lt;$&gt; vs
        mkField2 vs = Debug.Trace.trace ""sampling field 2"" $ noise2 &lt;$&gt; vs

        field1 = mkField1 . tmVertices &lt;$&gt; mesh :: Behavior (V.Vector Float)
        field2 = mkField2 . tmVertices &lt;$&gt; mesh :: Behavior (V.Vector Float)

    -- Checkbox chooses which field is displayed
    displayCheckbox &lt;- mkCheckbox ""field 1/2"" False
    dispField &lt;- switchB field1 $ _checkboxChanged displayCheckbox &lt;&amp;&gt;
                                  \b -&gt; if b then field2 else field1

    -- Choose the color range to be displayed
    colorRangeSlider &lt;- mkSlider ""range"" (1 :: Float) (0,2)
    -- Turn the scalar values of the chosen field into colors
    let colorMap = _sliderValue colorRangeSlider &lt;&amp;&gt; \c -&gt; jet (-c,c)
        colorField = fmap &lt;$&gt; colorMap &lt;*&gt; dispField :: Behavior (V.Vector Color)

    -- Update the displayed colors in OpenGL
    let updateColors = colorField &lt;&amp;&gt; \colors -&gt; doOnce $
          updateColorsGL colorVBO colors
    changes updateColors &gt;&gt;= reactimate'

    -- Show network changes
    meshChanges &lt;- changes mesh
    reactimate' $ pure (putStrLn ""mesh changed"") &lt;$ meshChanges
    field1Changes &lt;- changes field1
    reactimate' $ pure (putStrLn ""field1 changed"") &lt;$ field1Changes
    field2Changes &lt;- changes field2
    reactimate' $ pure (putStrLn ""field2 changed"") &lt;$ field2Changes
    dispFieldChanges &lt;- changes dispField
    reactimate' $ pure (putStrLn ""dispField changed"") &lt;$ dispFieldChanges
    colorFieldChanges &lt;- changes colorField
    reactimate' $ pure (putStrLn ""colorField changed"") &lt;$ colorFieldChanges

(Since we have to execute OpenGL actions during the GUI thread, we use `doOnce` to write an action to an `IORef` which is executed during the main loop.)

Changing the mesh subdivision level causes everything to be regenerated, as expected:

    sampling field 1
    mesh changed
    field1 changed
    field2 changed
    dispField changed
    colorField changed

Clicking on the checkbox then changes to field 2, which is sampled:

    sampling field 2
    dispField changed
    colorField changed

But then clicking on the checkbox again changes the display back to field 1, which is resampled:

    sampling field 1
    dispField changed
    colorField changed

The appropriate field is sampled every time we change the display. If `dispField` is replaced with an applicative combination, i.e.

    let dispField = (\b t f -&gt; if b then t else f) &lt;$&gt; _checkboxValue displayCheckbox
                                                   &lt;*&gt; field1 &lt;*&gt; field2

then *both* fields are resampled whenever the checkbox changes, no matter which is being drawn.",8e11b4e45ce01eae58e12eaaea4d278355cb95a8,True,False,,,,,0,1648035791,,0,{},i1s6zz5,True,t3_tk1khp,False,True,t1_i1p8hbj,/r/haskell/comments/tk1khp/reactivebanana_controlling_behavior_caching/i1s6zz5/,1648035805,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
383.0,[],False,,DmitryTsepelev,,,[],,,,text,t2_21cqe56c,False,False,"I'll try to update to 9 as soon as my extension supports it and see where it goes—I do not need libraries yet, so should be a safe thing to do",4e7db9cab8ec0f1f6eb4125580647c0813191bec,True,False,,,,,0,1648032506,,0,{},i1s223p,True,t3_tkpt4c,False,True,t1_i1s1sb2,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1s223p/,1648032519,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
384.0,[],False,,maerwald,,,[],,,,text,t2_t8qgl,False,False,"I think ghc 9.2.2 is supposed to work better on M1 and has a native code generator (so doesn't require llvm). Since it's very new not all libraries might support it yet, though.

The extension you linked does use HLS (a language server for the LSP protocol), but doesn't currently support 9.2.2. The next version of the extension will support the option to install GHC automatically for you.",fdba295f6d62c6302fdaa8c0cd259a4c11e620ab,True,False,,,,,0,1648032305,,0,{},i1s1sb2,False,t3_tkpt4c,False,True,t1_i1s17vd,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1s1sb2/,1648032322,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
385.0,[],False,,DmitryTsepelev,,,[],,,,text,t2_21cqe56c,False,False,"Since I'm using Haskell not for production apps but for fun and learning only, my setup is very stupid:

\- ghc 8.10.7 (I didn't manage to set up a newer version and I suppose that will be tricky since I'm on M1)

\- I use VSCode with this plugin [https://marketplace.visualstudio.com/items?itemName=haskell.haskell](https://marketplace.visualstudio.com/items?itemName=haskell.haskell) for highlighting and suggestions

\- my projects are just .hs files 🙂

\- when I need to play with things (kinda interactive repl) I run \`\`ghci and that's enough for now",fe42462df062578d32f62f23ce781f115854ddca,True,False,,,,,0,1648031880,,0,{},i1s17vd,True,t3_tkpt4c,False,True,t1_i1s0x45,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1s17vd/,1648031895,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
386.0,[],False,,maerwald,,,[],,,,text,t2_t8qgl,False,False,"Somewhat unrelated, but we've been trying to figure out how haskell tooling appears to newcomers. Long time Haskellers tend to live in a bubble, because we know all the ins and outs of tooling. 

How was your experience with installation, editors (did you use HLS?), setting up a project, interactive repl and so on?",d1ea41f8a55f8770aab6624d0a6f2aabb6cc3f1d,True,False,,,,,0,1648031655,,0,{},i1s0x45,False,t3_tkpt4c,False,True,t3_tkpt4c,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1s0x45/,1648031665,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
387.0,[],False,,Competitive_Ad2539,,,[],,,,text,t2_8g6liftg,False,False,Looking forward to it,70ce80cd26658357e1d48560c3221d5363cd334f,True,False,,,,,0,1648030470,,0,{},i1rzdhd,False,t3_tkpt4c,False,True,t1_i1rz5ho,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1rzdhd/,1648030481,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
388.0,[],False,,DmitryTsepelev,,,[],,,,text,t2_21cqe56c,False,False,"Thanks for the reply! Yeah, I \_already\_ (hehe) know that we can use a List monad here. My goal for the post was only to impress people with cool code snippents so I decided to not add any additional concepts here.

I have a draft for another article which touches functors, applicative and monads 🙂",1947e4909e72de0413a8732911926250990ecbec,True,False,,,,,0,1648030295,,0,{},i1rz5ho,True,t3_tkpt4c,False,True,t1_i1rygnf,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1rz5ho/,1648030314,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
389.0,[],False,,Competitive_Ad2539,,,[],,,,text,t2_8g6liftg,False,False,Regarding your `generateMoves` function again: Hackage [says](https://hackage.haskell.org/package/base-4.16.0.0/docs/Prelude.html#v:foldl) you almost never want to use `foldl` instead of `foldr` because of performance reasons.,c8a5b8d181bb425c4d3c43fb64ce7bf2443da3da,True,False,,,,,0,1648030043,,0,{},i1ryu4z,False,t3_tkpt4c,False,True,t3_tkpt4c,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1ryu4z/,1648030054,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
390.0,[],False,,Competitive_Ad2539,,,[],,,,text,t2_8g6liftg,False,False,"I know you're exited to learn Haskell and this is great.  


I just w to say that your `shortestPath :: Position -&gt; Position -&gt; Int` implementation looks remarkably like the List monad.  


    shortestPath :: Position -&gt; Position -&gt; Int",3a4a703f2ce076d6ced7b61448a0ab648418b5fc,True,False,,,,,0,1648029751,,0,{},i1rygnf,False,t3_tkpt4c,False,True,t3_tkpt4c,/r/haskell/comments/tkpt4c/im_a_rubyist_and_try_to_learn_haskellheres_my/i1rygnf/,1648029765,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
391.0,[],False,,vaibhavsagar,,,[],,,,text,t2_44j1,False,False,"&gt; [...] or maybe some sort of Haskell Notebook style editor

You might be able to use [IHaskell](https://github.com/IHaskell/IHaskell) for this!",2b76065884b8eec417faccc82b5f016403519d56,True,False,,,,,0,1648025840,,0,{},i1rtw0m,False,t3_t7v64h,False,True,t3_t7v64h,/r/haskell/comments/t7v64h/haskell_for_xp_style_discussions/i1rtw0m/,1648025855,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
392.0,[],False,,enobayram,,,[],,,,text,t2_90u7a,False,False,"Yeah, I reach for generic-lens all the time, but I strongly advise you to keep `RecordWildCards` in mind too. It can be a really useful tool, especially when you design your data types keeping it in mind. For instance:

    data DBUser = User { billions of fields, id :: DatabaseKey }

    data SomePartOfTheUserType = SomePartOfTheUserType { half a billion fields }
    data MostOfTheRemainingFieldsOfTheUserType = { other half a billion fields minus one or two }

    toDBUser :: SomePartOfTheUserType -&gt; MostOfTheRemainingFieldsOfTheUserType -&gt; Int -&gt; String -&gt; DBUser
    toDBUser SomePartOfTheUserType{..} MostOfTheRemainingFieldsOfTheUserType{..} userId someDbSpecificField = User {someField = doSomeCustomization someField, ..}

    -- A witness to the fact that DBUser contains MembershipDetails
    dbUserHasMembership :: Lens' DBUser MembershipDetails
    dbUserHasMembership = lens get set where
      get DBUser{..} = MembershipDetails{..}
      set DBUser{..} = \MembershipDetails{..} -&gt; DBUser{..}

    -- A witness to the fact that User is a subtype of AccountHolder
    userIsAccountHolder :: Prism' AccountHolder User
    userIsAccountHolder = prism' sup sub where
      sup = ...
      sub = ...

So, combined with `lens`, `RecordWildCards` can be really useful for surgically describing relationships between types that are conceptually related but independently defined.",7ad5727b3357c8f40c3d37cdd03c20fbe6bdae1e,True,False,,,,,0,1648024369,,0,{},i1rs8gr,False,t3_t3zw0x,False,True,t1_i1rqa0k,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1rs8gr/,1648024379,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
393.0,[],False,,Venom_moneV,,,[],,,,text,t2_t80um,False,False,"Selda looks good and similar to what I need, but it seems like it's not maintained anymore? Anyways I'll try using it. Thanks.",861f1f037bcbe014a244589635d27b6f84f6b1eb,True,False,,,,,0,1648022874,,0,{},i1rqjlq,False,t3_t3zw0x,False,True,t1_i1p81jo,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1rqjlq/,1648022887,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
394.0,[],False,,Venom_moneV,,,[],,,,text,t2_t80um,False,False,"generic-lens seems really convenient for writing these functions,  Thanks for that.",660f6b041acdf3dc970af8c2d5c1cd90c61f3480,True,False,,,,,0,1648022642,,0,{},i1rqa0k,False,t3_t3zw0x,False,True,t1_i1r1gpt,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1rqa0k/,1648022654,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
395.0,[],False,,Tarmen,,,[],,,,text,t2_7mjdo,False,False,"I see property testing as a version of fuzzing. Most of the time for tiny, easy to check, properties.

But I have used quickcheck-state-machine before to test an entire website. Generators generate web request and track which db IDs are generated for future requests. Validators check against internal Server errors, that valid XHTML is produced, etc. 

So when there is an edge case like some user supplied Input which isn't supplied properly, or an unhanded error like some divide by zero, then these can be very efficiently found.",9b022d2ba3cb2fb0ae6d1ed1e47c0f6fbb292b38,True,False,,,,,0,1648017924,,0,{},i1rkqs0,False,t3_tjxh34,False,True,t3_tjxh34,/r/haskell/comments/tjxh34/property_testing_am_i_missing_something/i1rkqs0/,1648017939,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
396.0,[],False,,circleglyph,,,[],,,,text,t2_557783ba,False,False,"If you want a challenge, and really, really want to blow those imperative cobwebs away, rewrite your project following [https://chrispenner.ca/posts/adjunction-battleship](https://chrispenner.ca/posts/adjunction-battleship).

Thats FP301 but ...",ef8acadf4edbed0015db7f2d2202f2b678b7150d,True,False,,,,,0,1648012893,,0,{},i1re75w,False,t3_tjforr,False,False,t1_i1kocal,/r/haskell/comments/tjforr/writing_proper_haskell_code/i1re75w/,1648012907,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
397.0,[],False,,circleglyph,,,[],,,,text,t2_557783ba,False,False,"That's a really great refactor. I'm not sure what's actually going on with the above code, but those two branches look a bit similar and maybe there's a deep unification to be found. More random advice:

isFree outputs are all Rights, so the Rights can be floated up. These little refactorings add up.

I'd guess you could pop isFree and isValidSquare out of all the Possibs and turn all of them into list of moves generators. Something like: `moves :: Piece -&gt; [Square]` and then isFree, isValidSquare filterBlocked gets wrapped up in a  `valid :: Square -&gt; Bool`  so then all the possibs are `possib = filter valid . moves`",f75dfe2b229e817e3a6f75a07656775aadae543b,True,False,,,,,0,1648012409,,0,{},i1rdhvr,False,t3_tjforr,False,True,t1_i1qgfwt,/r/haskell/comments/tjforr/writing_proper_haskell_code/i1rdhvr/,1648012424,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
398.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"&gt; I've just never connected to SQL from Haskell

MariaDB and PostgreSQL are fairly easy, as are things that are accessible via AWS or GCS APIs.

MS SQL and other T-SQL DBs are less well supported, or at least I'm not aware of a great library for them.",241d173cd219183d2ebd1c6563a22776dc551ef5,True,False,,,,,0,1648006838,,0,{},i1r4bb1,False,t3_t3zw0x,False,True,t1_i1qqtcq,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1r4bb1/,1648006850,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
399.0,[],False,,enobayram,,,[],,,,text,t2_90u7a,False,False,"Yeah, that's the way to go if you decide to use persistent, the library definitely was designed to be used that way. You could in theory adapt an existing type by manually writing some instances that are generated by the template Haskell utilities of persistent, but that'll be much harder than just writing conversion functions.

BTW you can reduce the boilerplate while writing the conversion functions using extensions like RecordWildcards (in a principled manner) or libraries like generic-lens. In general, lens is a great way to model relationships between types.",db95339228a19c37e175540fc087a22572833e6f,True,False,,,,,0,1648005320,,0,{},i1r1gpt,False,t3_t3zw0x,False,True,t1_i1oonmn,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1r1gpt/,1648005333,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
400.0,[],False,,SolaTotaScriptura,,,[],,,,text,t2_5dpnr08,False,False,"Sometimes I mix both approaches. I call it ""digging a tunnel from both ends"". You write high-level functions that *are called* but *don't work* and low-level functions which *work* but *aren't called*. For example:

    root = parent2 . parent1

    -- ... TODO ...

    child = (+ 1)

`root` would work if `parent1` and `parent2` existed.

`child` works, but is unused.",9a7a52873eb95e63862c03a118d055cc4b6d19b3,True,False,,,,,0,1648004721,,0,{},i1r0b5v,False,t3_tjl2sg,False,True,t1_i1nn39w,/r/haskell/comments/tjl2sg/what_does_your_workflow_look_like/i1r0b5v/,1648004735,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
401.0,[],False,,enobayram,,,[],,,,text,t2_90u7a,False,False,"I think the answer really depends on your domain (i.e. what it is that your codebase is doing), which direction you're planning to expand, what benefits you expect from Haskell and what scares you the most about it. 

Maybe you want to incorporate a DSL to your system, then you could simply write its compiler in Haskell and call it as a subprocess, or maybe let it serve itself.

Or maybe there are some very tricky concepts in your domain you want to model with the backing of a powerful type system and purity. In that case you could run Haskell code as a microservice, let it talk to the DB and expose an HTTP API, or respond to some queue.

If you need to talk to T-SQL I can recommend HDBC-odbc. Roughly a year ago, we found ourselves with a strategic need to talk to a number of DB engines like SQL Server and Snowflake and HDBC-odbc seemed work well enough. There's also the ODBC package, but we couldn't use it because seems like it tries to speak ODBC just as much as it needs in order to talk to SQL Server, which was not enough for us. HDBC-odbc has some rough edges too, but we've been making improvements and we're planning to upstream them soon.

With all that said about ODBC, there's no denying that ODBC isn't Haskell's strong side. The ecosystem you'll find there will be nothing compared to Postgres. Haskell+Postgres is a first-class experience, probably Haskell+SQLite too, but be ready to maintain some of the infrastructure yourself if you go Haskell+ODBC.

On the API side, you have a wide range of good options to choose from, so you should be good there.",2d5fc565063f9d3611180ffd432f7c46a2730995,True,False,,,,,0,1648004625,,0,{},i1r04gg,False,t3_t3zw0x,False,True,t1_i1qiele,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1r04gg/,1648004636,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
402.0,[],False,,ulysses4ever,,,[],,,,text,t2_68b11,False,False,Thank you! After your comment I got there and saw that it was indeed updated.,6150385810a458ac45d9c8978a6dd93b576339a2,True,False,,,,,0,1648000549,,0,{},i1qro3e,False,t3_tj0496,False,True,t1_i1qj4w7,/r/haskell/comments/tj0496/stack_lts_19_release_and_nightly_on_ghc92/i1qro3e/,1648000568,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
403.0,[],False,,makeitabyss,,,[],,,,text,t2_x6p2k,False,False,"Yeah honestly I'm more inclined to work with the backend. It's easier for me to imagine how to re-write code from a data perspective rather than a state perspective. 

I've just never connected to SQL from Haskell, so that will be a learning experience. I've only consumed JSON or flat files up to now in Haskell",eed5025eb85792ea2bfa1c447fce87c785eaf137,True,False,,,,,0,1648000159,,0,{},i1qqtcq,False,t3_t3zw0x,False,True,t1_i1qnk37,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1qqtcq/,1648000176,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
404.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"First you'd have to figure out a good way for Haskell to talk to T-SQL.  Maybe you can use ODBC?  After that, you can start swapping out parts of the backend.

In my very limited experience, GHCJS isn't ready for production.  But, you could get something very Haskell-like by using PureScript instead of JS in the front end.  If you want to work from that end simultaneously from beforehand.",e61c113e6e194ac7df078e480ebc2ffc144b7a97,True,False,,,,,0,1647998687,,0,{},i1qnk37,False,t3_t3zw0x,False,True,t1_i1qiele,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1qnk37/,1647998704,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
405.0,[],False,,DietOk3559,,,[],,,,text,t2_a2pe4ib3,False,False,"There are also literally exercises interspersed throughout every single chapter of that book, so I'm not sure why OP said that",6de8391e38de9d313dce3c0e22f61c9d36ce8aac,True,False,,,,,0,1647998361,,0,{},i1qmuks,False,t3_tjsna2,False,True,t1_i1nsute,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1qmuks/,1647998374,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
406.0,[],False,,DietOk3559,,,[],,,,text,t2_a2pe4ib3,False,False,"Agreed. As far as videos go, they're some of the best available. Hutton isn't my favorite teacher but nobody has as much experience teaching Haskell as him and he's really good at it. Video instruction should absolutely be accompanied by a textbook and exercises though, or it's not worth much. Either Haskell Programming from First Principles or Hutton's book. Different books appeal to different people - First Principles may be denser than some are comfortable with and it's definitely not a perfect book - but if someone doesn't have the patience to read *any* textbook they probably don't have the patience required to learn Haskell. It's too conceptually heavy and different from other languages to pick it up without actually studying, the way one can with say Python or Javascript (no offense meant here, I program in both)",563f4d1a9c11c714cb320885307f71f7133a827d,True,False,,,,,0,1647998260,,0,{},i1qmmbo,False,t3_tjsna2,False,True,t1_i1pe89w,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1qmmbo/,1647998277,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
407.0,[],False,,man-vs-spider,,,[],,,,text,t2_5by84,False,False,"Haha, maybe, 

honestly I’m just playing around with the FFI features,

The specific thing I’m trying is running an integrator (Euler or Runge-Kutta), where the function, f, is passed from Haskell to C where C does the integration.

The function f(t,y), takes t (1d, time) and y (n-dim) and gives and n-dim result. In Haskell I’m just using lists for the n-dim results, but that needs to be translated for C",4b4c623922147da1366f584f28b73a38ee70f790,True,False,,,,,0,1647998191,,0,{},i1qmglf,True,t3_tk6kxo,False,True,t1_i1qhgbb,/r/haskell/comments/tk6kxo/can_the_haskell_ffi_pass_functions_on_lists_to_c/i1qmglf/,1647998209,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
408.0,[],False,,DietOk3559,,,[],,,,text,t2_a2pe4ib3,False,False,"Can either of you provide a reason why you think this? The series I mentioned was good for me as a beginner. It wasn't the first or the only resource I relied on by any means but I watched it from start to finish within my first couple months of learning Haskell and found all of it easy to follow and very helpful at the time. Again I'm not referring to his blog/book or any of his series on Category Theory, just the Haskell one",453d7c1dae71f50ba6c9649a0579d26a7f8a38a9,True,False,,,,,0,1647997266,,0,{},i1qkf7p,False,t3_tjsna2,False,True,t1_i1ntaqx,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1qkf7p/,1647997278,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
409.0,[],False,,Endicy,,,[],,,,text,t2_mz4isnd,False,False,"It picked up on my version bump automatically, and seeing as other automation of stackage also picks up on revisions, I'd wager it'll automatically remove the &lt; 0 after a revision :)",f39476ac382ba5c615152b74eb1a007704dd9ee4,True,False,,,,,0,1647996683,,0,{},i1qj4w7,False,t3_tj0496,False,True,t1_i1iq1mr,/r/haskell/comments/tj0496/stack_lts_19_release_and_nightly_on_ghc92/i1qj4w7/,1647996701,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
410.0,[],False,,makeitabyss,,,[],,,,text,t2_x6p2k,False,False,"
Given I have some large code base (front end is JavaScript. Backend is C#. Database is T-SQL.)
Compromised of websites, webAPIs, and services. 

I want to slowly integrate Haskell into the work flow. 

**Where do you see Haskell being able to fit into this ecosystem? In your opinion. **

I've messed around with F#. And it's great! It connects straight into the dotnet ecosystem easily. However, as you can assume that comes with its own set of weird compromises, that are not always desirable.",76305348ecaf2d79ae029dc0edc16da0f264fe90,True,False,,,,,0,1647996350,,0,{},i1qiele,False,t3_t3zw0x,False,True,t3_t3zw0x,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1qiele/,1647996362,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
411.0,[],False,,dun-ado,,,[],,,,text,t2_ihltqlra,False,False,"May I ask what you’re trying to do. To me, what you’re trying to do negates most of the reasons to use Haskell.",454910f9ad88a6bbdbdc87e4f92eaa1290273127,True,False,,,,,0,1647995921,,0,{},i1qhgbb,False,t3_tk6kxo,False,True,t3_tk6kxo,/r/haskell/comments/tk6kxo/can_the_haskell_ffi_pass_functions_on_lists_to_c/i1qhgbb/,1647995938,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
412.0,[],False,,Endicy,,,[],,,,text,t2_mz4isnd,False,False,"I would even go one step further:

    apm b c (x, y)
      | isPawnStart = takeWhile checker [(x, y .+ 1), (x, y .+ 2)]
      | otherwise = filter checker [(x, y .+ 1)]
     where
      -- Basically the ""move forward"" operator
      (.+) = if c == Black then (+) else (-)
      isPawnStart = 
        case (c, y) of
          (Black, 1) -&gt; True
          (White, 6) -&gt; True
          _ -&gt; False",06b6f6b1d67445b1396a5a3d80e7f032f94b1602,True,False,,,,,0,1647995467,,0,{},i1qgfwt,False,t3_tjforr,False,True,t1_i1l838j,/r/haskell/comments/tjforr/writing_proper_haskell_code/i1qgfwt/,1647995479,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
413.0,[],False,,bedobi,,,[],,,,text,t2_k155g,False,False,"Really appreciate the replies, super helpful and understanding, great example of why I love the Haskell sub over so many other programming subs",51b6286f616efa04981ddf93dcd937fdbf4aaf12,True,False,,,,,0,1647989202,,0,{},i1q235i,True,t3_tjxh34,False,True,t1_i1pxope,/r/haskell/comments/tjxh34/property_testing_am_i_missing_something/i1q235i/,1647989219,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
414.0,[],False,,valcron1000,,,[],,,,text,t2_hw1ys,False,False,"It's just another tool, and besides knowing what it is you should know \*\*when\*\* to use it. For some use cases, it's a bit overkill, but sometimes its a very good tool. Maybe for your use case writing the email generator is just no worth it. Formal proofs also exist and you could apply them in a lot of situations, but most of the times you don't need that kind of verification. This is the ""engineering"" side of programming: knowing tradeoffs and picking those that fit your situation best.",d630738bf0566473b959f09001a6cdf518a22c6a,True,False,,,,,0,1647987372,,0,{},i1pxope,False,t3_tjxh34,False,False,t1_i1phwwq,/r/haskell/comments/tjxh34/property_testing_am_i_missing_something/i1pxope/,1647987395,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
415.0,[],False,,affinehyperplane,,,[],,,,text,t2_12xogr,False,False,You might also want to mention that `FunPtr`s created this way have to be freed with [`freeHaskellFunPtr`](https://hackage.haskell.org/package/base-4.16.0.0/docs/Foreign-Ptr.html#v:freeHaskellFunPtr) to prevent memory leaks.,c515ab2c1e18ae2dbfcdb325a2d82c814f34022e,True,False,,,,,0,1647985860,,0,{},i1ptyao,False,t3_tk6kxo,False,True,t1_i1omvzu,/r/haskell/comments/tk6kxo/can_the_haskell_ffi_pass_functions_on_lists_to_c/i1ptyao/,1647985877,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
416.0,[],False,,bedobi,,,[],,,,text,t2_k155g,False,False,"&gt;The ""problem"" here is that your test is only covering the ""test@email.com""

&gt;With property based testing, you can clearly state that **for any email** you get this behavior, and you can remove the hardcoded test email (what does ""test@email.com"" even mean? is it relevant for this test case? of course not!)

I happily admit that the test we already have is technically low confidence because it only tests a single email, but tbh part of me things this is just semantics and that a simple traditional naive test which does prove the property at least for a single email is more than enough.

Like yes we could write an email generator that respects our regex, creating millions of users with those emails and ensures for each of them a user with the same email cannot be created but on balance, I don't think the latter is worth the effort nor necessary for our use case here.

Please note this is not a dig at property testing and I'm not saying it's stupid or that it sucks. I think it's great, I can see how vital it is for many use cases, I'm simply saying I personally can't justify introducing it for my particular use case at hand.",0f056a59db1791cb6dc47978833ccda77788c638,True,False,,,,,0,1647981087,,0,{},i1phwwq,True,t3_tjxh34,False,True,t1_i1nmgzg,/r/haskell/comments/tjxh34/property_testing_am_i_missing_something/i1phwwq/,1647981103,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
417.0,[],False,,GudLincler,,,[],,,,text,t2_fgzkg21,False,False,"I don't find videos a quick way to learn, but [these](https://youtube.com/c/GrahamHuttonNotts) from professor Graham Hutton are pretty good.",0395da8a16444ba94ad3c385b6952126a3f5f5a3,True,False,,,,,0,1647979649,,0,{},i1pe89w,False,t3_tjsna2,False,True,t3_tjsna2,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1pe89w/,1647979667,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
418.0,[],False,,ocharles,,,[],,,,text,t2_9ojk6,False,False,I don't think I can really debug this without seeing some code. Are you able to share anything?,5b410353b8d43fa22ce90ffa239bc16e9376bd26,True,False,,,,,0,1647977435,,0,{},i1p8hbj,False,t3_tk1khp,False,True,t3_tk1khp,/r/haskell/comments/tk1khp/reactivebanana_controlling_behavior_caching/i1p8hbj/,1647977454,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
419.0,[],False,,tom-md,,,[],,,,text,t2_7b2si,False,False,I have a strong preference for either lots of type safety or quick and dirty.  On one end there's Selda. On the other there's postgresql-simple.,e083c06f0d5f1adfedd90f19178af4d784609fd7,True,False,,,,,0,1647977264,,0,{},i1p81jo,False,t3_t3zw0x,False,True,t1_i1n9s1j,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1p81jo/,1647977280,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
420.0,[],False,,ludvikgalois,,,[],,,,text,t2_dul9o,False,False,"If the data comes from Haskell, and is only ever going to be operated on by Haskell functions, you can use `StablePtr`s and pass function pointers into C which operate on `StablePtr`s (if you can include the HsFFI header) or function pointers which take regular `Ptr`s (but requires you to cast them either side). This is probably only of use if you're doing something like writing a UI in a non-Haskell language but have the ""business logic"" in Haskell.",85eb3983114436d1c2080c05ead76a3e6ea562ff,True,False,,,,,0,1647976158,,0,{},i1p56yl,False,t3_tk6kxo,False,False,t1_i1ooego,/r/haskell/comments/tk6kxo/can_the_haskell_ffi_pass_functions_on_lists_to_c/i1p56yl/,1647976174,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
421.0,[],False,,PASC7L,,,[],,,,text,t2_d1rzr16x,False,False,"Awesome. Thanks, I guess I’ll have to get a copy and learn me some of that there Haskell",199ede31aa47afe3eb984e8a65275846844dee27,True,False,,,,,0,1647973938,,0,{},i1ozi3x,False,t3_tjsna2,False,True,t1_i1mcrab,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1ozi3x/,1647973954,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
422.0,[],False,,Iceland_jack,,,[],,,,text,t2_3qjdu,False,False,The documentation can add reference implementations that have simpler definitions (`and = foldr (&amp;&amp;) True`) without changing the code.,84d6049d6c43581e292acd849dbbf552d87961a0,True,False,,,,,0,1647970204,,0,{},i1oprzu,False,t3_tjqw7a,False,True,t1_i1ol3gx,/r/haskell/comments/tjqw7a/seeking_community_feedback_on_datalist/i1oprzu/,1647970220,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
423.0,[],False,,Venom_moneV,,,[],,,,text,t2_t80um,False,False,"Yeah, Not the best solution. I guess need to have two different types and write conversion functions between them. Thanks again!",78d8b9c00ea3d301a9b498671fe2aa667a52a139,True,False,,,,,0,1647969777,,0,{},i1oonmn,False,t3_t3zw0x,False,False,t1_i1om8fl,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1oonmn/,1647969792,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
424.0,[],False,,man-vs-spider,,,[],,,,text,t2_5by84,False,False,"Thanks for the answer, what you posted with the ptr instead of Haskell lists/vector is kinda what I expected",ae77c55fc673ee8ab9f99f9296d8add42f645938,True,False,,,,,0,1647969680,,0,{},i1ooego,True,t3_tk6kxo,False,True,t1_i1omvzu,/r/haskell/comments/tk6kxo/can_the_haskell_ffi_pass_functions_on_lists_to_c/i1ooego/,1647969694,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
425.0,[],False,,ludvikgalois,,,[],,,,text,t2_dul9o,False,False,In retrospect `copyArray` from `Foreign.Marshal.Array` woul have been a better choice than `copyBytes` because you can skip the `* sizeOf` part,b27fc2e67155ba6d0ea0cd409be1f55f38b71aab,True,False,,,,,0,1647969358,,0,{},i1onjuj,False,t3_tk6kxo,False,True,t1_i1omvzu,/r/haskell/comments/tk6kxo/can_the_haskell_ffi_pass_functions_on_lists_to_c/i1onjuj/,1647969375,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
426.0,[],False,,ludvikgalois,,,[],,,,text,t2_dul9o,False,False,"The easiest way to answer such a question is to try.
    • Unacceptable argument type in foreign declaration:
        ‘SV.Vector CDouble’ cannot be marshalled in a foreign call
    • When checking declaration:
        foreign import ccall safe ""wrapper"" foo
          :: (SV.Vector CDouble -&gt; SV.Vector CDouble)
             -&gt; IO (FunPtr (SV.Vector CDouble -&gt; SV.Vector CDouble))

If you want a function that operate over an array of `CDouble`, you'll probably need to write a function of type `Ptr CDouble -&gt; CInt -&gt; IO ()` (where the `CInt` is the size of the array) if you want to mutate the original C array or `Ptr CDouble -&gt; CInt -&gt; IO (Ptr CDouble)` if you want to make a new one (assuming you malloc it on the Haskell side).

If you're happy with a moderate amount of copying into Haskell land, doing your operation and then mutation the C array you could do something like (warning, untested)

    import Foreign.Ptr
    import Foreign.C
    import Foreign.Storable
    import Foreign.Marshal (copyBytes)
    import qualified Data.Vector.Storable as SV

    foreign import ccall ""wrapper""
      withArray :: (Ptr CDouble -&gt; CInt -&gt; IO ()) -&gt; IO (FunPtr (Ptr CDouble -&gt; CInt -&gt; IO ()))

    wrapMyFunc :: IO (FunPtr (Ptr CDouble -&gt; CInt -&gt; IO ()))
    wrapMyFunc = withArray $ \ptr len' -&gt; do
      let len = fromIntegral len' -- CInt -&gt; Int
      vec &lt;- SV.generateM len (peekElemOff ptr)
      SV.unsafeWith vec (\vecPtr -&gt; copyBytes ptr vecPtr (len * sizeOf (0 :: CDouble)))

    myFunc :: SV.Vector CDouble -&gt; SV.Vector CDouble
    myFunc = &lt;...&gt;",51de807aa7a70e374dd51c0a5fa28f5e7f27842b,True,False,,,,,0,1647969107,,0,{},i1omvzu,False,t3_tk6kxo,False,True,t3_tk6kxo,/r/haskell/comments/tk6kxo/can_the_haskell_ffi_pass_functions_on_lists_to_c/i1omvzu/,1647969119,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
427.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"See [this stackoverflow answer](https://stackoverflow.com/a/28690597/15207568):

&gt; From: http://www.yesodweb.com/book/persistent
&gt;
&gt;     {-# LANGUAGE TemplateHaskell #-}
&gt;     module Employment where
&gt;     
&gt;     import Database.Persist.TH
&gt;     
&gt;     data Employment = Employed | Unemployed | Retired
&gt;         deriving (Show, Read, Eq)
&gt;     derivePersistField ""Employment""
&gt;
&gt; The derivePersistField function is the template Haskell magic that makes it work.
&gt;
&gt; Note, you need to do the derivePersistField thing in a separate file to where you do the mkPersist to avoid a TH phase error.",441f9c089e8e6f47017e5b72fe1f3e8000817d53,True,False,,,,,0,1647968858,,0,{},i1om8fl,False,t3_t3zw0x,False,True,t1_i1ohjg5,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1om8fl/,1647968869,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
428.0,[],False,,nxnt,,,[],,,,text,t2_we1z6qx,False,False,Have you taken a look at [Foreign.Marshal.Array](https://hackage.haskell.org/package/base-4.16.0.0/docs/Foreign-Marshal-Array.html)?,75ecc22571d585f4431cbcb41ad814376c2040ee,True,False,,,,,0,1647968728,,0,{},i1olw15,False,t3_tk6kxo,False,True,t3_tk6kxo,/r/haskell/comments/tk6kxo/can_the_haskell_ffi_pass_functions_on_lists_to_c/i1olw15/,1647968747,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
429.0,[],False,,Athas,,,[],,,,text,t2_1rew,False,False,"&gt; Yeah, and having a standard library implementation optimized for beginner readability would be a monumental achievement that I don’t think any major language implementation pursues.

When I got started with Haskell, reading the definition of Prelude was recommended as a way to see some interesting programming techniques for solving simple problems.  I recall that the Prelude code was quite readable.  This is not the case anymore - I think the modern GHC prelude just imports and reexports various parts of base.  This does not mean that things were better in the old days (they were not), but there was indeed a time where Haskell's Prelude served sort of as a standard library, and either by design or accident managed to be readable for beginners.",cf0f6c2dece2b96d14074a0abf8cdc3c0d20ee59,True,False,,,,,0,1647968425,,0,{},i1ol3gx,False,t3_tjqw7a,False,True,t1_i1ngysh,/r/haskell/comments/tjqw7a/seeking_community_feedback_on_datalist/i1ol3gx/,1647968443,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
430.0,[],False,,Venom_moneV,,,[],,,,text,t2_t80um,False,False,"Any idea how persistent works with existing data types? The examples I checked created new types with Template haskell. I would much rather reuse my existing types, Thanks.",860edb859b4cc07df7ea1242c25d0baa1b591f3e,True,False,,,,,0,1647967076,,0,{},i1ohjg5,False,t3_t3zw0x,False,True,t1_i1o7elu,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1ohjg5/,1647967091,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
431.0,[],False,,rainbyte,,,[],,,,text,t2_hh844,False,False,"Shameless plug here... Sometime ago I have made [a post with an introduction to Haskell](https://rainbyte.net.ar/posts/200828-01-haskell-0-to-io.html), it doesn't go so deep but maybe it could help you to review the basic concepts",e3ba91eb1033e9a2029b5d9323e289ab664e87c1,True,False,,,,,0,1647966192,,0,{},i1of7rj,False,t3_tjsna2,False,False,t3_tjsna2,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1of7rj/,1647966209,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
432.0,[],False,,monnef,,,[],,,,text,t2_c7cq0,False,False,"Thank you for the link. I wrote 3k LoC project in Haskell with only mildly advanced stuff like lens and transformers, but after watching the first video, I learned how big gaps I have in the basics.",b101bf12bb8307147844836478354f6271b6cfdd,True,False,,,,,0,1647964542,,0,{},i1oay34,False,t3_tjforr,False,True,t1_i1l20vh,/r/haskell/comments/tjforr/writing_proper_haskell_code/i1oay34/,1647964556,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
433.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,I think [persistent](https://hackage.haskell.org/package/persistent) is the most popular package for that.,513a5bb92c8c10403d34121c8eff9567e8428390,True,False,,,,,0,1647963144,,0,{},i1o7elu,False,t3_t3zw0x,False,True,t1_i1n9s1j,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1o7elu/,1647963155,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
434.0,[],False,,pwmosquito,,,[],,,,text,t2_5bsnc,False,False,"My 2c: in these cases an arguably quick and easy win would be to add a comment with the ideal, non-productionised implementation or in this specific case a link to `GHC.List`? This would take care of beginner confusion by pointing them to something more understandable. Maybe as part of the HF documentation project?",1abee8d5779ba872248d3a84300a396ba519e9af,True,False,,,,,0,1647960517,,0,{},i1o0uuq,False,t3_tjqw7a,False,True,t1_i1nnc4o,/r/haskell/comments/tjqw7a/seeking_community_feedback_on_datalist/i1o0uuq/,1647960532,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
435.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"I don't think podcasts are inferior to video.

I'm not sure why anyone uses podcasts OR video as their primary learning tools.  I want a book or something else written, with a glossary and an index and table of contents.  I need to be able to skip forward when I get bored, re-read stuff when I get confused, and reference lessons quickly when I've started doing my project and realize ""the book mentioned something about this"".

A video/podcast might be a nice companion piece to a book.  But, I actually think a community that can answer my specific questions about the material is still more valuable.

(I'm 41.)",2fbcd615156bdb7a93af1665b59c26e08bc976e4,True,False,,,,,0,1647957651,,0,{},i1nu308,False,t3_tjsna2,False,True,t1_i1mrr7u,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1nu308/,1647957669,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
436.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"&gt; most definitely _don't_ start with Milewski's material

Agreed.  I really don't think it's good for beginners.",a1369965928ccf75f33a3f6d2d25613145984ee7,True,False,,,,,0,1647957302,,0,{},i1ntaqx,False,t3_tjsna2,False,True,t1_i1n5oyx,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1ntaqx/,1647957317,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
437.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"Alternate chapters of LYAH and https://haskellbook.com write _some_ code after each chapter, even if it's just to check how you are thinking about things.

Alternatively, you could do what I did and start reading the Report and writing code.  I was already an experienced programmer (10+ year professional) with experience with the lambda calculus in university.

&gt; Haskall programming from first principles is too long and verbose and I fall asleep reading it as it seems to be a lot of explanations compared to exercises.

So, add your own exercises!  That is literally the best book on Haskell right now, and the ""boring parts"" are often _exactly_ the bits that programmers coming from other languages need to understand before tackling Haskell.",251c0c5d5503adae5685347205e9173fb8516d8b,True,False,,,,,0,1647957107,,0,{},i1nsute,False,t3_tjsna2,False,True,t3_tjsna2,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1nsute/,1647957120,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
438.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"Property-based testing is designed for ""universal properties"", anything you can think of like ""for all x (in group X), prop(x)"".  You write a generator for ""group X"", and ""prop"".

Often we don't think of business requirements like this, at least not initially.  But, I find that when I'm writing ""normal"" unit tests with ""golden"" data, my thought process often stumbles over universal properties.  (Though sometimes it requires a very special generator.)",fb144ee62db7948958f3b7591ee76a8539c97aa1,True,False,,,,,0,1647956587,,0,{},i1nrp21,False,t3_tjxh34,False,True,t1_i1n1ryw,/r/haskell/comments/tjxh34/property_testing_am_i_missing_something/i1nrp21/,1647956602,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
439.0,[],False,,lomendil,,,[],,,,text,t2_bs6eo,False,False,"This is an example of testing your assumptions. You assume that all emails are treated equally throughout your system. What if you have a bug somewhere that makes your checks fail? Maybe your database allows null emails. It probably doesn't, but that would be the kind of bug property testing would find. In a complicated system that kind of bug can be more complicated too.",195ab7df683febf832758607db51ada78ab269ac,True,False,,,,,0,1647955746,,0,{},i1npvi9,False,t3_tjxh34,False,True,t1_i1n1nrm,/r/haskell/comments/tjxh34/property_testing_am_i_missing_something/i1npvi9/,1647955762,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
440.0,[],False,,HuwCampbell,,,[],,,,text,t2_z2xpn,False,False,"Apologies.

Yes. I think Data.List should be monomorphic and simple, including its implementation of `foldr` and `and`.

Beginners don't know to look at GHC.List.",99627bb42fabb115b3b771233f367b13ad87a11a,True,False,,,,,0,1647955413,,0,{},i1np6e9,False,t3_tjqw7a,False,True,t1_i1nnc4o,/r/haskell/comments/tjqw7a/seeking_community_feedback_on_datalist/i1np6e9/,1647955430,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
441.0,[],False,,phadej,,,[],,,,text,t2_4qmwn,False,False,"Your use of *specialised* is confusing.

I don't disagree. `and = foldr (&amp;&amp;) True` specifically for lists is the right way to do things. But when you click to view `and` implementation, you redirected to `Data.Foldable` source, which is *general* implementation! And that one should stay as `and = getAll #. foldMap All`.

The implementation in `GHC.List` **is** in fact `foldr (&amp;&amp;) True` in https://hackage.haskell.org/package/base-4.16.0.0/docs/src/GHC.List.html#and

So what you argue is all for monomorphization of `Data.List`. I.e. in some sense make `Data.List` re-export the subset of `GHC.List`, as latter has (or will have) also GHC specific stuff.

TL;DR: beginners should look into `GHC.List` for list function implementations",c36e12d5311a13d0613a7ae8a00983791228721e,True,False,,,,,0,1647954514,,0,{},i1nnc4o,False,t3_tjqw7a,False,True,t1_i1nlfkk,/r/haskell/comments/tjqw7a/seeking_community_feedback_on_datalist/i1nnc4o/,1647954531,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
442.0,[],False,,valcron1000,,,[],,,,text,t2_hw1ys,False,False,"Depends on the problem. Sometimes I apply a bottom-up approach defining core types and basic functions, and then composing them until I get what I want. Another approach is to get some examples, write down the expected API (top level functions) and then write on demand what I need to get things working.",8a43ef6ac86ffc2feab9ecd940a2a751f3afd850,True,False,,,,,0,1647954391,,0,{},i1nn39w,False,t3_tjl2sg,False,True,t3_tjl2sg,/r/haskell/comments/tjl2sg/what_does_your_workflow_look_like/i1nn39w/,1647954402,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
443.0,[],False,,ops-man,,,[],,,,text,t2_12z13r,False,False,"Do not get distracted by the ""M"" word or any of its many cousins.

As a beginner try focusing handling the functional paradigm and the Type system of haskell - that's where the language really shines. You can write an entire application without ever understanding monads.",b445158f17f4c0bb7d73cb47a9dec90947eb494e,True,False,,,,,0,1647954181,,0,{},i1nmo8t,False,t3_l4r111,False,True,t3_l4r111,/r/haskell/comments/l4r111/how_do_i_close_the_rift_between_textbook/i1nmo8t/,1647954194,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
444.0,[],False,,valcron1000,,,[],,,,text,t2_hw1ys,False,False,"There you have a property: ""you can't create a user with an email already taken"". You probably have a hardcoded email in your unit test, or - even better - you have multiple tests with various emails, but you probably don't have a proper statement about this property. I'm just guessing, but you probably have something like:

   @Test()
   public void cantCreateAnAccountWithAnAlreadyTakenEmail() {
       // Given:
       var email = new Email(""test@email.com"");
       // rest of the test ...
   }

The ""problem"" here is that your test is only covering the ""test@email.com"". If I don't read the method name, I could think that only that email can't be used more than once. Consider that your implementation could only check against that email and produce a 4XX response in that case, allowing other emails to be duplicated. The test would pass, but in practice the behavior of the system is not what you're looking for.

With property based testing, you can clearly state that **for any email** you get this behavior, and you can remove the hardcoded test email (what does ""test@email.com"" even mean? is it relevant for this test case? of course not!)",1c7c21e39e1784d0da04503e7f94bd195f47ea7d,True,False,,,,,0,1647954080,,0,{},i1nmgzg,False,t3_tjxh34,False,True,t1_i1n1nrm,/r/haskell/comments/tjxh34/property_testing_am_i_missing_something/i1nmgzg/,1647954094,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
445.0,[],False,,HuwCampbell,,,[],,,,text,t2_z2xpn,False,False,"Fair, and a good point.

I still believe that Data.List should use a more pedagogical implementations though.

The specialised versions are performant across all a wide variety of data structures, but it's very likely my version of and for lists is as fast as the generic one (if benchmarks show otherwise I'd love to see it).

Same goes with foldl, foldl' and foldr.",563a255424d001c8b6a624b00c263fded6090396,True,False,,,,,0,1647953551,,0,{},i1nlfkk,False,t3_tjqw7a,False,True,t1_i1niw4o,/r/haskell/comments/tjqw7a/seeking_community_feedback_on_datalist/i1nlfkk/,1647953563,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
446.0,[],False,,phadej,,,[],,,,text,t2_4qmwn,False,False,"&gt; Question though, with a Foldable constraint for foldr this should be as fast as the above?

It won't for `SnocList`. `foldr` and `foldl` aren't optimal for an unknown container.",00d0a793dbeb646cbb5770608a394ea1ae61b347,True,False,,,,,0,1647952213,,0,{},i1niw4o,False,t3_tjqw7a,False,True,t1_i1nc0pt,/r/haskell/comments/tjqw7a/seeking_community_feedback_on_datalist/i1niw4o/,1647952224,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
447.0,[],False,,dnkndnts,,,[],,,,text,t2_75i5o,False,False,"Yeah, and having a standard library implementation optimized for beginner readability would be a monumental achievement that I don’t think any major player pursues.

Just try reading an implementation of the c++ standard library 😬",6723e9f36b6310ecdce2e4efff363c59ca719b7b,True,False,,,,,0,1647951135,,0,{},i1ngysh,False,t3_tjqw7a,False,True,t1_i1nf1sd,/r/haskell/comments/tjqw7a/seeking_community_feedback_on_datalist/i1ngysh/,1647951149,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
448.0,[],False,,gelisam,,,[],,,,text,t2_akqgc,False,False,"Exporting a specialized type is one thing (which I support), changing the implementation from one optimized for efficiency to one optimized for readability is another! Especially for such commonly-used functions.

I hope the proposal is only to change the type signatures, not the implementations? It's hard to tell what the actual proposed change is, as all the discussion seems focused on the process around the change rather than the change itself.",71c62d0decf07aac93662330b3a31116d590a97c,True,False,,,,,0,1647950009,,0,{},i1nf1sd,False,t3_tjqw7a,False,True,t1_i1nc0pt,/r/haskell/comments/tjqw7a/seeking_community_feedback_on_datalist/i1nf1sd/,1647950026,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
449.0,[],False,,DietOk3559,,,[],,,,text,t2_a2pe4ib3,False,False,"There are ""quick and dirty"" ways to learn Haskell, like Learn You a Haskell for instance, or the videos I mentioned, or countless other resources available for beginners. You're still not going to learn Haskell in a week with them. The fact that it takes more than a week to learn Haskell isn't a shortcoming of the community.

What is your issue with Milewski's content? I think he is one of the most down to Earth and skilled Haskell instructors out there. Have you watched the series I recommended? I'm not talking about his category theory content, which is also great but not suited for beginners or anyone who isn't passionate about the subject.",c3f31990a70be66bb152800460a620aa0b798875,True,False,,,,,0,1647948308,,0,{},i1ncdrm,False,t3_tjsna2,False,False,t1_i1n5oyx,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1ncdrm/,1647948325,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
450.0,[],False,,HuwCampbell,,,[],,,,text,t2_z2xpn,False,False,"I'm for Data.List to offer specialised versions, and ones which are very readable. It's one of the first modules beginners will read the source for.

For example, clicking on view source for foldl shows:

    foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
    foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z

This is complex, and there's no way that a beginner will see that this is the lazy version of a left fold, they can't compare it to foldl' either, which is written completely differently.

Here's and:

    and :: Foldable t =&gt; t Bool -&gt; Bool
    and = getAll #. foldMap All

Again, ok, I don't know why this is the way it is, but to understand this you need to know monoids, foldable, the coerce version of function composition.

    and :: [Bool] -&gt; Bool
    and = foldr (&amp;&amp;) True

This gives newcomers a chance.

Question though, with a Foldable constraint for foldr this should be as fast as the above? Why is this not the actual implementation?",9f0737b4123ac1330095341b59d5a809ba9e039d,True,False,,,,,0,1647948067,,0,{},i1nc0pt,False,t3_tjqw7a,False,True,t3_tjqw7a,/r/haskell/comments/tjqw7a/seeking_community_feedback_on_datalist/i1nc0pt/,1647948080,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
451.0,[],False,,gelisam,,,[],,,,text,t2_akqgc,False,False,"Thanks for the link! I want to add, for those who like me are confused by the fact that the comment seems to be justifying the CLC's actions rather than justifying the change, that the actual list of justifications for the change is a bit further down that comment.

These justifications seem convicing to me, but since you used scare quotes around the word ""justification"", you clearly think otherwise. Do you have a similar list of objections to the change? Skimming through the discussion, it seems to me that the complaints are about the process around the change, and not about the change itself.",90f1be149088efedb81c6a10528a5a5547b383a8,True,False,,,,,0,1647947429,,0,{},i1nb359,False,t3_tjqw7a,False,True,t1_i1mxdnv,/r/haskell/comments/tjqw7a/seeking_community_feedback_on_datalist/i1nb359/,1647947445,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
452.0,[],False,,Venom_moneV,,,[],,,,text,t2_t80um,False,False,I'm trying to perform db operations in haskell but I'm not finding the library I want.  I have predefined types that will correspond to tables and I just want a simple interface to perform CRUD operations on them. Something like sqlalchemy in python. Any suggestions?,1f139bfe54c799b683893d573bd233e803f34dea,True,False,,,,,0,1647946487,,0,{},i1n9s1j,False,t3_t3zw0x,False,True,t3_t3zw0x,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1n9s1j/,1647946502,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
453.0,[],False,,ocramz_,,,[],,,,text,t2_jaolcjrr,False,False,typed holes are better than undefined because they force you to implement everything and suggest what's missing. With undefined it's easy to forget something that will blow up in your face at an unexpected time,60b9be26f16179ee2dc5c6145d97e6adc17cc134,True,False,,,,,0,1647943575,,0,{},i1n62ox,False,t3_tjl2sg,False,True,t1_i1maxl3,/r/haskell/comments/tjl2sg/what_does_your_workflow_look_like/i1n62ox/,1647943587,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
454.0,[],False,,ocramz_,,,[],,,,text,t2_jaolcjrr,False,False,"As a practitioner myself, I find it shameful that we can't suggest a quick-and-dirty way to learn the language. There is plenty of tutorial material out there",5f6ecab290e074bef810f4733e4041ed2f8315f1,True,False,,,,,0,1647943269,,0,{},i1n5oyx,False,t3_tjsna2,False,True,t1_i1me93g,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1n5oyx/,1647943283,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
455.0,[],False,,amalloy,,,[],,,,text,t2_6f5lu,False,False,"Have you watched any of John Hughes's talks on QuickCheck? https://www.youtube.com/watch?v=V9_14jjJiuQ is one example I pulled at random from YouTube, which I haven't watched personally but I assume is similar. It's interesting, and if it doesn't give you some ideas, I certainly won't be able to.",dcfffb7a0595abba3ffad58c7b294c2b0e8d447b,True,False,,,,,0,1647941653,,0,{},i1n3sfe,False,t3_tjxh34,False,True,t1_i1n1nrm,/r/haskell/comments/tjxh34/property_testing_am_i_missing_something/i1n3sfe/,1647941665,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
456.0,[],False,,gilmi,,,[],,,,text,t2_igdxr,False,False,"I think it might be possible to use my (fairly new) book to ramp up quickly, but I don't know yet (not enough feedback).
If you want to give it a try you can read it here: https://lhbg-book.link

And if you do try it and can let me know if it helped you I'd appreciate it as well.",a40ba8a54b700349de4c4ad33f743be806411d1c,True,False,,,,,0,1647940997,,0,{},i1n31u7,False,t3_tjsna2,False,True,t3_tjsna2,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1n31u7/,1647941008,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
457.0,[],False,,bedobi,,,[],,,,text,t2_k155g,False,False,"Thanks for this helpful reply, I do see what you mean, it does seem then like property testing isn't really super applicable to my intuitive use cases in the case of this system I'm working on",c40a57bbc2566cc07ccba7d3dda1716c14b98575,True,False,,,,,0,1647939850,,0,{},i1n1ryw,True,t3_tjxh34,False,True,t1_i1mxa03,/r/haskell/comments/tjxh34/property_testing_am_i_missing_something/i1n1ryw/,1647939864,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
458.0,[],False,,bedobi,,,[],,,,text,t2_k155g,False,False,"thanks for trying to shift my thinking, I do see what you mean

but I hate to admit even then I don't really see a huge need for a property testing framework

we already have literally that test, a test that spins up our app (with an ephemeral but real mysqsl db and everything), creates a user and then tries to create another user with the same email, and confirms the response is 4xx with an error

semantically, that test is testing the ""sharing email is not allowed-ness"" ""property"" of users in our system

it's not doing it using a property testing network that generates millions of examples, but I don't really see why more than one test to prove that is required

so I'm still a bit stumped trying to come up with a useful use case",cd4049c7ed07fdf1e946badf56d0c4a737e43b9b,True,False,,,,,0,1647939750,,0,{},i1n1nrm,True,t3_tjxh34,False,True,t1_i1mxjdl,/r/haskell/comments/tjxh34/property_testing_am_i_missing_something/i1n1nrm/,1647939765,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
459.0,[],False,,amalloy,,,[],,,,text,t2_6f5lu,False,False,"You have discovered that ""Our string validators should match this specific string generator"" is not a property you care about testing. That's fine, don't test it. Test more interesting properties like, ""When an input email address doesn't match our validator, we don't try to send an email to it"", or something else about your business logic. It's hard to guess what that might be since I don't know what your program does. Maybe things like ""A user who tries to create an account with the same email address as another account does not succeed in creating an account""?",2191c698cf45d5cad013406ea1d954def136fd04,True,False,,,,,0,1647936035,,0,{},i1mxjdl,False,t3_tjxh34,False,True,t3_tjxh34,/r/haskell/comments/tjxh34/property_testing_am_i_missing_something/i1mxjdl/,1647936046,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
460.0,[],False,,effectfully,,,[],,,,text,t2_svn83,False,False,"""Justification"" of this change can be found here: https://gitlab.haskell.org/ghc/ghc/-/issues/20025#note_365364",63c3c700db3cee0fdf404d9dda45a366059121a0,True,False,,,,,0,1647935893,,0,{},i1mxdnv,False,t3_tjqw7a,False,True,t3_tjqw7a,/r/haskell/comments/tjqw7a/seeking_community_feedback_on_datalist/i1mxdnv/,1647935905,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
461.0,[],False,,lomendil,,,[],,,,text,t2_bs6eo,False,False,"Property testing is about testing (or rather catching) your assumptions and validating laws.

If you have your special purpose custom email validator that uses a regex, then you're right, you probably wouldn't want to make a regex-based generator. You would construct a string using whatever classes of characters you allow in whatever places you allow them. If you're in regex-land already in your mind, then that probably sounds like a regex generator, but you don't have to do it that way. You describe a bunch of constraints that are particular to your situation, so those are the things you should start with defining a generator. Try to think more declarative and write down what your definition of an email address is at a high level (since it seems to differ from standards). Note you can make bad generators too, and check that they fail.

Again, it's for testing lawful things (well, properties!). One of the classics is encoder-decoder round trips, or sometimes you have the pleasure of testing things like associativity, though I find that rarer. My usual use case is testing whether something does the right thing, or at least doesn't blow up, given some kind of input. Making the generator is often part of the debugging process (oh, I actually don't want to accept inputs like that, I better handle that...). That sounds a bit like your situation, actually.",bab9ef80903728a0e2a3bd9405b748bf558ca5b0,True,False,,,,,0,1647935803,,0,{},i1mxa03,False,t3_tjxh34,False,True,t3_tjxh34,/r/haskell/comments/tjxh34/property_testing_am_i_missing_something/i1mxa03/,1647935815,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
462.0,[],False,,SnooRecipes5458,,,[],,,,text,t2_5rfmilp1,False,False,How old are you?,c0dcba11d4cfd9ff21309597cdfed78578687712,True,False,,,,,0,1647935787,,0,{},i1mx9cw,False,t3_tjsna2,False,True,t1_i1mrr7u,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1mx9cw/,1647935802,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
463.0,[],False,,AmbroseHaskell,,,[],,,,text,t2_ioythzj0,False,False,`-XExportAnnotations` seems like a cool feature heh,a07e1372ab78c8cd4318e73fd9b06c704f34a1b2,True,False,,,,,0,1647932727,,0,{},i1mts18,False,t3_tjqw7a,False,False,t3_tjqw7a,/r/haskell/comments/tjqw7a/seeking_community_feedback_on_datalist/i1mts18/,1647932742,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
464.0,[],False,,SolaTotaScriptura,,,[],,,,text,t2_5dpnr08,False,False,Typed holes,c343b5831f7cd2c42bec57ca2dc77e4fe451efe8,True,False,,,,,0,1647932588,,0,{},i1mtm4y,False,t3_tjl2sg,False,True,t3_tjl2sg,/r/haskell/comments/tjl2sg/what_does_your_workflow_look_like/i1mtm4y/,1647932605,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
465.0,[],False,,Opposite-Platypus-99,,,[],,,,text,t2_clsnehel,False,False,must be an age thing but podcasts are the last thing I'd turn to for learning anything,5b02b4b5d6c95eb1ff20994ebe5caceb4c8d8dcd,True,False,,,,,0,1647931046,,0,{},i1mrr7u,False,t3_tjsna2,False,True,t1_i1mp9rc,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1mrr7u/,1647931062,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
466.0,[],False,,Opposite-Platypus-99,,,[],,,,text,t2_clsnehel,False,False,"Learn you a Haskal in one week :

* ADTs and pattern matching.  Maybe, Either. Write a function that catches division by zero and returns Nothing
* monads : ""do"" notation, IO . Write a program that waits for user input and prints it back
* parser combinators : set up a project, import attoparsec and put together a program that parses some structured data like a street address.
* typeclasses : write a JSON ser/des interface with aeson, auto-derive FromJSON and ToJSON. Figure out why it works by reading typeclass instance chains
* typeclasses 2 : Functor, what types satisfy its interface? What is it useful for?",c8807afbba8a31bade8719a4adb868799e6707ad,True,False,,,,,0,1647930933,,0,{},i1mrm7q,False,t3_tjsna2,False,True,t3_tjsna2,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1mrm7q/,1647930946,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
467.0,[],False,,SnooRecipes5458,,,[],,,,text,t2_5rfmilp1,False,False,"It’s going to take you more than a week, but I’d do Haskell on https://exercism.org paired with http://learnyouahaskell.com and some LambdaCast on sound cloud.",da13f39811b24209dc2a04551ea4b124d0c509d4,True,False,,,,,0,1647929077,,0,{},i1mp9rc,False,t3_tjsna2,False,True,t3_tjsna2,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1mp9rc/,1647929088,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
468.0,[],False,,someacnt,,,[],,,,text,t2_euebihog,False,False,How much exposure did you have previously?,5fe4ca9b43bbce0c6bfdbd3f739c9e993b677b01,True,False,,,,,0,1647924163,,0,{},i1mieof,False,t3_tjsna2,False,True,t3_tjsna2,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1mieof/,1647924179,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
469.0,[],False,,DietOk3559,,,[],,,,text,t2_a2pe4ib3,False,False,"It's not realistic to expect to learn the basics of Haskell in one week, even if you have some prior exposure to the language. You certainly shouldn't be looking at monad tutorials (ever, in my opinion, but especially not in your first week when you don't have a solid understanding of fundamentals yet).

There aren't any shortcuts to learning Haskell. Anyone has the capacity to learn it, but it requires disciplined study and patience. That said, if the Haskell Book isn't the right resource for your learning style, you could try watching Graham Hutton's video courses on Youtube. There is also a workshop series by Bartosz Milewski on YT (Parallel and Concurrent Haskell) that is a very good introduction to the language (it doesn't have much to do with parallelism/concurrency despite the title - more of a general introduction).

You will need to code a lot on your own and wrestle with GHC if you want to progress beyond a superficial understanding of the language.

This is just my personal perspective, as someone who is self-taught and who teaches Haskell to beginners. Best of luck to you in your studies.",2b7f57291daaa27dc23c9dcaaa0acfe6173c6a88,True,False,,,,,0,1647921644,,0,{},i1me93g,False,t3_tjsna2,False,True,t3_tjsna2,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1me93g/,1647921658,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
470.0,[],False,,Big_Relationship_239,,,[],,,,text,t2_g3zohhjw,False,False,"Check out [Typeclassopedia](https://wiki.haskell.org/Typeclassopedia):

&gt; Have you ever had any of the following thoughts?    
&gt; 
&gt; - What the heck is a monoid, and how is it different from a monad?  
&gt; - I finally figured out how to use [Parsec](https://wiki.haskell.org/Parsec) with do-notation, and someone told me I should use something called `Applicative` instead Um, what?  
&gt; - Someone in the [#haskell](https://wiki.haskell.org/IRC_channel) IRC channel used `(***)`, and when I asked Lambdabot to tell me its type, it printed out scary gobbledygook that didn’t even fit on one line! Then someone used `fmap fmap fmap` and my brain exploded. 
&gt; - When I asked how to do something I thought was really complicated, people started typing things like `zip.ap fmap.(id &amp;&amp;&amp; wtf)` and the scary thing is that they worked! Anyway, I think those people must actually be robots because there’s no way anyone could come up with that in two seconds off the top of their head.
&gt;   
&gt; If you have, look no further! You, too, can write and understand concise, elegant, idiomatic Haskell code with the best of them.",2b0304f76ea3df913932014feb9eb6d9eda816a1,True,False,,,,,0,1647921529,,0,{},i1me1zg,False,t3_tjforr,False,True,t3_tjforr,/r/haskell/comments/tjforr/writing_proper_haskell_code/i1me1zg/,1647921545,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
471.0,[],False,,DietOk3559,,,[],,,,text,t2_a2pe4ib3,False,False,"Yes, in my opinion it's the best Haskell book and is certainly suitable for Haskell beginners, as well as those new to programming in general (Julie, one of the authors, was a linguist who had no programming experience and learned Haskell as her first language, so the book is informed by her perspective). You can visit the website and preview a few chapters there to see if you like it.",25e4a3bc83019305d7b6281285b642f2bcdc49db,True,False,,,,,0,1647920795,,0,{},i1mcrab,False,t3_tjsna2,False,True,t1_i1ma021,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1mcrab/,1647920811,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
472.0,[],False,,Syncopat3d,,,[],,,,text,t2_5qs9j,False,False,"I don't use anything fancy.

For a project above a certain complexity threshold, I do this: Define the types (data types and function types), filling in the blanks for unimplemented functions with undefined. Go over the skeleton code from a type perspective to check that the data flow makes sense. If not, fix the types. Fill in the blanks and replace the undefined parts with actual implementation.",a60db1c7079f4a88d6bf7631b9d226b5417941e2,True,False,,,,,0,1647919784,,0,{},i1maxl3,False,t3_tjl2sg,False,False,t3_tjl2sg,/r/haskell/comments/tjl2sg/what_does_your_workflow_look_like/i1maxl3/,1647919800,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
473.0,[],False,,TheTravelingSalesGuy,,,[],,,,text,t2_6alpil7,False,False,"After I learned Haskell I tried using point free style for a little bit. It might be a good idea to try to refactor some of your functions to be point free. Here is a video that explains it.

https://youtu.be/seVSlKazsNk

Not all point free code is readable so don't use it everywhere tho. Haskell is a great language for refactoring code and using point free style can help you see new ways to write functions.

Aside from that I recommend using hlint which is a code linter for Haskell.",0c7e34da69640d66fb804e46f9d173774b617622,True,False,,,,,0,1647919739,,0,{},i1maujz,False,t3_tjforr,False,True,t3_tjforr,/r/haskell/comments/tjforr/writing_proper_haskell_code/i1maujz/,1647919750,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
474.0,[],False,,PASC7L,,,[],,,,text,t2_d1rzr16x,False,False,"Sorry I don’t know how to recommend learning this language because I have just started it myself. In fact I am not a very experienced programmer at all. FWIW from an academic standpoint I did the same thing for math. Grind a lot of algebra or whatever before diving into something else that requires it. As long as you concentrate while working, correct your mistakes, and don’t fry your brains before the class begins. Hopefully someone here can evaluate the exercises you’ve chosen in detail.

I wanted to ask you about Haskell Programming from First Principles. How did you hear about this book? Your post is the first I’ve heard of it and it sounds interesting. As a math guy, functional programming seems really cool. From what you have read, do you think that it would make a good book for a programming beginner?",61ea18d85d8d3d02ad2f1e9a80d3e9a510698cda,True,False,,,,,0,1647919284,,0,{},i1ma021,False,t3_tjsna2,False,True,t3_tjsna2,/r/haskell/comments/tjsna2/need_the_basics_down_in_one_week_where_to_start/i1ma021/,1647919296,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
475.0,[],False,,wadawalnut,,,[],,,,text,t2_bjw77,False,False,I've had great experience in the past asking people on IRC (#haskell on libera.chat) to review some code snippets.,07ec5f635e6cdd113cf539c761a8c70e3f2b469a,True,False,,,,,0,1647911418,,0,{},i1ltfjg,False,t3_tjforr,False,True,t3_tjforr,/r/haskell/comments/tjforr/writing_proper_haskell_code/i1ltfjg/,1647911431,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
476.0,[],False,,whilefive,,,[],,,,text,t2_4n1teftu,False,False,"ever think about refactoring?  


Just write whatever, so you get something working. Take a long look at the code, change whatever you want. The compiler is a \_huge\_ help here, because it'll tell you everything you broke.   


Once you've gone through a few times, and made it more like you want, the next time you write a batch of code, it'll look more Haskell style. Nobody is perfect out of the gate. Revise, refine, keep looking for chances to do better.  


But seriously, lean on the compiler. be fearless about moving stuff around, ghc will tell you everything you need to think about. worst case, ya just git revert.",2a5b2b7c190c6771d4c234fabdf2f4332af1d968,True,False,,,,,0,1647908083,,0,{},i1lm1ob,False,t3_tjforr,False,True,t3_tjforr,/r/haskell/comments/tjforr/writing_proper_haskell_code/i1lm1ob/,1647908097,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
477.0,[],False,,FreeVariable,,,[],,,,text,t2_16uihwda,False,False,"It's quite clear what what my benchmark is: similar in price to events otherwise similar. I could add another: not exceeding a 1/10th of the median salary of the host country. If India's median salary is 16k Rs, and the Functional Conf pass 3k Rs, we're at about 1/5th of the median salary. 

That does not mean that everything should be free, obviously. But requiring 1/5th of India's monthly salary for accessing the stream looks bad no matter how I look at it.",a7ac22f2ec028500d7ca1d9c548950351b4e10ed,True,False,,,,,0,1647905781,,0,{},i1lgvl2,False,t3_telf9t,False,True,t1_i1kwffg,/r/haskell/comments/telf9t/haskellers_functional_conf_2022_is_online_and/i1lgvl2/,1647905795,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
478.0,[],False,,Iceland_jack,,,[],,,,text,t2_3qjdu,False,False,"While we don't have [parameterised patterns](https://gitlab.haskell.org/ghc/ghc/-/wikis/pattern-families) I liked this outcome, I mean I found it cute :)

    winner :: Action -&gt; Action -&gt; Outcome
    winner = curry \case
      Beats      -&gt; Player1Win
      Swap Beats -&gt; Player2Win
      _          -&gt; Draw

    pattern Beats :: (Action, Action)
    pattern Beats &lt;- ((`elem` rules) -&gt; True)

    pattern Swap :: (a, b) -&gt; (b, a)
    pattern Swap as &lt;- ((\(a, b) -&gt; (b, a)) -&gt; as)",40e244e9d5ba866578dcaaee8616e7c1fbd6d95b,True,False,,,,,0,1647905024,,0,{},i1lf56y,False,t3_tdh2nn,False,True,t1_i0k1o0j,/r/haskell/comments/tdh2nn/pattern_matching_rps/i1lf56y/,1647905064,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
479.0,[],False,,IronyIsHonesty,,,[],,,,text,t2_jydp4c3d,False,False,"Well, I'd say that it's not a pure functional language, but a functional language, since functions are first-class citizens.",d603e7bb396f874f2bc0710cd7543f800fc3bf13,True,False,,,,,0,1647903283,,0,{},i1lb3u1,False,t3_rkldfc,False,True,t1_hpef1pm,/r/haskell/comments/rkldfc/how_come_haskell_ended_up_with_a_repl_ghci_as_a/i1lb3u1/,1647903303,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
480.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"Some random advice: 

I think you overuse `Either`. I would strongly recommend to read [parse don't validate](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/). For example instead of `type Board = [[Piece]]` use `newtype Board = UnsafeMkBoard [[Piece]]` and write a ""parser"" (aka smart constructor):

    mkBoard :: [[Piece]] -&gt; Either String Board
    mkBoard b 
      | isBoardFit b = Right (UnsafeMkBoard b)
      | otherwise = Left ""some error""

If you make sure never to use the `UnsafeMkBoard` constructor, then you can assume that any board you get as input is always valid. This does also require you to do this packing and unpacking of boards, but I think that is preferred over having `Either` all over your code.

Also, I think you can use more pattern matching. E.g. instead of:

    apm b c s@(x, y)
      | c == Black &amp;&amp; y == 1 = takeWhile checker [(x, y + 1), (x, y + 2)]
      | c == Black = filter checker [(x, y + 1)]
      | c == White &amp;&amp; y == 6 = takeWhile checker [(x, y - 1), (x, y - 2)]
      | c == White = filter checker [(x, y - 1)]
      | otherwise = undefined              

I would write:

    apm b Black s@(x, 1) = takeWhile checker [(x, y + 1), (x, y + 2)]
    apm b Black s@(x, y) = filter checker [(x, y + 1)]
    apm b White s@(x, 6) = takeWhile checker [(x, y - 1), (x, y - 2)]
    apm b White s@(x, y) = filter checker [(x, y - 1)]
    apm b c s@(x, y) = undefined",ce1543e36219bd3f8c91e0c6a3a6e18c1b139152,True,False,,,,,0,1647902005,,0,{},i1l838j,False,t3_tjforr,False,True,t1_i1kocal,/r/haskell/comments/tjforr/writing_proper_haskell_code/i1l838j/,1647902022,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
481.0,[],False,,Iceland_jack,,,[],,,,text,t2_3qjdu,False,False,"I second pattern matching, at 3-tuples I usually reach for a record but if you are given a function

    myFun :: Foo -&gt; (Integer, Integer, Integer)

you can pattern match in a few ways


    {-# Language ViewPatterns #-}
    f1 :: Foo -&gt; Integer
    f1 (myFun -&gt; (a, _, _)) = a + a

    f2 :: Foo -&gt; Integer
    f2 foo
      | (a, _, _) &lt;- myFun foo
      = a + a

    {-# Language MultiWayIf #-}
    f3 :: Foo -&gt; Integer
    f3 foo =
      if | (a, _, _) &lt;- myFun foo -&gt; a + a

    {-# Language LambdaCase #-}
    import Control.Category ((&gt;&gt;&gt;))

    f4 :: Foo -&gt; Integer
    f4 = myFun &gt;&gt;&gt; \case
      (a, _, _) -&gt; a + a",06fc6719a8d1a3f434d418d777308064a1feb9d3,True,False,,,,,0,1647901227,,0,{},i1l68eq,False,t3_t3zw0x,False,True,t1_i1jq787,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1l68eq/,1647901243,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
482.0,[],False,,tom-md,,,[],,,,text,t2_7b2si,False,False,"Yes, and they are quite likely to react positively to you note it is an assignment upfront. Just post it and call out what confuses you (rather than ""I don't understand: &lt;link&gt;"").",ce8c2a6d8754e085adc5d63fcc1a7697db0fbbbe,True,False,,,,,0,1647900444,,0,{},i1l4d1k,False,t3_tjmcwy,False,True,t3_tjmcwy,/r/haskell/comments/tjmcwy/assignment/i1l4d1k/,1647900461,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
483.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"I don't know all the features of VS code, but I'm using CoC or LanguageClient-neovim and the typescript LSP to get autocomplete and real-time diagnostics.",70bf84eb8ed003e6c4339a74f5e4368d673a2a49,True,False,,,,,0,1647899952,,0,{},i1l38ap,False,t3_tbo2ti,False,True,t1_i1kxtyd,/r/haskell/comments/tbo2ti/good_haskell_ide/i1l38ap/,1647899964,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
484.0,[],False,,miketsap,,,[],,,,text,t2_ptujc,False,False,"Having the exact same feeling! Solving the aoc21 in Haskell and then watching someone more experienced solving it with in the proper* Haskell way was eye opening! https://youtube.com/playlist?list=PLKDpSfFMS1VQROyYkjXbI7sO-cU8QeaSS

*proper compared to the code that I write.",b74b29ffbc6cdc70922d728336d05d8d71623ddd,True,False,,,,,0,1647899436,,0,{},i1l20vh,False,t3_tjforr,False,True,t3_tjforr,/r/haskell/comments/tjforr/writing_proper_haskell_code/i1l20vh/,1647899451,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
485.0,[],False,,crisoagf,,,[],,,,text,t2_aw38c,False,False,"Thank you! Good to know that there isn't anything escaping me!

I'd venture that `(Strong p, Choice p, Monoidal p)`  may be the formula to get `Traversing p` or at least something similar (because the profunctor optics seem to be `Traversal`s for both).",c15d15d38b8eeab8cea1d037b32b33ea4d32d13b,True,False,,,,,0,1647898595,,0,{},i1l01bg,True,t3_tji67i,False,True,t1_i1klkty,/r/haskell/comments/tji67i/are_monoidalproductprofunctor_and_traversing/i1l01bg/,1647898606,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
486.0,[],False,,frailman,,,[],,,,text,t2_1wevn6sx,False,False,"I've been using vim for almost a decade, but for a recent typescript project (last 6 months or so) i've been using exclusively vs code with its vim plugin.  If i'm going to switch back to vim, I'm going to have to spend some time getting vim to do some of the things I've become used to, mostly around language support and real time linting.  I'm confident vim can do it all, but vscode has been good enough (still some minor frustrations) basically out of the box.  I'm reluctant to like it, but I do.",4d18e96de6bc639f1d1e24dfe863074774637429,True,False,,,,,0,1647897673,,0,{},i1kxtyd,False,t3_tbo2ti,False,True,t1_i0a7jbk,/r/haskell/comments/tbo2ti/good_haskell_ide/i1kxtyd/,1647897687,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
487.0,[],False,,dontchooseanickname,,,[],,,,text,t2_idajg,False,False,"[shitty] No it's not :)

&gt; Just writing pure functions in a procedural

In you project, [Lib.hs](https://github.com/RHL120/RhChess/blob/master/app/Lib.hs) does not have any IO. it's pure. Your actual Main.hs is 1/5th long, perfect for glue code that wires pure code.

&gt; I don't think about them

Hmm you're strong-typing, pattern-matching a lot. Sorry, this looks like perfectly understandable, clear and valid Haskell to me.
 
So allow me to make the joke : [here be concepts, especially Recursion Schemes from Comonads](http://www.willamette.edu/~fruehr/haskell/evolution.html)",cfe31415b1474bba858e496d61c6272c7482d949,True,False,,,,,0,1647897460,,0,{},i1kxbvv,False,t3_tjforr,False,False,t1_i1kocal,/r/haskell/comments/tjforr/writing_proper_haskell_code/i1kxbvv/,1647897477,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
488.0,[],False,,rampion,,,[],,,,text,t2_4gh8d,False,False,"The competition started at midnight in my timezone, so I kept nodding off while working on the third problem.

I was quite satisfied with my approach to the first two, though.

For ""Speed Typing"" I just wrote a recursive edit-distance computation:

    {-# OPTIONS_GHC -Wall -Wextra -Werror #-}
    {-# LANGUAGE TypeApplications #-}
    {-# LANGUAGE BangPatterns #-}
    module Main where

    import Control.Monad (forM_)

    main :: IO ()
    main = do
      numCases &lt;- readLn @Int
      forM_ [1..numCases] $ \caseNum -&gt; do
        input &lt;- getLine
        produced &lt;- getLine
        putStrLn $ concat [ ""Case #"", show caseNum, "": "", maybe ""IMPOSSIBLE"" show $ numDeletions input produced ]

    numDeletions :: String -&gt; String -&gt; Maybe Int
    numDeletions = loop 0 where
      loop !count as@(a:at) (b:bt)
        | a == b    = loop count at bt
        | otherwise = loop (count + 1) as bt
      loop !count [] bs = Just (count + length bs)
      loop _ (_:_) [] = Nothing


For ""Challenge Nine"" I probably did more conversion between integer and string than I needed to, but constructing the solution was still easy due the useful property that 10ⁿ = 1 mod 9

    {-# OPTIONS_GHC -Wall -Wextra -Werror #-}
    {-# LANGUAGE TypeApplications #-}
    module Main where

    import Control.Monad (forM_)

    main :: IO ()
    main = do
      numCases &lt;- readLn @Int
      forM_ [1..numCases] $ \caseNum -&gt; do
        n &lt;- readLn @Integer
        putStrLn $ concat [ ""Case #"", show caseNum, "": "", show (nextMultipleOfNine n)]

    nextMultipleOfNine :: Integer -&gt; Integer
    nextMultipleOfNine n = read (prefix ++ dc : suffix) where
      digit = negate n `mod` 9
      ~[dc] = show digit
      ns@(~(nc:nt)) = show n
      (prefix, suffix) 
        | dc == '0' = ([nc], nt)
        | otherwise = span (&lt;=dc) ns

I may have been taking the wrong approach for the third one, but I started looking at substrings a_i a_{i+1} ... a_{i+k}, k &gt;= 5 as a boolean constraint:

  a_i /= a_{i+k} || a_{i+1} /= a_{i+k-1} || ...

In combination with all the other substrings, that meant I had something that looked like a SAT problem

  (a_i /= a_{i+k} || a_{i+1} /= a_{i+k-1} || ...) &amp;&amp; (a_i /= a_{i+k+1} || a_{i+1} /= a_{i+k} || ...) &amp;&amp; ...

There were some optimizations I could make - if a clause contained `1 /= 0` then it was trivial, but the general case seemed to require a SAT solver, so that's what I fell asleep working on.",4d4fec0f30ecb4e74169ed6da8ee75c1cd3f825b,True,False,,,,,0,1647897362,,0,{},i1kx3sz,True,t3_tjlxcg,False,True,t3_tjlxcg,/r/haskell/comments/tjlxcg/google_kick_start_round_a_2022/i1kx3sz/,1647897379,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
489.0,[],False,,ConfEngine,,,[],,,,text,t2_4rfhxpaq,False,False,"If ""free"" is your benchmark, then anything with a charge will seem disappointing. I hope you will find value in what Functional Conf is offering for a very modest price.",6c4bab3db6c36ad902df2fe8cac642b5e9b44c94,True,False,,,,,0,1647897058,,0,{},i1kwffg,False,t3_telf9t,False,True,t1_i16qwbo,/r/haskell/comments/telf9t/haskellers_functional_conf_2022_is_online_and/i1kwffg/,1647897074,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
490.0,[],False,,AmbroseHaskell,,,[],,,,text,t2_ioythzj0,False,False,I do a lot of chores,5755e4b803df5d0a12af6d3a93362e50f27074d0,True,False,,,,,0,1647895905,,0,{},i1ktt91,False,t3_tjl2sg,False,True,t3_tjl2sg,/r/haskell/comments/tjl2sg/what_does_your_workflow_look_like/i1ktt91/,1647895917,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
491.0,[],False,,rhl120,,,[],,,,text,t2_6cjrymqf,False,False,"Sure, I wrote this shitty program that that takes a chess board and gives out a diagram with all possible moves as arrows: https://github.com/RHL120/RHCHess",abb6fc9f4f8d79e6b5dd037a20dfbd9a153d3898,True,False,,,,,0,1647893725,,0,{},i1kocal,True,t3_tjforr,False,True,t1_i1kbvqp,/r/haskell/comments/tjforr/writing_proper_haskell_code/i1kocal/,1647893737,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
492.0,[],False,,rhl120,,,[],,,,text,t2_6cjrymqf,False,False,Thanks,97cba4858411c435e526dd651157aac20178222c,True,False,,,,,0,1647893654,,0,{},i1ko5rw,True,t3_tjforr,False,True,t1_i1jsoqh,/r/haskell/comments/tjforr/writing_proper_haskell_code/i1ko5rw/,1647893668,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
493.0,[],False,,WarDaft,,,[],,,,text,t2_cspxi,False,False,"I feel like `p ?$&gt; x` is a reasonable synonym for `guard p $&gt; x`... or rather, it would be without MonadComprehensions.",3aad5fe5435c74f6dcd88642cd0b07d773e3753d,True,False,,,,,0,1647893139,,0,{},i1kmuqw,False,t3_tfkteo,False,True,t1_i0wiewq,/r/haskell/comments/tfkteo/is_there_a_better_pattern_for_return_just_some/i1kmuqw/,1647893150,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
494.0,[],False,,tomejaguar,,,[],,,,text,t2_45sug,False,False,"You definitely can't get `Traversing` from `ProductProfunctor`. Consider the `Traversable` `Const a`. There's no way to get `p (Const a a') (Const a b')`, i.e. `p a a`, from `p a' b'`. It think you need `ProductProfunctor`, `SumProfunctor` and `Strong` to get `Traversing` and [Alexis King's construction](https://github.com/tomjaguarpaw/Arrows2/issues/3#issuecomment-561973678) gives you that (albeit in an Arrow setting, but should generalise to Profunctor).

As for whether you can get `ProductProfunctor` from `Traversing`, I'm skeptical. Suppose I have `p a b1` and `p a b2`. How can I turn them into a single `p` value to which to apply `traverse'`? I don't see how that can be possible, but I don't have a convincing proof.

On the other hand if `p` were a `SumProfunctor` you could form `p (Either a a) (Either b1 b2)`, then take `(a1, a2) :: (a, a)`, turn it into `[Left a1, Right a2]`, `traverse'` over that to get `[Left b1, Right b2] :: Either b1 b2`, which you turn into `(b1, b2) :: (b1, b2)`. In principle this can crash, but if everything obeys the appropriate laws then I don't think it can crash in practice.

So perhaps `SumProfunctor` is needed for the correspondence to go through.",44ed9362eb002c4a0ad815658ad43d547350a771,True,False,,,,,0,1647892644,,0,{},i1klkty,False,t3_tji67i,False,False,t3_tji67i,/r/haskell/comments/tji67i/are_monoidalproductprofunctor_and_traversing/i1klkty/,1647892663,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
495.0,[],False,,dontchooseanickname,,,[],,,,text,t2_idajg,False,False,"Can you show some code ?

- I can't understand if you're just _solving_ non-functional problems
- Or if you're actually really trying to make a step by step IO program where not necessary

For instance writing a Wordle solver is hard to write in _imperative style only_, the whole ""find words matching all previous knowledge deduced from past incorrect answers"" .. can't be written in imperative style. It has to be functional : It literally has to be a single function",94ea322372155388dc60b57cd531ae98ca4512b0,True,False,,,,,0,1647888713,,0,{},i1kbvqp,False,t3_tjforr,False,True,t3_tjforr,/r/haskell/comments/tjforr/writing_proper_haskell_code/i1kbvqp/,1647888727,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
496.0,[],False,,VincentPepper,,,[],,,,text,t2_dwxl7,False,False,"Int# is always as wide as the machines native word size (32/64bit) if that's what you mean. 

Where it got funky was that eg. Int8 was represented by a full Word operations were done on the full word, but we would zero/ignore the high bits so that the value would always be in the correct bounds.",288b29eecf67d432bbaa25d2e6e88278629f3c19,True,False,,,,,0,1647887671,,0,{},i1k98ef,False,t3_thtrew,False,True,t1_i1dbm1w,/r/haskell/comments/thtrew/wordcompat_supporting_word8_and_the_like_with_no/i1k98ef/,1647887682,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
497.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,https://lorepub.com/product/haskellbook,b9b3e5357335bd8bbb21cd622893e195a4f55edb,True,False,,,,,0,1647881242,,0,{},i1jsoqh,False,t3_tjforr,False,True,t1_i1jqo2l,/r/haskell/comments/tjforr/writing_proper_haskell_code/i1jsoqh/,1647881255,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
498.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,Use an existing one? https://hoogle.haskell.org/?hoogle=%28Integer%2C+b%2C+c%29+-%3E+Integer&amp;scope=set%3Astackage,49b82d15d99d59c5580c044515338fa0db546fae,True,False,,,,,0,1647881024,,0,{},i1js4g9,False,t3_t3zw0x,False,True,t1_i1jhurs,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1js4g9/,1647881038,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
499.0,[],False,,rhl120,,,[],,,,text,t2_6cjrymqf,False,False,Thanks. From where can I download a PDF,23ce809477196cabe4f909e7caa2d8218163d278,True,False,,,,,0,1647880464,,0,{},i1jqo2l,True,t3_tjforr,False,True,t1_i1jq0sm,/r/haskell/comments/tjforr/writing_proper_haskell_code/i1jqo2l/,1647880482,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
500.0,[],False,,MorrowM_,,,[],,,,text,t2_6l7exkda,False,False,"You can use pattern matching. `let (first, _, _) = myFun foo in ...`",74ef3663b1af303aabc6ff0fb6817a2ce38add58,True,False,,,,,0,1647880288,,0,{},i1jq787,False,t3_t3zw0x,False,True,t1_i1jhurs,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1jq787/,1647880301,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
501.0,[],False,,dun-ado,,,[],,,,text,t2_ihltqlra,False,False,You may want to go through or use as reference https://haskellbook.com/progress/.,b291363d50ddd5ccc899e9f2baa636c50d1f87a8,True,False,,,,,0,1647880219,,0,{},i1jq0sm,False,t3_tjforr,False,True,t3_tjforr,/r/haskell/comments/tjforr/writing_proper_haskell_code/i1jq0sm/,1647880233,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
502.0,[],False,,rhl120,,,[],,,,text,t2_6cjrymqf,False,False,Thanks I will check it out.,e0c258b854411623f9d5b814561ce395084a3d2b,True,False,,,,,0,1647880210,,0,{},i1jpzzc,True,t3_tjforr,False,True,t1_i1jpx7m,/r/haskell/comments/tjforr/writing_proper_haskell_code/i1jpzzc/,1647880225,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
503.0,[],False,,paretoOptimalDev,,,[],,,,text,t2_fjx3p3ff,False,False,"I think this presentation might help:

https://speakerdeck.com/ajnsit/supercharged-imperative-programming-with-haskell-and-fp",3cac8b24e01f83f0835fb5202a0b37609a0d1df7,True,False,,,,,0,1647880180,,0,{},i1jpx7m,False,t3_tjforr,False,True,t3_tjforr,/r/haskell/comments/tjforr/writing_proper_haskell_code/i1jpx7m/,1647880194,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
504.0,[],False,,josephcsible,,,[],,,,text,t2_14phjb,False,False,"I'm always in favor of this kind of generalization. The only time there's ever a question for me is when there's multiple orthogonal ways to generalize something. For example, `concat` can be generalized to `join`, `fold`, or `asum`.",dfc230cfba2977e86313c02b7722433b010b0746,True,False,,,,,0,1647879993,,0,{},i1jpfz3,False,t3_t3zw0x,False,False,t1_i1djzl4,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1jpfz3/,1647880007,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
505.0,[],False,,TheActualMc47,,,[],,,,text,t2_om5ms0g,False,False,"I've been AFK for a couple of days, and there's nothing wrong with arguing! We're all learning together.

&gt;there is no such thing as ""compiler magic""

Well... there absolutely is: conceptually, IO is just like State, but the State is a type called ""RealWorld"". How to exactly act on that type and how to use it, isn't something that is written in Haskell itself, but actually is handled by GHC.

The `liftM2` function has no assumptions on how the underlying monad works, and it does the most generic thing of binding the arguments and returning the result of the given function. It knows nothing about the function, the arguments, or even the monad. So your question isn't about how `liftM2` breaks laziness, it's about why the bind operator acts the way it is. And as pointed out by u/dagit and u/anydalch, the key point is that values are different from side-effects. If we're in the state monad, and m1 and m2 change the state in some way, and you don't force the state to be evaluated, it won't be computed. u/anydalch's comment where the definitions are expanded is a perfect way to illustrate that.

Are there instances where you want the function to shortcut? Absolutely! But you can't use `liftM2` for that, you need a special function for your case, as the `mAnd` you wrote. Unlike `liftM2`, this function needs to know the context.",b97331bf10c703a176c813004560338a05a4df75,True,False,,,,,0,1647878730,,0,{},i1jm6lz,False,t3_tfqpeg,False,True,t1_i170e66,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i1jm6lz/,1647878744,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
506.0,[],False,,CyborgDennet,,,[],,,,text,t2_11m18v,False,False,"I got a function with output (Integer, Integer, Integer)

In another function i use this function, but only want the first integer.

How do I get the first integer without writing a function for it?",4551863d0b43bf3ff9261d42d6f8c6925091d25b,True,False,,,,,0,1647877008,,0,{},i1jhurs,False,t3_t3zw0x,False,True,t3_t3zw0x,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1jhurs/,1647877024,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
507.0,[],False,,libeako,,,[],,,,text,t2_vs0ts,False,False,"I wrote [a free book](https://drive.google.com/drive/folders/1kiFr_OGXP6olNQjmShaPeCXiKhnA08Rp?usp=sharing) for this exact purpose. 

I need to revise it +1 time, but i think it is already readable. 

Feedback would help me in further improvement of the text.",e3958365acbe6c2d4e534c2de765da48fd2755e3,True,False,,,,,0,1647873560,,0,{},i1j9kuv,False,t3_tj5lcz,False,True,t3_tj5lcz,/r/haskell/comments/tj5lcz/best_resources_for_highlevel_explanations_of/i1j9kuv/,1647873577,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
508.0,[],False,,themilitia,,,[],,,,text,t2_qthfz,False,False,"Idk, 50 bucks is pretty good for a conference.",cdbc71aeb0784b54189f17b8145e64fe8e2aea78,True,False,,,,,0,1647873323,,0,{},i1j9168,False,t3_telf9t,False,True,t1_i16qwbo,/r/haskell/comments/telf9t/haskellers_functional_conf_2022_is_online_and/i1j9168/,1647873337,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
509.0,[],False,,sjakobi,,,[],,,,text,t2_sbvuw,False,False,"Ah, sorry, I hadn't seen that announcement. I'm not familiar with that new automation.",61ed9d6b4b17d24866dab68b8656f813805b3652,True,False,,,,,0,1647868141,,0,{},i1ixyov,False,t3_tj0496,False,True,t1_i1iq1mr,/r/haskell/comments/tj0496/stack_lts_19_release_and_nightly_on_ghc92/i1ixyov/,1647868154,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
510.0,[],False,,ulysses4ever,,,[],,,,text,t2_68b11,False,False,"Thanks! I was particularly curious about the phrase in #6486 (referenced from the blog post):

&gt; We've also added further automation to detect when packages get fixed so that we can re-enable them automatically.

I wonder if this automation will notice a revision or only a version bump.",9a5db7639fe8d2b082cf9a7b519fbc96a72cf207,True,False,,,,,0,1647863629,,0,{},i1iq1mr,False,t3_tj0496,False,True,t1_i1hgv1u,/r/haskell/comments/tj0496/stack_lts_19_release_and_nightly_on_ghc92/i1iq1mr/,1647863643,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
511.0,[],False,,flavortownXpress,,,[],,,,text,t2_dxklpceb,False,False,"Looks great, thanks",226352f541307db1ce6737e368e4899d44bc8cad,True,False,,,,,0,1647848902,,0,{},i1i7oza,True,t3_tj5lcz,False,True,t1_i1i6od1,/r/haskell/comments/tj5lcz/best_resources_for_highlevel_explanations_of/i1i7oza/,1647848916,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
512.0,[],False,,SnooRecipes5458,,,[],,,,text,t2_5rfmilp1,False,False,The defunct podcast LambdaCast has some very good content for this https://soundcloud.app.goo.gl/5PTsPUrJNs3C3u766,dea3a531f7962a106248f1759ad9ed59e78425be,True,False,,,,,0,1647848023,,0,{},i1i6od1,False,t3_tj5lcz,False,True,t3_tj5lcz,/r/haskell/comments/tj5lcz/best_resources_for_highlevel_explanations_of/i1i6od1/,1647848040,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
513.0,[],False,,Ok-Contest7468,,,[],,,,text,t2_3k12xk2l,False,False,"I solved this issue on Arch Linux by removing the dynamically linked version of ghc and installing the statically linked ghc-static, along with haskell-language-server-static.",bf0c36d9c683345a4d23539834eeb73720b02923,True,False,,,,,0,1647834544,,0,{},i1hnwam,False,t3_t3qq0i,False,True,t3_t3qq0i,/r/haskell/comments/t3qq0i/haskell_language_server_is_broken_after_vscode/i1hnwam/,1647834560,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
514.0,[],False,,absence3,,,[],,,,text,t2_lha7l,False,False,"Great news! Does anyone know how bad this [GC crash bug](https://gitlab.haskell.org/ghc/ghc/-/issues/20959) is? Is it better to wait for 9.0.3 for production use, or does it only happen in very specific situations?",ddbf3bda4e4ff5140e8b14759fca83b3f96d4447,True,False,,,,,0,1647831140,,0,{},i1hhhcf,False,t3_tj0496,False,True,t3_tj0496,/r/haskell/comments/tj0496/stack_lts_19_release_and_nightly_on_ghc92/i1hhhcf/,1647831151,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
515.0,[],False,,sjakobi,,,[],,,,text,t2_sbvuw,False,False,"AFAIK Stackage takes Hackage revisions into account.

Someone will have to remove the `&lt; 0` bound though. That can be you or someone else.",15d816187ebbe3209e199f0035e9fa1c8371ca47,True,False,,,,,0,1647830828,,0,{},i1hgv1u,False,t3_tj0496,False,True,t1_i1hg3eo,/r/haskell/comments/tj0496/stack_lts_19_release_and_nightly_on_ghc92/i1hgv1u/,1647830839,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
516.0,[],False,,ulysses4ever,,,[],,,,text,t2_68b11,False,False,"does anyone know: if my package got  &lt; 0 on Stackage nightly because of dependency bound, will it suffice to revise metadata on Hackage to have it back? I vaguely remember that Stackage infrastructure is not keen of revisions.",59a33ba8203a6ddc0b4e4872c03ecccaa0399027,True,False,,,,,0,1647830438,,0,{},i1hg3eo,False,t3_tj0496,False,True,t3_tj0496,/r/haskell/comments/tj0496/stack_lts_19_release_and_nightly_on_ghc92/i1hg3eo/,1647830455,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
517.0,[],False,,Syncopat3d,,,[],,,,text,t2_5qs9j,False,False,Thanks for the hard work. It's been a long wait and I'm looking forward to finally trying out the new record handling syntax in GHC 9.2.,10eb6352a38b4eb99b0988b8760211a2ec160ad8,True,False,,,,,0,1647828057,,0,{},i1hb9su,False,t3_tj0496,False,True,t3_tj0496,/r/haskell/comments/tj0496/stack_lts_19_release_and_nightly_on_ghc92/i1hb9su/,1647828074,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
518.0,[],False,,taylorfausak,,,[],,,,text,t2_4hurx,False,False,This was caught in moderation for a couple days. A more recent post made it through: https://www.reddit.com/r/haskell/comments/tj0496/stack_lts_19_release_and_nightly_on_ghc92/,fce27c7524ecff029304ba7040b2ef6beaff2cad,True,False,,,,,0,1647826338,moderator,0,{},i1h7po4,False,t3_th6zme,False,True,t3_th6zme,/r/haskell/comments/th6zme/stackage_lts_190_is_released_with_ghc_902/i1h7po4/,1647826351,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
519.0,[],False,,sullyj3,,,[],,,,text,t2_5b0kp,False,False,"I think it's at least partially a documentation issue tbh. I've been struggling a bit with the exposition in the book. I wish there were more minimal examples for getting stuff done, as well as the existing in-depth examples that take full advantage of every feature.",778cf044a194d2e0d10f5ce5ae1111967e0343d4,True,False,,,,,0,1647818333,,0,{},i1gqp3d,True,t3_tigsot,False,True,t1_i1fd96l,/r/haskell/comments/tigsot/confused_about_design_of_yesod_form_api/i1gqp3d/,1647818350,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
520.0,[],False,,sullyj3,,,[],,,,text,t2_5b0kp,False,False,"&gt;But you can grab the field data without making a form:   
&gt;  
&gt;https://hackage.haskell.org/package/yesod-core-1.6.21.0/docs/Yesod-Core-Handler.html#g:6

Ah, I was too hasty. Thanks, that's good info. I'm not familiar with Django forms.",588d3eb348698225f31e93e20cdca2ce07d87356,True,False,,,,,0,1647818149,,0,{},i1gqaje,True,t3_tigsot,False,True,t1_i1dzzdx,/r/haskell/comments/tigsot/confused_about_design_of_yesod_form_api/i1gqaje/,1647818161,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
521.0,[],False,,dreixel,,,[],,,,text,t2_378rf,False,False,Fully remote is possible.,261d5747c97082482ab1165b31f48691448e966a,True,False,,,,,0,1647812934,,0,{},i1gec8n,True,t3_tinwvw,False,True,t1_i1gasdl,/r/haskell/comments/tinwvw/haskell_internships_with_standard_chartered_bank/i1gec8n/,1647812951,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
522.0,[],False,,tobz619,,,[],,,,text,t2_13erzn,False,False,Are the positions remote or hybrid?,6c6bdf431bc10772595c554c320be95d650c39d6,True,False,,,,,0,1647811420,,0,{},i1gasdl,False,t3_tinwvw,False,True,t3_tinwvw,/r/haskell/comments/tinwvw/haskell_internships_with_standard_chartered_bank/i1gasdl/,1647811434,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
523.0,[],False,,NNOTM,,,[],,,,text,t2_6ztbu,False,False,"Oh, that looks really good, thank you!",cdb121f1826f802acfb47c88ac3bd099fc03211b,True,False,,,,,0,1647809114,,0,{},i1g5ahx,True,t3_ti4nci,False,True,t1_i1g1xlt,/r/haskell/comments/ti4nci/utility_to_print_anything_with_a_data_instance/i1g5ahx/,1647809128,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
524.0,[],False,,isovector,,,[],,,,text,t2_pir4g,False,False,"If you're working in GHC specifically, you might be interested in [`GHC.Hs.Dump.showAstData`](https://hackage.haskell.org/package/ghc-9.2.1/docs/GHC-Hs-Dump.html#v:showAstData)",43fde4ffb94731dc638e2ddc0fca6eda40f689dd,True,False,,,,,0,1647807697,,0,{},i1g1xlt,False,t3_ti4nci,False,True,t3_ti4nci,/r/haskell/comments/ti4nci/utility_to_print_anything_with_a_data_instance/i1g1xlt/,1647807708,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
525.0,[],False,,WarDaft,,,[],,,,text,t2_cspxi,False,False,"There's always the inversion under CPS, that is:

    divSafe p q s f | q == 0 = f | otherwise = s (p/q)

At some point, you do have to handle what to do if the case you don't want happens. You either handle it before divSafe, during it, or after.

Another option is Either, so you can tell more about what happened when things went off the rails.

If you have the option of just throwing away bad cases, there's stuff like `catMaybes` where you get all the successful results from the list ignoring the rest... but you usually care about cases where things have gone wrong to at least some extent.",38002ece6d6a479e5ec3b5469594e69a2ce33713,True,False,,,,,0,1647805523,,0,{},i1fwwho,False,t3_tfkteo,False,True,t3_tfkteo,/r/haskell/comments/tfkteo/is_there_a_better_pattern_for_return_just_some/i1fwwho/,1647805542,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
526.0,[],False,,ludvikgalois,,,[],,,,text,t2_dul9o,False,False,"I don't know too much about Mac. It's finding `netinit/tcp.h`, but `SOL_TCP` isn't in there. I'm guessing these options are Linux specfic. [This StackOverflow post](https://stackoverflow.com/questions/15860127/how-to-configure-tcp-keepalive-under-mac-os-x) makes me think that you need to set different options (perhaps this lack of portability is why it's not in `Network.Socket`?).
You'll probably need to find some Mac specific docs on how to make keepalive do what you want.",5022550faea7a20781c1d80dea2d8f0711930524,True,False,,,,,0,1647800636,,0,{},i1flhgp,False,t3_tilhpz,False,True,t1_i1fduqi,/r/haskell/comments/tilhpz/haskell_network_library_tcp_keepalive_parameters/i1flhgp/,1647800648,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
527.0,[],False,,NNOTM,,,[],,,,text,t2_6ztbu,False,False,"The basic idea is that often you write a lot of boilerplate code to traverse through a data structure that has nothing to with what you actually want to do to the data structure.

So `Data` provides a general way to do that for any type with a `Data` instance.

An example of where I used this is again with ghc's AST, I wanted to return the exact same expression except when I encounter one particular kind of expression, I want to change it in some way. `Data` makes it pretty easy to do that first part, regardless of how many types your AST consists of, and then you can focus your effort only on actually making the change you need.

The original paper is [here](https://www.microsoft.com/en-us/research/wp-content/uploads/2003/01/hmap.pdf), though they use `Term` rather than `Data`.",83a9b0997ca3c653c17a3bd8afcacf054b084bab,True,False,,,,,0,1647799444,,0,{},i1filac,True,t3_ti4nci,False,True,t1_i1fehjw,/r/haskell/comments/ti4nci/utility_to_print_anything_with_a_data_instance/i1filac/,1647799456,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
528.0,[],False,,paulstelian97,,,[],,,,text,t2_103opj,False,False,"So basically Data just gives it some sort of reflection/runtime introspection ability. Nice, wasn't aware of it.

Always gotta learn!",3468b90e18ab9e971b33afc36f4643bf5e81bca2,True,False,,,,,0,1647799189,,0,{},i1fhyoc,False,t3_ti4nci,False,True,t1_i1fhnei,/r/haskell/comments/ti4nci/utility_to_print_anything_with_a_data_instance/i1fhyoc/,1647799205,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
529.0,[],False,,affinehyperplane,,,[],,,,text,t2_12xogr,False,False,"When some type is `Data`, you can think of it as supporting runtime reflection (like in e.g. Java), so you can print its name (which just needs `Typeable`, which `Data` extends), list/modify/update fields/constructors, construct it, and cast to it from unknown values.

Therefore, it is extremely flexible, but also by nature very weakly typed, and does not have the best performance as everything is opaque.",eee9477d2ba092cc27aa04316ec28780e6d9ab34,True,False,,,,,0,1647799064,,0,{},i1fhnei,False,t3_ti4nci,False,True,t1_i1fehjw,/r/haskell/comments/ti4nci/utility_to_print_anything_with_a_data_instance/i1fhnei/,1647799076,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
530.0,[],False,,the_state_monad,,,[],,,,text,t2_6cjla307,False,False,I understand. Thnx for the quick reply,b1d6b810ec75b3419b4bbafddf9f6dbac8b3fd25,True,False,,,,,0,1647798850,,0,{},i1fh4hs,False,t3_tinwvw,False,True,t1_i1ezst2,/r/haskell/comments/tinwvw/haskell_internships_with_standard_chartered_bank/i1fh4hs/,1647798867,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
531.0,[],False,,paulstelian97,,,[],,,,text,t2_103opj,False,False,"Sorry for going slightly-off-topic (Haskell fan but noob here): what does the Data class even mean in the first place? As in, intuition rather than details.",2ccfa1080db25ac0441bb03e8b13e1456729232e,True,False,,,,,0,1647797785,,0,{},i1fehjw,False,t3_ti4nci,False,True,t3_ti4nci,/r/haskell/comments/ti4nci/utility_to_print_anything_with_a_data_instance/i1fehjw/,1647797800,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
532.0,[],False,,epoberezkin,,,[],,,,text,t2_13t18x,False,False,"It does not seem to find netinet/tcp.h on Mac:

/var/folders/cb/q9yg95\_s3fq47zqp76x254940000gn/T/ghc11893\_0/ghc\_7.c:9:120: error:  
error: use of undeclared identifier 'SOL\_TCP'  
  |  
9 | HsInt32 ghczuwrapperZC0ZCsimplexmqzm1zi0zi3zminplaceZCSimplexziMessagingziTransportziKeepAliveZCSOLzuTCP(void) {return SOL\_TCP;}  
  |                                                                                                                        \^  
HsInt32 ghczuwrapperZC0ZCsimplexmqzm1zi0zi3zminplaceZCSimplexziMessagingziTransportziKeepAliveZCSOLzuTCP(void) {return SOL\_TCP;}",49f555f22521744ae2ba3288062b39787cdb24f3,True,False,,,,,0,1647797528,,0,{},i1fduqi,True,t3_tilhpz,False,True,t1_i1er7ar,/r/haskell/comments/tilhpz/haskell_network_library_tcp_keepalive_parameters/i1fduqi/,1647797541,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
533.0,[],False,,dpwiz,,,[],,,,text,t2_4xjof,False,False,"It is possible to keep it low-level/minimal with Yesod, but you need (evidently, per OP) some experience to distinguish obligatory parts (which are fundamental) from merely opinionated, which you are free to sidestep.",b0b224b9b9921c20cd351194b2aa70c361ce4759,True,False,,,,,0,1647797285,,0,{},i1fd96l,False,t3_tigsot,False,True,t1_i1fa6ip,/r/haskell/comments/tigsot/confused_about_design_of_yesod_form_api/i1fd96l/,1647797295,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
534.0,[],False,,ephrion,,,[],,,,text,t2_4y723,False,False,"Disagree that DIY means you should do `Spock` (which has far more complicated type-level machinery) or `scotty` (which forces more of a Haskell understanding of things and loses a lot of type safety benefits). Building a minimal DIY experience with Yesod is rather pleasant - while the default experience with the templates is batteries-included, you're absolutely free to start from scratch and [have a minimal site](https://github.com/parsonsmatt/yesod-minimal/blob/master/src/Minimal.hs) which still has good type safety and smart defaults for a lot of web stuff.",0a3540ec194bf31267204d4b003268b86991ed39,True,False,,,,,0,1647796056,,0,{},i1fa6ip,False,t3_tigsot,False,True,t1_i1dzzdx,/r/haskell/comments/tigsot/confused_about_design_of_yesod_form_api/i1fa6ip/,1647796069,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
535.0,[],False,,dreixel,,,[],,,,text,t2_378rf,False,False,"No, but you will have to be in the UK to actually do the work, and I do not think we can cover relocation or visa application for these internships (which means you also need to have the right to work in the UK).",62958b3a0823f7545286163eb07c4d2ab470accb,True,False,,,,,0,1647791947,,0,{},i1ezst2,True,t3_tinwvw,False,True,t1_i1ezmvw,/r/haskell/comments/tinwvw/haskell_internships_with_standard_chartered_bank/i1ezst2/,1647791957,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
536.0,[],False,,the_state_monad,,,[],,,,text,t2_6cjla307,False,False,Do you have to live in the UK to apply?,67b6800c78bc7a26dc686866eeef05ebc3c45a4f,True,False,,,,,0,1647791878,,0,{},i1ezmvw,False,t3_tinwvw,False,True,t3_tinwvw,/r/haskell/comments/tinwvw/haskell_internships_with_standard_chartered_bank/i1ezmvw/,1647791891,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
537.0,[],False,,man-vs-spider,,,[],,,,text,t2_5by84,False,False,"Thanks for your response, I will try testing how different methods compare",97b62b6979c71a7ad66b73d8ab22b37f4b24f2b8,True,False,,,,,0,1647790922,,0,{},i1exd25,True,t3_ti9c0n,False,True,t1_i1d3phz,/r/haskell/comments/ti9c0n/what_is_a_good_data_type_for_doing_initial_value/i1exd25/,1647790939,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
538.0,[],False,,the-coot,,,[],,,,text,t2_1t3hztq2,False,False,"If the network package does not provide that option for you, it's extensible; you can define a pattern synonym yourself or use `SockOpt` constructor directly. Here's an [example](https://github.com/input-output-hk/ouroboros-network/blob/master/network-mux/src/Network/Mux/TCPInfo/Linux.hsc#L28).  The option number, on linux, is defined in `/usr/include/linux/tcp.h` header.

For the option value, the tcp man page says it should be a pointer to a machine int (see `man tcp`). So you don't even need to define a type with a `Storable` instance for that to work.  I believe you can just use `CInt` type.

All together, this should work for you
```
setSocketOpt sock (SockOpt 6 5) (CInt 10) 
```",76af064c8f0608f51b9d3ba9a8592f031e1e270b,True,False,,,,,0,1647789666,,0,{},i1eudvq,False,t3_tilhpz,False,True,t3_tilhpz,/r/haskell/comments/tilhpz/haskell_network_library_tcp_keepalive_parameters/i1eudvq/,1647789683,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
539.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"    fromEither :: (Either a b -&gt; c) -&gt; (a -&gt; c, b -&gt; c)
    fromEither f = (f . Left, f . Right)

    toEither :: (a -&gt; c, b -&gt; c) -&gt; Either a b -&gt; c
    toEither = uncurry either",7249daf517bf8bd9c0f03bf210dc2bf050baedbd,True,False,,,,,0,1647789027,,0,{},i1eswdb,False,t3_ti2eaa,False,True,t1_i1d4blo,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1eswdb/,1647789044,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
540.0,[],False,,epoberezkin,,,[],,,,text,t2_13t18x,False,False,"Fantastic - thank you so much, I was hoping it would be something like it - will try it now!

Do you maybe know why it returns different values for SO_KEEPALIVE after I set it (also different in the client and in the server)?

Also - am I right that it won’t hurt setting it in both server and client, or I only need it in the client?

Thank you!",0202a40908c376c31a46f48a557740cc7008cc2e,True,False,,,,,0,1647788783,,0,{},i1escia,True,t3_tilhpz,False,True,t1_i1er7ar,/r/haskell/comments/tilhpz/haskell_network_library_tcp_keepalive_parameters/i1escia/,1647788794,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
541.0,[],False,,ludvikgalois,,,[],,,,text,t2_dul9o,False,False,"The library doesn't seem to expose them, but a `SockOpt` is a pair of level and an opt name, so if you can't find an adequate answer, you can always do something like

    {-# Language CApiFFI #-}

    import Network.Socket
    import Foreign.C (CInt)

    foreign import capi ""netinet/tcp.h value TCP_KEEPCNT"" tcpKeepCnt :: CInt
    foreign import capi ""netinet/tcp.h value TCP_KEEPIDLE"" tcpKeepIdle :: CInt
    foreign import capi ""netinet/tcp.h value TCP_KEEPINTVL"" tcpKeepIntvl :: CInt
    foreign import capi ""netinet/tcp.h value SOL_TCP"" solTcp :: CInt

    setTcpKeepCnt :: Socket -&gt; Int -&gt; IO ()
    setTcpKeepCnt sock = setSocketOption sock (SockOpt solTcp tcpKeepCnt)",5748f43237291c301a6a4a4ba28a13661e8c5ff6,True,False,,,,,0,1647788282,,0,{},i1er7ar,False,t3_tilhpz,False,True,t3_tilhpz,/r/haskell/comments/tilhpz/haskell_network_library_tcp_keepalive_parameters/i1er7ar/,1647788293,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
542.0,[],False,,NNOTM,,,[],,,,text,t2_6ztbu,False,False,"That would produce the expression as written down in the source file, but unfortunately isn't very useful when trying to understand the structure of the AST",c9b8f42c9d5ed3f07d5faa6c2e464445b23d760f,True,False,,,,,0,1647788110,,0,{},i1eqtsm,True,t3_ti4nci,False,True,t1_i1ek9kz,/r/haskell/comments/ti4nci/utility_to_print_anything_with_a_data_instance/i1eqtsm/,1647788130,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
543.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"As for as interface, I think it's often good to expose both.  I know when I'm writing an application, sometimes I'll have bindings that are just there to give a more specific type and app-specific contextual name to something from a library.  Making something easier to find from hoogle or making something have better type inference are both clear wins, and maintenance burden is likely to stay low.

On the implementation side, I generally don't think it's worth it to replace a one-liner with use of a more general symbol nor vice-versa.  Like you say, the DRY advantages are small with such small code.  That said, I have ended up writing several lines and a local helper function for something that turned out to be `traverse` -- one I realized to could really simplify the code, I had no hesitation in doing so.  On the flip side, you may need to manually inline or specialize or both to get the performance you want, and that may justify any potential future maintenance burden.",f243a2fe5f6440e71cbd012e7a81ad7800405ae9,True,False,,,,,0,1647787169,,0,{},i1eoqux,False,t3_t3zw0x,False,True,t1_i1djzl4,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1eoqux/,1647787183,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
544.0,[],False,,kindaro,,,[],,,,text,t2_pcbvq,False,False,Cool!,33754244c02265dc24dfec91d64a48410ec24831,True,False,,,,,0,1647785639,,0,{},i1elg6d,False,t3_ti2eaa,False,True,t1_i1celze,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1elg6d/,1647785652,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
545.0,[],False,,day_li_ly,,,[],,,,text,t2_5ti04om6,False,False,I remember that there is specifically an `Outputable` typeclass in GHC that allows you to pretty-print GHC values. Can you use that instead?,e63ffe457195987b78852a1da83f1f77ec5a40c9,True,False,,,,,0,1647785069,,0,{},i1ek9kz,False,t3_ti4nci,False,True,t3_ti4nci,/r/haskell/comments/ti4nci/utility_to_print_anything_with_a_data_instance/i1ek9kz/,1647785079,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
546.0,[],False,,mordae_with_box,,,[],,,,text,t2_jlgh3,False,False,"Forms can be validated. Validations should be run after a POST, but not when the form is being created at first. Otherwise you would have ""This field is required."" errors all over the place.

Forms could also be for editing an existing entity. Meaning they should have some defaults that are applied only when the form is created at first, but not when it parses POST data.

Then there are not only simple types such as inputs and text areas, but also multi-selects.

Finally, you want to be able to use forms with different CSS frameworks.
Add all of these requirements together and then try to design a decent interface yourself. Even Django forms fall short in various ways. It's quite a hard problem that has no clear solution.",02b08b76c9b5f8cca70318975dadf24d4378d876,True,False,,,,,0,1647784918,,0,{},i1ejye6,False,t3_tigsot,False,True,t3_tigsot,/r/haskell/comments/tigsot/confused_about_design_of_yesod_form_api/i1ejye6/,1647784934,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
547.0,[],False,,ocramz_,,,[],,,,text,t2_jaolcjrr,False,False,Also consider the recently-revived [https://hackage.haskell.org/package/rungekutta2](https://hackage.haskell.org/package/rungekutta2),867d65eb0188ed6a5430d0d645ede1b9bb21f4e2,True,False,,,,,0,1647777283,,0,{},i1e6szk,False,t3_ti9c0n,False,True,t3_ti9c0n,/r/haskell/comments/ti9c0n/what_is_a_good_data_type_for_doing_initial_value/i1e6szk/,1647777294,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
548.0,[],False,,dpwiz,,,[],,,,text,t2_4xjof,False,False,"There is a *lot* of code omitted by `# do things with username and password`, like validation and error messages.

Basically `yesod-forms` are Django forms.

But you can grab the field data without making a form: https://hackage.haskell.org/package/yesod-core-1.6.21.0/docs/Yesod-Core-Handler.html#g:6

PS: If you want DIY things like this, Flask-style, you'd better take [Spock](https://hackage.haskell.org/package/Spock), [scotty](https://hackage.haskell.org/package/scotty) or something like that.",f58cf2dc192563d004b91ea8c2b153a03e9f293e,True,False,,,,,0,1647771895,,0,{},i1dzzdx,False,t3_tigsot,False,True,t3_tigsot,/r/haskell/comments/tigsot/confused_about_design_of_yesod_form_api/i1dzzdx/,1647771908,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
549.0,[],False,,kindaro,,,[],,,,text,t2_pcbvq,False,False,Thanks!,1da20795f84bb9c5e16697aea34f14720e38fc37,True,False,,,,,0,1647767325,,0,{},i1dum8o,False,t3_ti2eaa,False,True,t1_i1d4blo,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1dum8o/,1647767339,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
550.0,[],False,,kindaro,,,[],,,,text,t2_pcbvq,False,False,Cool! Is there a standard reference?,368540c9c5ebfb48d3888d8efa0e49e38b881d7f,True,False,,,,,0,1647767138,,0,{},i1dueif,False,t3_ti2eaa,False,True,t1_i1ckhg3,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1dueif/,1647767153,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
551.0,[],False,,on_hither_shores,,,[],,,,text,t2_jnsj1me6,False,False,"No, adjoints don't have to exist. For endofunctors on Hask, they typically won't: all right adjoints are isomorphic to `x -&gt;`, and all left adjoints are isomorphic `(x,)`. The interesting behavior is happening one level up, in [Hask, Hask]",90cf69f19ed9de3b9d5edaa1f2f714829d9f7d03,True,False,,,,,0,1647767060,,0,{},i1dub6p,False,t3_ti2eaa,False,True,t1_i1dqu01,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1dub6p/,1647767076,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
552.0,[],False,,skyb0rg,,,[],,,,text,t2_83z9i,False,False,"Thanks for the link! That answers my question about the “dual” relationship, especially why it’s lopsided.

&gt;	Furthermore, comonadic programs are in one-to-one correspondence to monadic programs

Does this mean that every Comonad w has a corresponding right adjoint Monad? Or just that if it does then the laws work out. The wording seems to imply the former but the context seems to imply the latter.",5c927ab235a2200b4053ff5b3d7e51afdfcd4df3,True,False,,,,,0,1647764017,,0,{},i1dqu01,True,t3_ti2eaa,False,True,t1_i1bz13b,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1dqu01/,1647764028,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
553.0,[],False,,leighscullyyang,,,[],,,,text,t2_jddda4f8,False,False,"I like this. At some point, we need to be considerate of the computational model. And even in something as declarative as the lambda calculus, different reduction strategies matter in whether a term is normalizing or not.

You might also enjoy this article http://tutorials.jenkov.com/the-declarative-delusion.html",8239fb72ebde45775f76fb5ad4f03b09c53c1d69,True,False,,,,,0,1647763105,,0,{},i1dpsgj,True,t3_tgmr1x,False,True,t1_i15hqy3,/r/haskell/comments/tgmr1x/the_imperative_bit_in_functional_programming_is/i1dpsgj/,1647763119,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
554.0,[],False,,SolaTotaScriptura,,,[],,,,text,t2_5dpnr08,False,False,"What are your thoughts on ""unnecessary generalisation""? For example, I have this definition:

    toParser = Parser $ \s -&gt; (s, s)

OK, but then I realised `Parser` is a `Category`:

    toParser = Category.id

On the one hand, this obfuscates the definition of `toParser`, but on the other hand it points out an important equivalence. It says ""this is really an alias"". It's also DRY, but to be honest I don't think DRY is important on this scale.

So what's your stance on this? Should we express things in terms of more abstract relationships when they're available?

Another example:

I had a signature containing `Maybe`:

    Maybe a

But then I realised my definition only relies on the fact that `Maybe` is a `Monad` and an `Alternative`:

    (Monad m, Alternative m) =&gt;

This isn't that much more general. It allows `[]` and `IO`, so that's a small win. But it could lead to worse type inference and more confusing error messages.",89a70d5f1c17f591376dec3091ed39c5b135b4ea,True,False,,,,,0,1647758203,,0,{},i1djzl4,False,t3_t3zw0x,False,True,t3_t3zw0x,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1djzl4/,1647758219,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
555.0,[],False,,dagit,,,[],,,,text,t2_lj2p,False,False,"You have a lot of good tips in that blog post, but if you ever make an update there are two things I think you should add:

* Use [time-ghc-modules](https://github.com/codedownio/time-ghc-modules) to collect data about where the compiler is spending time (both which phases and which modules in your project)
* Records have several places where they cause polynomial slow down worse than linear. We're talking quadratic and I think in some cases cubic? As a result, `RecordWildCards` can be a surprising cost in compile times. At my work, we recently discovered half the compile time was spent desugaring records. Well-Typed has written a few articles on this topic and made a library specifically for large records: https://well-typed.com/blog/2021/08/large-records/",23dc1bd84e5ab67cf5d4b3da0069dee3ad654857,True,False,,,,,0,1647753905,,0,{},i1debpt,False,t3_glqlgw,False,True,t1_fqziuss,/r/haskell/comments/glqlgw/how_are_compulebuild_times/i1debpt/,1647753916,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
556.0,[],False,,someacnt,,,[],,,,text,t2_euebihog,False,False,"Oh, this is interesting. So it used to be that Int# could represent variable sizes?",ce519229f50e83fd975bfe751d29844adba439b3,True,False,,,,,0,1647752072,,0,{},i1dbm1w,False,t3_thtrew,False,True,t1_i1dbanl,/r/haskell/comments/thtrew/wordcompat_supporting_word8_and_the_like_with_no/i1dbm1w/,1647752082,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
557.0,[],False,,sjakobi,,,[],,,,text,t2_sbvuw,False,False,"See https://gitlab.haskell.org/ghc/ghc/-/wikis/migration/9.2#sized-wordint-use-sized-wordint-primitives.

Admittedly it would have been nicer to get all these changes in a single release.",41abaa97907c46894289b7d3515887aebedabd20,True,False,,,,,0,1647751861,,0,{},i1dbanl,False,t3_thtrew,False,True,t1_i1d9qxv,/r/haskell/comments/thtrew/wordcompat_supporting_word8_and_the_like_with_no/i1dbanl/,1647751881,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
558.0,[],False,,someacnt,,,[],,,,text,t2_euebihog,False,False,"Oh no, why are these breaking changes happening?",a182f11c8204c8c7955399b9b815ed8561b4e4f3,True,False,,,,,0,1647750894,,0,{},i1d9qxv,False,t3_thtrew,False,False,t1_i1ade45,/r/haskell/comments/thtrew/wordcompat_supporting_word8_and_the_like_with_no/i1d9qxv/,1647750908,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
559.0,[],False,,Toricon,,,[],,,,text,t2_zi98c,False,False,"It uses the fact that for all c, `Either a b -&gt; c` is equivalent to `(a -&gt; c , b -&gt; c)`, via case analysis.

    x + y
      &lt;=&gt; (Yoneda)
    forall c. ((x + y) -&gt; c) -&gt; c
      &lt;=&gt; (Case analysis)
    forall c. (x -&gt; c , y -&gt; c) -&gt; c",08c0e1af16fd519b1074f512449a456d414b0f95,True,False,,,,,0,1647747692,,0,{},i1d4blo,False,t3_ti2eaa,False,True,t1_i1cb4bd,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1d4blo/,1647747703,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
560.0,[],False,,viercc,,,[],,,,text,t2_13byaj,False,False,"First of all: always measure! Expect to be surprised, because ""optimizations"" you try often do not make an improve.

For answering the question, I'd say just using list is sufficient, because it's very likely that the usage of the list  as a data structure is optimized out by the compiler.

Especially, if you build the list by iterate or unfoldr and comsume by a fold (including `forM_`,) exactly once, actual list will be entirely eliminated from the compiled program.",121cf58911faded8a7b8a22928a9901fcf9cf1e2,True,False,,,,,0,1647747349,,0,{},i1d3phz,False,t3_ti9c0n,False,True,t3_ti9c0n,/r/haskell/comments/ti9c0n/what_is_a_good_data_type_for_doing_initial_value/i1d3phz/,1647747364,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
561.0,[],False,,lomendil,,,[],,,,text,t2_bs6eo,False,False,"`Seq` might be a one-step improvement over a list. If you want to get into parallel or GPU implementations, then take a look at repa, accelerate, and massiv, depending on your application.",2045befe3002016fc592fa0f995885a8baf525f5,True,False,,,,,0,1647738596,,0,{},i1cmxz2,False,t3_ti9c0n,False,True,t3_ti9c0n,/r/haskell/comments/ti9c0n/what_is_a_good_data_type_for_doing_initial_value/i1cmxz2/,1647738609,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
562.0,[],False,,ineffective_topos,,,[],,,,text,t2_2nd1rf5j,False,False,"A common example of a comonad which is not obviously a dual is Stream:  
```
data Stream a = SCons a (Stream a)
```
that is, an infinite stream of data. Similarly non-empty lists, bidrectional lists/streams, etc.

Extract takes the head of the list, whereas extend sends each element to the entire located at it.",eee6ed70600e1764f7386d8b18a9e63288177fb9,True,False,,,,,0,1647737722,,0,{},i1cl7tg,False,t3_ti2eaa,False,False,t3_ti2eaa,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1cl7tg/,1647737736,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
563.0,[],False,,on_hither_shores,,,[],,,,text,t2_jnsj1me6,False,False,"No, I just mean the context part. Haskell doesn't let you write freestanding contexts, but that doesn't mean you can't reason about them.",d461a68de775ecca7108aea85c40c0fbf66ac60c,True,False,,,,,0,1647737355,,0,{},i1ckhg3,False,t3_ti2eaa,False,True,t1_i1cidkh,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1ckhg3/,1647737369,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
564.0,[],False,,kindaro,,,[],,,,text,t2_pcbvq,False,False,"Thank you. When you say _«context»_, do you mean _«type in context»_, as in your example №2? I do not expect contexts to walk around by themselves, should I?",b150b22f2679de595447b79557f9bd43372a9833,True,False,,,,,0,1647736308,,0,{},i1cidkh,False,t3_ti2eaa,False,True,t1_i1cgtd3,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1cidkh/,1647736322,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
565.0,[],False,,fumieval,,,[],,,,text,t2_fwirv,False,False,Good to know! Writing these conversions once again by hand.would've been a pain.,2f02259612a0a41329b8057d1b102a38f6bb4f03,True,False,,,,,0,1647735970,,0,{},i1choqu,True,t3_thtrew,False,True,t1_i1ade45,/r/haskell/comments/thtrew/wordcompat_supporting_word8_and_the_like_with_no/i1choqu/,1647735986,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
566.0,[],False,,on_hither_shores,,,[],,,,text,t2_jnsj1me6,False,False,"Yeah, you're right; I was skimming and carelessly assumed that OP was unfolding a stream.",31bfe348ef9589ed6360e5126c6f0c9f2818207d,True,False,,,,,0,1647735699,,0,{},i1ch4ry,False,t3_t3zw0x,False,True,t1_i1cfjp9,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1ch4ry/,1647735714,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
567.0,[],False,,on_hither_shores,,,[],,,,text,t2_jnsj1me6,False,False,"`[Int]` is a type

`(x :: Type) . [x]` is a *type in context*.

`forall (x :: Type) . [x]` is a type again. 

The syntactic category has contexts as its objects, and substitutions of free variables as its morphisms.",7cb18409f5b47971c19b640987d2b9e665f13478,True,False,,,,,0,1647735548,,0,{},i1cgtd3,False,t3_ti2eaa,False,True,t1_i1cbl5b,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1cgtd3/,1647735563,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
568.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"Is that true even in *this* case?  Is ""codata Void"" inhabited by `id`?  Even extended to codata, I don't think the function given is total.",1723d9e09a6fa0f79341a8de33466cdbbe1a148e,True,False,,,,,0,1647734921,,0,{},i1cfjp9,False,t3_t3zw0x,False,True,t1_i1c26m1,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1cfjp9/,1647734934,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
569.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,I think it's curried Scott encoding.,b8cfba24e37f1efbb0af487c51e4318a26610680,True,False,,,,,0,1647734461,,0,{},i1celze,False,t3_ti2eaa,False,True,t1_i1cb4bd,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1celze/,1647734475,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
570.0,[],False,,kindaro,,,[],,,,text,t2_pcbvq,False,False,"Sounds cool.

Can you name the objects and arrows of these categories for me? I thought the category of types and programs is the one called _«syntactic»_ so I am now befuddled.",334ee04fc44893430a348cf31b61c4b977fded39,True,False,,,,,0,1647733004,,0,{},i1cbl5b,False,t3_ti2eaa,False,True,t1_i1c18vu,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1cbl5b/,1647733021,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
571.0,[],False,,kindaro,,,[],,,,text,t2_pcbvq,False,False,"Ha-ha, yes, no problem, now I see what you mean.

The code is not necessary.

Can we simply call this an application of the continuation passing transformation, Yoneda lemma or something like that?",73aa289d7a95420babde57f74ac0a53b511e96ff,True,False,,,,,0,1647732781,,0,{},i1cb4bd,False,t3_ti2eaa,False,True,t1_i1bs106,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1cb4bd/,1647732793,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
572.0,[],False,,Straight_Doubt2866,,,[],,,,text,t2_g5ggaddw,False,False,"&gt; What can a function do that a function pointer cannot?

You can't dynamically return a closure in C like in Haskell; at least, not using functions alone.

A curried function can't be implemented in C without using structs. In something like this:

    f :: Int -&gt; Int -&gt; Int
    f a b = a + b

Which is equivalent to this: 

    f :: Int -&gt; Int -&gt; Int
    f a = \b -&gt; a + b

You're defining the function to take an Int and return another function that takes an Int and knows about the first argument, which returns a new Int as a result of the previous two. In other words, you're creating a new, different function at runtime every time you call f with a different argument; `f 1` is a different function from `f 2`. I'm ignoring optimizations GHC might make, because I don't know much about them.

In C, you would need a struct with an int and a function pointer as members in order to capture that context. This is basically how C++ implements closures (AKA lambdas); whenever you make one, the compiler generates a new class with its captured variables as members. If it doesn't capture any variables, then it can decay into a function pointer.

I realize this is a year old, so sorry if this message confused you at first. I just happened to come across this comment and wanted to answer.",a4eb9e67a5be5940727155a13e6b34670f4a5b7b,True,False,,,,,0,1647732102,,0,{},i1c9p74,False,t3_kx2pgk,False,True,t1_gj9rp1e,/r/haskell/comments/kx2pgk/are_all_curried_function_higher_order_functions/i1c9p74/,1647732116,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
573.0,[],False,,NNOTM,,,[],,,,text,t2_6ztbu,False,False,"Oh, nice! I would have probably used that instead if I'd known about it at the time",9e48d1f7c8dc120ccfbcadce799a706df3138ebf,True,False,,,,,0,1647729149,,0,{},i1c39nf,True,t3_ti4nci,False,True,t1_i1c2k79,/r/haskell/comments/ti4nci/utility_to_print_anything_with_a_data_instance/i1c39nf/,1647729161,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
574.0,[],False,,Syrak,,,[],,,,text,t2_4atne,False,False,"I shouldn't have used ""any"" because it's ambiguous, but I actually meant it in the opposite way. ""Total"" means ""defined everywhere"". Everywhere you look, you will get a meaningful observation.

The utopia is for programs to never crash and never run into an infinite, nonresponsive loop. Sticking infinite loops in lazy tuples is going in the wrong direction.",203bb932a40c9e9edf0a60daae2265ec63b8b963,True,False,,,,,0,1647729141,,0,{},i1c38za,False,t3_t3zw0x,False,True,t1_i1bz14c,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1c38za/,1647729154,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
575.0,[],False,,affinehyperplane,,,[],,,,text,t2_12xogr,False,False,"You might also be interested in [`gshow`](https://hackage.haskell.org/package/syb-0.7.2.1/docs/Data-Generics-Text.html#v:gshow) from syb (""scrap your boilerplate"") which provides many helpful functions to simplify use cases like yours.",fe31482607835b6130c92dff33ad6093fcc1df14,True,False,,,,,0,1647728831,,0,{},i1c2k79,False,t3_ti4nci,False,True,t3_ti4nci,/r/haskell/comments/ti4nci/utility_to_print_anything_with_a_data_instance/i1c2k79/,1647728845,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
576.0,[],False,,on_hither_shores,,,[],,,,text,t2_jnsj1me6,False,False,"Properly speaking, it's a *productive* function that generates *co-data*, but laziness blurs the distinction.",c46e02a0157901f3a00983f98f4a220de8ca88cf,True,False,,,,,0,1647728658,,0,{},i1c26m1,False,t3_t3zw0x,False,True,t1_i1bz14c,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1c26m1/,1647728671,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
577.0,[],False,,on_hither_shores,,,[],,,,text,t2_jnsj1me6,False,False,"&gt; I know that theoretically every monad arises from an adjunction, but I have not found out yet what the adjunctions for Reader and Writer are. 

Every monad arises from many different adjunctions, with ""minimal"" and ""maximal"" solutions being given by the Kleisli and Eilenberg-Moore categories for the monad under consideration. These are usually not interesting though. 

In a dependently typed setting, the reader/function monad arises from the adjunction (between the category of types and the corresponding syntactic category) consisting of the dependent product on the right, and context extension (the operation of introducing a new free variable) on the left. The writer comonad arises from the dependent sum and context extension instead.",b53f57c48e4ef4b91608267f05fd15d5398562f2,True,False,,,,,0,1647728240,,0,{},i1c18vu,False,t3_ti2eaa,False,True,t1_i1blgu8,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1c18vu/,1647728251,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
578.0,[],False,,mn15104,,,[],,,,text,t2_33938rg,False,False,"Right, so im interpreting this as, as long as we can evaluate _some_ part of the function's output, the function is total, e.g.

    foo n = let f x = f x
                 in (n, f x)",dec351ba6558437bff9a3ec3c3c72113f11b7858,True,False,,,,,0,1647727260,,0,{},i1bz14c,False,t3_t3zw0x,False,True,t1_i1bxbpv,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1bz14c/,1647727271,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
579.0,[],False,,on_hither_shores,,,[],,,,text,t2_jnsj1me6,False,False,"&gt; all the Comonads (at least the ones defined in the comonads package) are duals of transformers Monad Transformers ...  wanted to know if there is a more intuition as to why this is the case

https://www.cs.ox.ac.uk/ralf.hinze/WG2.8/28/slides/ralf.pdf



&gt; Or why (-&gt;) and (,) are duals (because one is the exponential, and the other is the product); why aren’t the duals Either and (,)?

`(a,)` and `(a -&gt;)` are *adjoint*: there's an isomorphism between maps from `(a,b)` to `c` and maps from `b` to `a -&gt; c`. Duality is an overloaded term, and this is one of its meanings, but more often duality means duality with respect to reversing all the morphisms, which is the sense in which `(,)` and `Either` are dual.",27f765ae8be0c1b20c3578eb127e45a0f7ded10f,True,False,,,,,0,1647727259,,0,{},i1bz13b,False,t3_ti2eaa,False,True,t3_ti2eaa,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1bz13b/,1647727271,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
580.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"&gt; either a function that is undefined for a subset of inputs, or a function that has unproductive infinite behaviour

Those two things are really the same thing. Undefined cases are equivalent to unproductive infinite behavior. E.g. in Haskell if you leave out cases like this:

    f 1 = True

Then you are basically writing the same thing as:

    f 1 = True
    f _ = undefined

Which is also the same as:

    f 1 = True
    f x = f x

Or

    f 1 = True
    f _ = let x = x in x",8b4e6db84d29e22f383259bb0fabd227aa8c0cb2,True,False,,,,,0,1647726759,,0,{},i1bxws5,False,t3_t3zw0x,False,True,t1_i1bxf4v,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1bxws5/,1647726771,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
581.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"&gt; (Ignoring the trivial case of a partial function returning bottom)

I think every partial function must contain (an equivalent to) bottom. The only real difference can be that it can return a prefix that is not bottom, e.g. `1 : 2 : undefined`. Other than that, all partial functions are basically equivalent to bottom.",a40df7b541ad3a9d26b5333bb0f8605ac66ee8f8,True,False,,,,,0,1647726557,,0,{},i1bxgao,False,t3_t3zw0x,False,True,t1_i1bv2fl,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1bxgao/,1647726568,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
582.0,[],False,,mn15104,,,[],,,,text,t2_33938rg,False,False,"Right i see. So a partial function could be considered as either a function that is undefined for a subset of inputs, or a function that has unproductive infinite behaviour?

For example, the following would be total

    loopA n = n : loopA (n + 1)

But the following would be partial?

    loopB n = loopB (n + 1)",f3c8ec17961520a82fcf67b0342013e8ab9551fd,True,False,,,,,0,1647726543,,0,{},i1bxf4v,False,t3_t3zw0x,False,True,t1_i1bw76y,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1bxf4v/,1647726561,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
583.0,[],False,,Syrak,,,[],,,,text,t2_4atne,False,False,Ask yourself whether you could print any element in the list.,fe55d0f350dafb6e031c7ae2ee191d08bbc6e84b,True,False,,,,,0,1647726504,,0,{},i1bxbpv,False,t3_t3zw0x,False,True,t1_i1bv2fl,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1bxbpv/,1647726517,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
584.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"I think the difference is that a partial function will get completely stuck at some point without returning any output. In contrast, total functions with this infinite behavior will always keep producing pieces of the output. As long as the consumer is guaranteed to terminate (i.e. only consumes a finite prefix of the output), the whole program is guaranteed to terminate.",ab3f25299a7d2cfaa1ad1cf76a1795fbf2a3cbba,True,False,,,,,0,1647726017,,0,{},i1bw76y,False,t3_t3zw0x,False,True,t1_i1bv2fl,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1bw76y/,1647726028,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
585.0,[],False,,mn15104,,,[],,,,text,t2_33938rg,False,False,"I see, thanks a lot. With this mindset, im not sure how we tell the difference between a partial function that diverges, and a total function that has infinite behaviour?",2d03f69150b67f92c34e56ea58b623b8b6f48a15,True,False,,,,,0,1647725530,,0,{},i1bv2fl,False,t3_t3zw0x,False,True,t1_i1bnvgw,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1bv2fl/,1647725542,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
586.0,[],False,,Syrak,,,[],,,,text,t2_4atne,False,False,"A total function maps every input to an output.

Think at the level of a math 101/discrete math class. Accept that mathematical objects, infinite or not, exist on an intuitive level. You have to be careful about how to construct and manipulate things, but not necessarily to the point of spelling out what foundations (logic and axioms) you want to rely on. Then you can think of Haskell as a language to do math that's slightly more formal than English. Just as not every grammatically well-structured English sentence is meaningful, not every Haskell program is to represent a well-defined mathematical concept. But you also don't need a PhD to believe that you can `map` an infinite list to an infinite list for example.

Now if you want a formal model of the Haskell language itself, you need to handle such ""intuitively meaningless"" programs, either by somehow rejecting them, or by generalizing the notion of ""meaning"" to encompass them, and that's where notions like totality, partiality, or ""bottom"" come in. But you don't have to be a linguist to derive meaning from English, and you don't have to be a PL theorist to derive meaning from programming languages.",c2bd0e1cccd31ed68c8490de9759255359778db8,True,False,,,,,0,1647724928,,0,{},i1btowi,False,t3_t3zw0x,False,True,t1_i1atynd,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1btowi/,1647724939,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
587.0,[],False,,amalloy,,,[],,,,text,t2_6f5lu,False,False,"Ah, thanks. Yes, of course that works quite well.

    to f = f (Left, Right)",a08001b8e26ef217e029c5e43a356fdc69127fd9,True,False,,,,,0,1647724408,,0,{},i1bsi9m,False,t3_ti2eaa,False,True,t1_i1bqmpw,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1bsi9m/,1647724425,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
588.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"Whoops, I left out a `-&gt; c`.

    fromEither :: Either a b -&gt; (forall c. (a -&gt; c, b - &gt; c) -&gt; c)
    fromEither (Left x) = \(f, _) -&gt; f x
    fromEither (Right y) = \(_, g) -&gt; g y

    toEither :: (forall c. (a -&gt; c, b -&gt; c) -&gt; c) -&gt; Either a b
    toEither g = g Left Right",e4a7dbdf8356d43422741b248e48216f3c0fbf40,True,False,,,,,0,1647724198,,0,{},i1bs106,False,t3_ti2eaa,False,True,t1_i1bmxh1,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1bs106/,1647724213,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
589.0,[],False,,ThePyroEagle,,,[],,,,text,t2_jjm1c,False,False,"Pick `c ~ Either a b` to go the other way, i.e `(Left, Right)`",72d22c992694a8491cd5f6954d597f30307a9a28,True,False,,,,,0,1647723594,,0,{},i1bqmpw,False,t3_ti2eaa,False,True,t1_i1bpmnh,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1bqmpw/,1647723609,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
590.0,[],False,,amalloy,,,[],,,,text,t2_6f5lu,False,False,"I don't think they are. I see no way to go from either one of them to the other, let alone to go both ways. To me it seems more like

    Either a b = forall c. ((a -&gt; c, b -&gt; c) -&gt; c)

One direction of translation is easy:

    from :: Either a b -&gt; (forall c. ((a -&gt; c, b -&gt; c) -&gt; c))
    from (Left x) = \(f, g) -&gt; f x
    from (Right y) = \(f, g) -&gt; g y

The other one I understand but don't know how to write down formally. If you have a pair of functions, one from `a` and one from `b`, to some other type `c`, and you can produce a value of type `c`, the only explanation is that somewhere you must have a value of type `a` *o(r `b` ready to pass to one of the two functions.",2ffaf2d905e0d1b6998c9eed42b2c4387dc88dee,True,False,,,,,0,1647723171,,0,{},i1bpmnh,False,t3_ti2eaa,False,True,t1_i1bmxh1,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1bpmnh/,1647723190,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
591.0,[],False,,Syrak,,,[],,,,text,t2_4atne,False,False,"A total function is one that associates an output value to every input. The values could be finite or infinite, all that matters is that they are defined. If you accept that `Fix (ListF Double)` is a set of potentially infinite lists, then `ana coalg :: Integer -&gt; Fix (ListF Double)` is a function that maps each integer to such a list.

`ana coalg' 5` is a well-defined list. It makes just as much sense as the function `\i -&gt; 1/2^i`.

Of course, when you run code on a computer, the infinite list is not represented literally, it must be somehow encoded finitely. The beauty of functional programming is that we can just think about manipulating abstract, mathematical objects like functions and infinite lists, and we let the compiler figure out how to represent these objects concretely.

Math teaches us to be suspicious of infinity, but it's not that infinity is inherently problematic, rather the issue lies in the way we talk about it. Unless you're a finitist, but then you'd already know what you're talking about. For most people, it's completely fine to accept the existence of infinite lists and trees. One must be careful when defining operations on them, for example one can't just take the minimum of an infinite list. But rather than checking every definition from scratch, we can rely on general constructions like anamorphisms that are guaranteed to yield well-defined (total) functions.",8b00762ca96e1c41973a8ec0b6d785a10641c6fe,True,False,,,,,0,1647722413,,0,{},i1bnvgw,False,t3_t3zw0x,False,True,t1_i19ri6e,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1bnvgw/,1647722431,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
592.0,[],False,,kindaro,,,[],,,,text,t2_pcbvq,False,False,"&gt; They are, but often  `Either`
&gt;  is unpleasant to deal with, so it gets explicitly split; 
&gt; `Either a b`
&gt;  = 
&gt; `forall c. (a -&gt; c, b -&gt; c)`
&gt; , and then the pieces are manipulated individually.

How often? I have never seen this.

Can you show me how these two types are isomorphous?",778e45b8c071e2a03481cef5cd843ff8ebc50563,True,False,,,,,0,1647722003,,0,{},i1bmxh1,False,t3_ti2eaa,False,True,t1_i1bkd3z,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1bmxh1/,1647722020,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
593.0,[],False,,AshleyYakeley,,,[],,,,text,t2_92cbu,False,False,"OK, try this:

    newtype T a = MkT a

    instance {-# OVERLAPPABLE #-} Given (a -&gt; a -&gt; Bool) =&gt; Eq (T a) where
        MkT a == MkT b = given a b

    toDict :: forall a. Dict (Eq (T a)) -&gt; Dict (Eq a)
    toDict = unsafeCoerce

    withEq :: forall a r. (a -&gt; a -&gt; Bool) -&gt; (Eq a =&gt; r) -&gt; r
    withEq f r = give f $ case toDict @a Dict of
        Dict -&gt; r",f598d4c1ef77ffeaa2ea69820cafece9e591c509,True,False,,,,,0,1647721544,,0,{},i1blv83,False,t3_thaqi6,False,True,t1_i19lom5,/r/haskell/comments/thaqi6/faking_local_instances_with_unsafecoerce_dict/i1blv83/,1647721560,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
594.0,[],False,,kindaro,,,[],,,,text,t2_pcbvq,False,False,"Amazing question! I wish I had time to dive into it right now. Hopefully someone already has the answers you are looking for.

I know that theoretically every monad arises from an adjunction, but I have not found out yet what the adjunctions for `Reader` and `Writer` are. I only know that the `State`/`Store` construction arises from the tuple-arrow adjunction witnessed in Haskell by `curry` and `uncurry`. I also have no idea what the categorification of monad _transformers_ is.

So, my bit of the answer is that the arrow and the tuple are _«duals»_ because they are adjoint, and from every adjunction you get a monad and a comonad at once.",0319b8164bdec790be6bcd61ea1effbce06d9a05,True,False,,,,,0,1647721374,,0,{},i1blgu8,False,t3_ti2eaa,False,True,t3_ti2eaa,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1blgu8/,1647721386,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
595.0,[],False,,lgastako,,,[],,,,text,t2_1mp2i,False,False,Same question for SQL.,0505887be0a9cfed630a90230996df72acf5019b,True,False,,,,,0,1647721128,,0,{},i1bkwp8,False,t3_tgmr1x,False,True,t1_i17g25r,/r/haskell/comments/tgmr1x/the_imperative_bit_in_functional_programming_is/i1bkwp8/,1647721142,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
596.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"&gt; Or why (-&gt;) and (,) are duals

They aren't, but sometimes they look like they are because of currying.  `c -&gt; Dual (a, b)` is the dual of `a -&gt; b -&gt; c` = `(a, b) -&gt; c`, but so is `(c -&gt; b) -&gt; a`

&gt; why aren’t the duals Either and (,)?

They are, but often `Either` is unpleasant to deal with, so it gets explicitly split; `Either a b` = `forall c. (a -&gt; c, b -&gt; c)`, and then the pieces are manipulated individually.

--

I feel like there might be something on the Comod Reader (http://comonad.com/reader/category/haskell/) that gives a firm intuition, but I can't find it right now.",fa2799759ddbc700ed1af69c85428a0bdc024bc5,True,False,,,,,0,1647720892,,0,{},i1bkd3z,False,t3_ti2eaa,False,True,t3_ti2eaa,/r/haskell/comments/ti2eaa/intuition_for_comonads/i1bkd3z/,1647720906,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
597.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"&gt; But a total function can produce an infinite output just fine.

Could you provide/link a definition of totality that makes that clear?  It's not clear to me an ""an infinite output"" is even a _thing_ without introducing some non-obvious axioms.  Like unifying expressions and values or otherwise allowing values in non-normal form, or assuming some particular family of limits exist.",caafb3f5a0227b3075e1092fb06ce673fbe1597b,True,False,,,,,0,1647709590,,0,{},i1atynd,False,t3_t3zw0x,False,True,t1_i1anb0u,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1atynd/,1647709603,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
598.0,[],False,,amalloy,,,[],,,,text,t2_6f5lu,False,False,"As far as I can tell, the AuditableData type this article describes is just Writer. It is well known that Writer obeys the monad laws.",30b19e9d3fdbde5d9b010887df5fba46b1981ebc,True,False,,,,,0,1647708741,,0,{},i1arzhg,False,t3_thby6s,False,True,t3_thby6s,/r/haskell/comments/thby6s/an_audit_monad/i1arzhg/,1647708757,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
599.0,[],False,,Syrak,,,[],,,,text,t2_4atne,False,False,"&gt; I don't really consider it total unless there's a guarantee that seeds generated by coalg are ""monotonically decreasing"" in some sense.

That would ensure the tree is finite/well-founded. But a total function can produce an infinite output just fine.",3177ebc9e442c3448ec9d871b109795dbdf9dcc8,True,False,,,,,0,1647706781,,0,{},i1anb0u,False,t3_t3zw0x,False,True,t1_i1ac4c8,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1anb0u/,1647706797,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
600.0,[],False,,sjakobi,,,[],,,,text,t2_sbvuw,False,False,Nice! Note that GHC 9.4 will change the representation of `Word64` and `Int64`: https://gitlab.haskell.org/ghc/ghc/-/wikis/migration/9.4#word64int64-use-word64int64,d29117ce891da7272ad13edcc8d2dee4bc11878f,True,False,,,,,0,1647702611,,0,{},i1ade45,False,t3_thtrew,False,True,t3_thtrew,/r/haskell/comments/thtrew/wordcompat_supporting_word8_and_the_like_with_no/i1ade45/,1647702625,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
601.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"`ana coalg`'s recursion is always guarded, so that paired with laziness guarantees it never generates without bound unless there's an unbounded demand introduced separately.

So, it can't be the ""source"" of non-totality, is the thinking I guess.

I don't really consider it total unless there's a guarantee that seeds generated by coalg are ""monotonically decreasing"" in some sense.  Or maybe there's some other checks for how coinductive structures are consumed.  But, all my training and intuition around totality is fairly informal.

Anyway, I think it has to do with how coinductive data and totality interact.  That fact may be obscured in Haskell since it doesn't differentiate between inductive and coinductive data.",85d638ac632cbc82a5d679032549a47094586240,True,False,,,,,0,1647702044,,0,{},i1ac4c8,False,t3_t3zw0x,False,True,t1_i19ri6e,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i1ac4c8/,1647702056,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
602.0,[],False,,blockscope,,,[],,,,text,t2_1nwfcyn5,False,False,"Haddocks [rendering on hackage](https://hackage.haskell.org/package/ghc-9.2.1/docs/GHC-Driver-Plugins.html#t:TcPlugin) can make it look like Haskell has recursive type synonyms.

    type TcPlugin = [CommandLineOption] -&gt; Maybe TcPlugin",3e2da115654741ec535328790e729a3e69d18f63,True,False,,,,,0,1647697632,,0,{},i1a2vwt,False,t3_rto654,False,True,t1_hqulcux,/r/haskell/comments/rto654/recursive_types/i1a2vwt/,1647697645,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,True
603.0,[],False,,TheCommieDuck,,,[],,,,text,t2_52eu3,False,False,"Even if you *know* that `map` is doing the same as the C code, you don't have to bother doing it yourself.",132ce76775500571568442451ad182a86384536b,True,False,,,,,0,1647692744,,0,{},i19ub3y,False,t3_tgmr1x,False,True,t1_i133zs4,/r/haskell/comments/tgmr1x/the_imperative_bit_in_functional_programming_is/i19ub3y/,1647692762,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
604.0,[],False,,mn15104,,,[],,,,text,t2_33938rg,False,False,"Can someone give an intuitive explanation of what ""universal properties"" that catamorphisms and anamorphisms give us when programming with them, and why these are important?  

      newtype Fix f = In (f (Fix f))
      out :: Functor f =&gt; Fix f -&gt; f a
      out (In f) = f

      cata :: Functor f =&gt; (f a -&gt; a) -&gt; Fix f -&gt; a
      cata alg = alg . fmap (cata alg) . out

      ana :: Functor f =&gt; (b -&gt; f b) -&gt; b -&gt; Fix f
      ana coalg = In . fmap (ana coalg) . coalg",061b54bd12ec0ae5f78543373dfa943395ed60a6,True,False,,,,,0,1647690808,,0,{},i19ri6e,False,t3_t3zw0x,False,True,t3_t3zw0x,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i19ri6e/,1647690824,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
605.0,[],False,,Odd-Fox-8410,,,[],,,,text,t2_7pefb5kd,False,False,"Well, I wanted swagger either way, so it made for an easy transition. Swagger-typescript can generate React hooks directly which is nice, using useQuery under the hood. Been smooth so far.",ee789cbd0b9fa52f514a46a9ce9a575c82b83039,True,False,,,,,0,1647687974,,0,{},i19nu3y,False,t3_tgt2bb,False,True,t1_i19lw08,/r/haskell/comments/tgt2bb/ann_servanttypescript_typescript_client/i19nu3y/,1647687989,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
606.0,[],False,,enobayram,,,[],,,,text,t2_90u7a,False,False,"I've been planning to do the same, (i.e. `servant-openapi3` followed by swagger-&gt;typescript codegen), how was you experience through that route? I wonder how it compares to OP's `servant-typescript`.",3836d5062b5afe6747b8ca3550cc42442af51c5f,True,False,,,,,0,1647686370,,0,{},i19lw08,False,t3_tgt2bb,False,True,t1_i158zd7,/r/haskell/comments/tgt2bb/ann_servanttypescript_typescript_client/i19lw08/,1647686382,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
607.0,[],False,,Innf107,,,[],,,,text,t2_3hk0np9x,False,False,"I don't actually think this is a big issue if the instances are generated with TemplateHaskell. As long as you only use `withFakeDict` (as opposed to `withFakeDictUnsafe`), you should never actually run into a situation where classes and dictionaries go out of sync.

So when `(/=)` is actually removed from `Eq` , this should only result in a compiler error (because my approach cannot handle default methods, so you would have to write out an implementation for `(/=)` right now which would then become redundant).

That said, if GHC ever decides to compile dictionaries in a different way, `withFakeDict` *is* going to break.

Your approach sounds pretty neat, though I would be a bit concerned about that orphan instance. 

I have had troubles getting your code to compile though. If I just type it directly into GHCi, I get 

    Couldn't match type: Given (a -&gt; a -&gt; Bool)
                   with: Eq a

because GHC doesn't infer that `Given (a -&gt; a -&gt; Bool)` implies `Eq a`.

If I eta expand `withEq`, GHC instead fails with `Overlapping instances for Eq a`, since every single Eq instance overlaps here, and GHC refuses to just pick the first one (unless every single in-scope Eq instance is marked as incoherent).",ed777ed14cc12279d0dec0b444a91f62327ca111,True,False,,,,,0,1647686198,,0,{},i19lom5,True,t3_thaqi6,False,True,t1_i191jft,/r/haskell/comments/thaqi6/faking_local_instances_with_unsafecoerce_dict/i19lom5/,1647686210,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
608.0,[],False,,Faucelme,,,[],,,,text,t2_6ofev,False,False,"Is there a version of the ""haskeline"" package where the functionality is provided as a record-of-functions over `IO`, instead of a transformer?",d854af2216baa8c35df44b699bfd4cdcbbbdee29,True,False,,,,,0,1647685956,,0,{},i19le2u,False,t3_t3zw0x,False,True,t3_t3zw0x,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i19le2u/,1647685970,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
609.0,[],False,,AshleyYakeley,,,[],,,,text,t2_92cbu,False,False,"I would consider it unacceptably fragile to unsafely depend on a particular layout of a class dictionary. This is especially true for the `Eq` example you gave, which IIRC is going to be revised to remove the `(/=)` member.

But if you trust `given`, I think you can do the same thing:

    instance {-# OVERLAPPABLE #-} Given (a -&gt; a -&gt; Bool) =&gt; Eq a where
        (==) = given

    withEq :: (a -&gt; a -&gt; Bool) -&gt; (Eq a =&gt; r) -&gt; r
    withEq = give

...although there might be some awkwardness about that fully-general `Eq` instance leaking everywhere.",3d07605ed3c3d5f2da880c076f04608def4b4bc8,True,False,,,,,0,1647668750,,0,{},i191jft,False,t3_thaqi6,False,True,t1_i17tgnd,/r/haskell/comments/thaqi6/faking_local_instances_with_unsafecoerce_dict/i191jft/,1647668762,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
610.0,[],False,,olstrak,,,[],,,,text,t2_5mujb5oz,False,False,"I don't know of a document that specifically lays this out in a concise way, but the exercises in the [Typeclassopedia](https://wiki.haskell.org/Typeclassopedia) can really help to develop your intuition here. Aside from that, you might want to look into effects systems, which offer a different approach to the matter and may give you more clarity than monad transformers.",16a39cd2a90c119b6e775df0d1ac4dc67a1858c8,True,False,,,,,0,1647654423,,0,{},i18cg2j,False,t3_tfqpeg,False,False,t1_i17riqd,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i18cg2j/,1647654439,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
611.0,[],False,,affinehyperplane,,,[],,,,text,t2_12xogr,False,False,"&gt; But note that in the end the `each`, `_1`, and `_2` lenses do have to be implemented separately for each tuple size. There is no free lunch.

generic-lens implements `Generic`-based lenses which work more generally and without duplication for different tuple sizes:

     Λ import Control.Lens
     Λ import Data.Generics.Product.Positions
     Λ import Data.Generics.Product.Types
     Λ :set -XDataKinds
     Λ :set -XTypeApplications
     Λ (1,2,3) ^.. types @Integer
    [1,2,3]
     Λ (4,5,6) &amp; position @3 +~ 1
    (4,5,7)",db9f688d1506ecd27535a70e765ce0916687a6f2,True,False,,,,,0,1647651468,,0,{},i186esp,False,t3_t3zw0x,False,True,t1_i0wh8oe,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i186esp/,1647651479,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
612.0,[],False,,anydalch,,,[],,,,text,t2_127z0q,False,False,"your last paragraph hits the nail on the head. many monads have strict bind operators, because many monads encode side effects on a state which can be observed by subsequent monadic operations. and `liftM2` is implemented in terms of the bind operator to cause the side effects of both of its operands, which, with a strict bind operator, gives you a strict `liftM2`.",9ac9389c096e73c50bee0f7cbab41a3bf2c04617,True,False,,,,,0,1647648262,,0,{},i17zo92,False,t3_tfqpeg,False,False,t1_i17o39z,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i17zo92/,1647648278,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
613.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"The `reflection` package is restricted to safe and coherent usage, so that is why they don't provide the full power of your local instances.

As for the carrier, you indeed need newtypes (e.g. `M` or `Lift`), but only one per class instead of the usual one per instance.

I would recommend watching the talk [Type Classes vs. the World](https://youtu.be/hIZxTQP1ifo?t=5007) for a very quick overview. The overview starts at 1:23:30, but the rest of the talk is also very interesting.

There is a paper that proposes a language-level solution to safe explicit dictionary passing: https://lirias.kuleuven.be/retrieve/519822/

Here's some previous discussion about that paper: https://reddit.com/r/haskell/comments/jonjy8/explicit_dictionary_passing_as_a_language/gbbqajl/",3ed2680bf8d7cf4509be6db6157c242e166b5777,True,False,,,,,0,1647648144,,0,{},i17zf7m,False,t3_thaqi6,False,True,t1_i17tgnd,/r/haskell/comments/thaqi6/faking_local_instances_with_unsafecoerce_dict/i17zf7m/,1647648157,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
614.0,[],False,,MorrowM_,,,[],,,,text,t2_6l7exkda,False,False,"I've done something similar before for faking aeson instances for types you don't own:l using the constraints library:

https://www.reddit.com/r/haskellquestions/comments/sqsu3i/-/hwpqefv",dc47ea4a756ba81c3197f7f64c54135d39cbcb32,True,False,,,,,0,1647646841,,0,{},i17wneu,False,t3_thaqi6,False,True,t3_thaqi6,/r/haskell/comments/thaqi6/faking_local_instances_with_unsafecoerce_dict/i17wneu/,1647646855,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
615.0,[],False,,SouthernDifference86,,,[],,,,text,t2_ho3vhqip,False,False,I really like this technique for implicitparams like constructs. But the typing just plains sucks. GHC assumes a monomorph constraint must be in scope and thus throws a type error. UNLESS you give it a type signature yourself. Really hate this and wish GHC would infer a monomorphic constraint if it can solve it straight away.,1af3db14185b099e87ecc609cb81ea1548f0fd3d,True,False,,,,,0,1647646325,,0,{},i17vj5u,False,t3_thaqi6,False,True,t3_thaqi6,/r/haskell/comments/thaqi6/faking_local_instances_with_unsafecoerce_dict/i17vj5u/,1647646342,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
616.0,[],False,,Innf107,,,[],,,,text,t2_3hk0np9x,False,False,"This is interesting. I didn't actually know about reflection until you mentioned it, but it seems like it allows a very similar approach.

Altough after looking at the reflection [examples](https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs) for [local instances](https://github.com/ekmett/reflection/blob/master/examples/Constraints.hs), it seems like reflection still needs some kind of 'carrier' newtype (`M` and `Lift` in the examples), so you don't get full local instances in the same way you do with my library?",f97e61d0822ad3e07ce1fb0ab7bb8fb0100e6cf7,True,False,,,,,0,1647645363,,0,{},i17tgnd,True,t3_thaqi6,False,True,t1_i16sn1q,/r/haskell/comments/thaqi6/faking_local_instances_with_unsafecoerce_dict/i17tgnd/,1647645376,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
617.0,[],False,,Innf107,,,[],,,,text,t2_3hk0np9x,False,False,"Sorry about that, seems like I forgot to actually upload the repository :)

Should be fixed now.",ed99dd6b46567beb00b63e0a2551e5dbf9732440,True,False,,,,,0,1647644621,,0,{},i17rvkm,True,t3_thaqi6,False,True,t1_i17pmsz,/r/haskell/comments/thaqi6/faking_local_instances_with_unsafecoerce_dict/i17rvkm/,1647644635,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
618.0,[],False,,Defrigeration,,,[],,,,text,t2_ghrwv,False,False,"Ok, cool. That makes a lot of sense. Do you know if there is a document somewhere (I'm not even sure what to call it, a style guide, perhaps) that expands on what you said about types and explains what's intended for representing what, especially in relation to monads? Now I'm worried I might be missing other such details. I find the library documentation very light on the intent of things. (I'm not the only one. Someone else created a thread recently asking why Solo exists.)",5643648a907e87b39575ffaf2a9a5e0723540628,True,False,,,,,0,1647644459,,0,{},i17riqd,True,t3_tfqpeg,False,True,t1_i16wpzj,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i17riqd/,1647644475,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
619.0,[],False,,Las___,,,[],,,,text,t2_hgb80y2l,False,False,FYI the GitHub repo gives me a 404,6171072f348ce57a8b73b9d48032dd0c3b7f14c2,True,False,,,,,0,1647643601,,0,{},i17pmsz,False,t3_thaqi6,False,True,t3_thaqi6,/r/haskell/comments/thaqi6/faking_local_instances_with_unsafecoerce_dict/i17pmsz/,1647643634,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
620.0,[],False,,Defrigeration,,,[],,,,text,t2_ghrwv,False,False,"I have no particular desire to prove either the other commenter or you wrong, but, I can't see how both of you can be right (in that you originally said that I can look to the definition of `liftM2` to understand what I'm seeing happen whereas they said it was ""specific"" to the particular bind operator. If it is specific to that bind operator, it follows that there must be some other possible bind operator for which things are different. It sounds like `[]` might be such an example.) I merely asked them for some evidence for an assertion that seems to contradict yourself and the others mentioned. The fact that [evilLazyLiftM2](https://www.reddit.com/r/haskell/comments/tfqpeg/comment/i0ywzdc/?utm_source=share&amp;utm_medium=web2x&amp;context=3) could be defined seems to prove that we don't have to consider the particulars of the monad in order to control how its inputs are bound, but I admit I haven't tried it.

Supposing, on the other hand, that ""compiler magic"" really is the answer, then my ""why"" question is asking why the compiler writers chose this magic instead of some other magic. This has been adequately answered: to preserve order in IO and State computations, etc. However, I would point out that if the specification is that ""A happens before B"", order is still preserved if B never happens at all.

As to your touch example, of course I see why practically, we would want it not to be lazy about actually creating the file. However, from a semantic point of view, if I'm the compiler, I might reason: the programmer doesn't care about the success or failure of the touch operation (e.g. no permission to write to that directory), so they don't care whether it was completed, so I might as well be lazy about it. It is only because the state of the file system is passed (so to speak) to whatever program executes next that it needs to actually write to disk. (In fact, in a shell script, you might check for the success of the touch command with a boolean operator on the exit code to control what executes next.)",4364f7c9d70b773c7accc0913153d9c84fed2fb7,True,False,,,,,0,1647642907,,0,{},i17o39z,True,t3_tfqpeg,False,False,t1_i174n9k,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i17o39z/,1647642919,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
621.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"&gt; they're definitely better at stealing the surface appearances than they are at getting the underlying virtues

One reason I want to work with Haskell / PureScript / Idris / Agda is because I think the languages that are mimicing the surface appearance end up making easier to bury a tech debt landmine (e.g. passing an ""impure"" callback where an ""pure"" callback is expected).",ea24e391fc762d0099c200b7efc2c8fc6cffec74,True,False,,,,,0,1647640393,,0,{},i17icg9,False,t3_thby6s,False,True,t1_i171zoj,/r/haskell/comments/thby6s/an_audit_monad/i17icg9/,1647640407,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
622.0,[],False,,bitconnor,,,[],,,,text,t2_be0esdi4,False,False,Would you say that an Excel spreadsheet is declarative? Or is this also just an illusion?,cf4d62a2fa7fb8bf740c111f4a732df4eadc0c5e,True,False,,,,,0,1647639421,,0,{},i17g25r,False,t3_tgmr1x,False,True,t1_i15hqy3,/r/haskell/comments/tgmr1x/the_imperative_bit_in_functional_programming_is/i17g25r/,1647639432,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
623.0,[],False,,thomasjm4,,,[],,,,text,t2_ye2d7h4,False,False,"Interesting, a little googling indicates that Aeson-to-PureScript serialization is still sort of an unsolved problem.

Just a thought, but the `TypeScript` instances you derive with `aeson-typescript` have full knowledge of how Haskell values are serialized to JSON. I wonder if you could write a tool to reverse the process, using this information to generate `FromJSON`/`ToJSON` instances for PureScript (or whatever the equivalent is, I don't use PureScript). Or just full type definitions.",b0f49b644a364dcfbca0ff26b25d274c657d71b7,True,False,,,,,0,1647639360,,0,{},i17fx37,True,t3_tgt2bb,False,True,t1_i15nfo5,/r/haskell/comments/tgt2bb/ann_servanttypescript_typescript_client/i17fx37/,1647639374,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
624.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,It seems exactly what the OP is trying to do with the `Increment` constructor and their incomplete/incorrect implementation of `&lt;*&gt;`.,4a06db70fe0d572c8248cb149c519e6b98bc2654,True,False,,,,,0,1647635510,,0,{},i176j0v,False,t3_tgu4fy,False,True,t1_i1743sg,/r/haskell/comments/tgu4fy/im_having_issues_with_applicative_effects/i176j0v/,1647635528,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
625.0,[],False,,anydalch,,,[],,,,text,t2_127z0q,False,False,"i generally would say you're right to reject explanations of ""compiler magic,"" but your linked definitions of the definition of `bindIO` are not terribly helpful. and it is possible to describe what you're observing in terms of either the bind operator or the definition of `liftM2`; it's an interaction between them.

the commentor you're responding to is correct; it's impossible to define a `Monad` instance for `IO`, or any of the monads which represent side-effecting procedures, which preserves both laziness and side-effects. i was trying to describe this conflict in my `Logging` example.

&gt; In the case of the State monad, it would be reasonable (though perhaps not desirable in every case) to avoid a statefull computation that is not needed to compute the result of the lifted function.

i think it's important to explicate: laziness can only reason about the result of a computation, not its side effects. `IO` is the best example here, because it encodes side effects which are otherwise unobservable to the haskell vm, like creating files. imagine, for example, a usage of `touchFile`, which wraps the unix `touch` operation:

    main = (touch somePath) &gt;&gt; (return ())

rewrite this as:

    main = (touch somePath) &gt;&gt;= (\ignored -&gt; return ())

now imagine that the implementation of `&gt;&gt;=` for `IO` is lazy; it does not perform side-effecting operations until their results are needed. in that world, because `ignored` is never used, that program will terminate without touching any files.

you can construct similar examples with a hypothetical `State`- or `ST`-analogue which yields incorrect results because writes to the state are never forced, but it's not possible to implement these without ""compiler magic"" (i.e. messing with internal interfaces beyond my understanding), because representing the mutable state as a haskell value will make the dependency visible to the vm and force the computation.

there are, actually, monads which preserve laziness, like `[]`, but you wouldn't be able to tell without pulling out your profiler and disassembler, because they are exclusively the monads which do not encode externally-observable side effects.",583f99f261fc0eb84f1f8984aa52fc4fd9af41d2,True,False,,,,,0,1647634766,,0,{},i174n9k,False,t3_tfqpeg,False,True,t1_i170e66,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i174n9k/,1647634783,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
626.0,[],False,,amalloy,,,[],,,,text,t2_6f5lu,False,False,I feel like that is a huge distraction for someone who is trying to figure out applicative effects at all.,7834474a05c136f0e2a54c8520a69a77cc998246,True,False,,,,,0,1647634551,,0,{},i1743sg,False,t3_tgu4fy,False,True,t1_i16ttfk,/r/haskell/comments/tgu4fy/im_having_issues_with_applicative_effects/i1743sg/,1647634567,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
627.0,[],False,,dagit,,,[],,,,text,t2_lj2p,False,False,"There is some truth to what they're saying. The `IO` monad is modeled by GHC using a value of `RealWorld` that the `IO` monad must thread through the computation. The line:

    bindIO (IO m) k = IO (\ s -&gt; case m s of (# new_s, a #) -&gt; unIO (k a) new_s)

Does this threading by casing on the result of `m s` to get `new_s`. The `new_s` is this `RealWorld` thingy I mentioned.

To see an example of this at play, look at this:

    $ ghci
    GHCi, version 8.10.7: https://www.haskell.org/ghc/  :? for help
    Prelude _&gt; import Control.Monad.Identity 
    Prelude Control.Monad.Identity _&gt; liftM2 (||) (pure True) undefined :: Identity Bool
    Identity True
    Prelude Control.Monad.Identity _&gt; liftM2 (||) (pure True) undefined :: IO Bool
    *** Exception: Prelude.undefined
    CallStack (from HasCallStack):
      error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err
      undefined, called at &lt;interactive&gt;:5:25 in interactive:Ghci2

In the `Identity` case, the definition of `&gt;&gt;=` for the monad is lazy. That is, it doesn't demand the result of the LHS of `&gt;&gt;=`. In the case of `IO`, the LHS is demanded. And given the way `liftM2` is defined, we have to call `&gt;&gt;=` on both arguments before we can apply the supplied function. So both arguments end up on the LHS of a `&gt;&gt;=`. In the lazy case, this is fine but in the strict case this forces the evaluation of `undefined`.

Why does `IO` have this `RealWorld` state threading? Precisely to ensure all the side-effects are run in correct order and none are skipped.

Note however, this doesn't work if we use `liftM2 (&amp;&amp;)`. In that situation, both end up on the LHS again, but now it's `(&amp;&amp;)` that is forcing it's arguments, because it has a case like:

    (&amp;&amp;) True True = True",b0f2d027744dc2b2bdf9a02873f17a9f2a527237,True,False,,,,,0,1647634248,,0,{},i173cka,False,t3_tfqpeg,False,True,t1_i170e66,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i173cka/,1647634264,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
628.0,[],False,,jerf,,,[],,,,text,t2_9duv,False,False,"Yeah, in Haskell it's trivial, plus you get type system support to ensure that it is rigidly used where you expect it is used, the audit messages can be declared as data types so they stay symbolic as long as possible, you get the full [Control.Monad suite](https://hackage.haskell.org/package/base-4.16.0.0/docs/Control-Monad.html) and many others to help you work through the code that is doing the audit work is as ergonomic to work with in Haskell terms as possible, the experience is just a dream.

By comparison, while I've reached for it in desperation a couple of times in other languages, it is... a solution, definitely. A solution. Not much more.

I miss working in Haskell a lot less than you might expect, maybe even less than _I_ might expect, but as much as languages have been stealing from it lately, they're definitely better at stealing the surface appearances than they are at getting the underlying virtues. I know other languages that could do this better than the ones I use at work but none will be as _slick_ as Haskell, and mostly be using library code.",58fdd83300d954fcc05178223e14675cac4b2c1e,True,False,,,,,0,1647633708,,0,{},i171zoj,False,t3_thby6s,False,True,t1_i16tu2y,/r/haskell/comments/thby6s/an_audit_monad/i171zoj/,1647633726,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
629.0,[],False,,Defrigeration,,,[],,,,text,t2_ghrwv,False,False,"I hate to argue with someone who seems to be trying to help, but there is no such thing as ""compiler magic"". IO's `&gt;&gt;=` is defined on lines 1579 and 1593 of [Base.hs](https://gitlab.haskell.org/ghc/ghc/-/blob/master/libraries/base/GHC/Base.hs) . 

/u/anydalch, /u/dagit, and /u/Tysonzero all gave convincing, reasoned arguments explaining that what I've observed is down to the definition of `liftM2`. You assert that it's due to the specific definition of `&gt;&gt;=` for the IO monad and the State monad, but you can't give an alternate definition that would act differently (even a silly, useless, insane one would be evidence for what you're saying).  Can you explain why they are wrong? Alternatively, an existing example of a another monad instance with different behaviour would support your case.

In the case of the State monad, it would be reasonable (though perhaps not desirable in every case) to avoid a statefull computation that is not needed to compute the result of the lifted function. So, I do not accept your unsupported claim that this is the ""only sane definition"".",ea489b64b3ab28ab9a36a68678e09a0425b5d81e,True,False,,,,,0,1647633074,,0,{},i170e66,True,t3_tfqpeg,False,True,t1_i14qdwl,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i170e66/,1647633086,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
630.0,[],False,,olstrak,,,[],,,,text,t2_5mujb5oz,False,False,"&gt;I had seen mention of ""boolean blindness"" somewhere but I didn't really get what was meant by it

The gist of it is that you want to encode your program's logic in your types. There's no indication that the `Bool` in `IO Bool` represents failure and the only guarantee you get from composing an `IO Bool` with a `Bool -&gt; IO Bool` is the sequencing of the IO operations. In contrast, a `MaybeT IO a` unambiguously represents an IO operation that either yields a value of type `a` or simply fails, and composing a `MaybeT IO a` with an `a -&gt; MaybeT IO b` ensures that the second operation is only performed if the first succeeds.

&gt;Why else would it specify which argument is lazy and which isn't?

This is the type of thing you would want to know for the sake of optimization. Your program's logic shouldn't depend on laziness in order to be semantically correct.",688b186e402af29ecfe3eba9d0f39331d3b83d49,True,False,,,,,0,1647631559,,0,{},i16wpzj,False,t3_tfqpeg,False,False,t1_i16dio5,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i16wpzj/,1647631572,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
631.0,[],False,,mirkeau,,,[],,,,text,t2_2rafjlo8,False,False,Thank you so much for taking your time to explain the reasons behind it. I'll need a bit of time to understand it completely. Awesome!,f64ac1e89dc4f049477fde54068d941330148659,True,False,,,,,0,1647630904,,0,{},i16v53v,True,t3_th4twn,False,True,t1_i16lnje,/r/haskell/comments/th4twn/understanding_tolistof_with_van_laarhoven/i16v53v/,1647630919,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
632.0,[],False,,patrick_thomson,,,[],,,,text,t2_ghxtk,False,False,"You can implement an auditable memoization monad with the state monad (among others), so yes.",de3bf1684bf80474b0d130a56a5fa4db20df1bc5,True,False,,,,,0,1647630364,,0,{},i16tu2y,False,t3_thby6s,False,True,t3_thby6s,/r/haskell/comments/thby6s/an_audit_monad/i16tu2y/,1647630379,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
633.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"Yeah, I think https://softwareengineering.stackexchange.com/a/242803 might be apropos.",9dc4b6991dde0b087d00cc1118b79329e1da2e9f,True,False,,,,,0,1647630358,,0,{},i16ttfk,False,t3_tgu4fy,False,True,t1_i16nup1,/r/haskell/comments/tgu4fy/im_having_issues_with_applicative_effects/i16ttfk/,1647630370,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
634.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,How is this different from [`reflection`](https://hackage.haskell.org/package/reflection)?,539a9173659423a9dc72f1d59df12b22fd75dc1c,True,False,,,,,0,1647629876,,0,{},i16sn1q,False,t3_thaqi6,False,True,t3_thaqi6,/r/haskell/comments/thaqi6/faking_local_instances_with_unsafecoerce_dict/i16sn1q/,1647629892,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
635.0,[],False,,FreeVariable,,,[],,,,text,t2_16uihwda,False,False,"I must say I am bit disappointed in the pricing here. For comparison, EuropPython 2021 offered free of charge streaming access. And we're talking of one of the most popular language in the world. This doesn't help with Haskell's accessibility and visibility.",fbb0ffc43aeb84dd711a358e45aebf232d8c6301,True,False,,,,,0,1647629173,,0,{},i16qwbo,False,t3_telf9t,False,True,t3_telf9t,/r/haskell/comments/telf9t/haskellers_functional_conf_2022_is_online_and/i16qwbo/,1647629187,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
636.0,[],False,,amalloy,,,[],,,,text,t2_6f5lu,False,False,"Seems like a good attempt to make a simple effect, but as the other comments point out, you have no way to combine a Counter and an Increment into a Counter. You could choose to only get an Increment out, and that should be lawful, but not very useful.

Alternatively, I'd suggest this simpler type, which combines more easily:

    data Counter a = Counter Integer a

i.e., remove the Increment constructor. Then you can define

    increment :: Counter ()
    increment = Counter 1 ()

and that should combine just fine with other Counter values, leading to a lawful Applicative instance.",8eac3d2b42afe788edc2eb6e876b62f4a9e4225b,True,False,,,,,0,1647627957,,0,{},i16nup1,False,t3_tgu4fy,False,True,t3_tgu4fy,/r/haskell/comments/tgu4fy/im_having_issues_with_applicative_effects/i16nup1/,1647627970,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
637.0,[],False,,amalloy,,,[],,,,text,t2_6f5lu,False,False,"This is illegal to do without turning on some language extensions, so it would be helpful to mention what those are when suggesting it.",bd8e7579041408b8a630d64152af5aa760a7f73e,True,False,,,,,0,1647627562,,0,{},i16mv5v,False,t3_tgu4fy,False,True,t1_i14ebtj,/r/haskell/comments/tgu4fy/im_having_issues_with_applicative_effects/i16mv5v/,1647627579,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
638.0,[],False,,kuribas,,,[],,,,text,t2_nct91,False,False,"You're going with this the wrong way.  `Const (Endo [a])` is an implementation detail, a leaking abstraction.  It's easier to start from the traversal:

    type Traversal s t a b = forall f. Applicative f =&gt; (a -&gt; f b) -&gt; s -&gt; f t

So you want to find an effect that can loop over all the values, and collect all the elements in the list.  Then you discard the result type, since you don't need it, and return the collected values.  The logical effect to use would be the writer monad:

    toListOf1 :: Traversal (t a) (t a) a a
              -&gt; t a
              -&gt; [a]
    toListOf1 t s = execWriter $ t (\x -&gt; do tell [x]; pure x) s

This works fine, but it seems a bit overkill, since you ignore the result.  So you can use `Const` instead, which is like a writer effect, except that it always ignores the return values. It simply collects its arguments using the Monoid instance:

    toListOf2 :: Traversal (t a) (t a ) a a
              -&gt; t a
              -&gt; [a]
    toListOf2 t s = getConst $ t (\x -&gt; Const [x]) s

This is better, but it has a nasty surprise, it uses append to collect the values, so it will run in quadratic time.  The solution is to use a difference list, which is usually implemented in haskell using the `Endo` functor.  Then you use can use `Endo (x:)` to append a value, but without the quadratic complexity.

This gives: 

    toListOf3 :: Traversal (t a) (t a ) a a
              -&gt; t a
              -&gt; [a]
    toListOf3 t s = flip appEndo [] $ getConst $ t (\x -&gt; Const $ Endo $ (x:))

To make it more general, you can specialize the `f` in this function, so it gives the type you get from the lens library.  This way the given traversal function doesn't need to work with any functor, just with `Const (Endo [a])`.  But at the cost of leaking the abstraction.",083a0421cd4234ceb4df7fdd796520b33f911c12,True,False,,,,,0,1647627078,,0,{},i16lnje,False,t3_th4twn,False,True,t3_th4twn,/r/haskell/comments/th4twn/understanding_tolistof_with_van_laarhoven/i16lnje/,1647627092,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
639.0,[],False,,rbrucesp,,,[],,,,text,t2_cascywq,False,False,"Thank you very much, yes that gets me further.

Yes, the remaining error is just there because I swapped ty2F and ty1F.",07c91e3807363567f5cf464d510cc9bee68314cb,True,False,,,,,0,1647626308,,0,{},i16jpck,True,t3_th1sco,False,True,t1_i15p9vj,/r/haskell/comments/th1sco/conversion_to_tagless_style/i16jpck/,1647626322,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
640.0,[],False,,IamfromSpace,,,[],,,,text,t2_b84xa,False,False,"I struggled greatly to really understand Applicative.  Notably, it was discovered/introduced later, so I don’t think that should be surprising.

I feel like it’s useful to break down what it’s useful for vs what it “is” in the abstract.

For usefulness, `liftA2` is in many ways the place to start.  What this does for us allows us to take a pure function `a -&gt; b -&gt; c` and get `Applicative f =&gt; f a -&gt; f b -&gt; f c`.  In terms of effects, this lets us choose how to fuse two _independent_ events.  It’s quite advantageous to define the fusion in terms of a generic function, but considering `liftA2 (,)` we illustrate the idea with fewer type variables: `Applicative =&gt; f a -&gt; f b -&gt; f (a, b)`.  The key piece here is that the result of one cannot influence the other (unlike Monads).

Now, sometimes we need to combine `liftA3`, and `liftA4`, and so on, but that’s where `(&lt;*&gt;)` comes into play.  It’s the lower level building block that allows us to build out any `liftAn`.  The trick is fusing effects when one effect is a function, whose next argument is in the other effect.  Since the effect with the function is the _result_ it doesn’t need the argument _before_ the effect, like a Monad.

For your type, there’s no real way to fuse the results, neither sum type has enough information, or too much in a way that combination is ambiguous.",42fe8e405bab19779ffa1dbf2e8cfe490b85c111,True,False,,,,,0,1647624618,,0,{},i16fdha,False,t3_tgu4fy,False,True,t3_tgu4fy,/r/haskell/comments/tgu4fy/im_having_issues_with_applicative_effects/i16fdha/,1647624634,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
641.0,[],False,,Defrigeration,,,[],,,,text,t2_ghrwv,False,False,"Ah, I had seen mention of ""boolean blindness"" somewhere but I didn't really get what was meant by it and I haven't got around to learning about monad transformers yet. As to the intent of (&amp;&amp;), the docs say: 

&gt;Boolean ""and"", lazy in the second argument

I took this to confirm my belief that it could be used to decide which computation is actually done. Why else would it specify which argument is lazy and which isn't?",2abe2fe0944462033f4a59a744e22e8fd8ba46fe,True,False,,,,,0,1647623893,,0,{},i16dio5,True,t3_tfqpeg,False,True,t1_i154bhx,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i16dio5/,1647623904,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
642.0,[],False,,mirkeau,,,[],,,,text,t2_2rafjlo8,False,False,"I see! I need to think of difference lists instead of arbitrary `Endo [a]`, so the better choice seems to be `(:)`! This version passes the test! Thank you very much!

    toListOf :: ((a -&gt; Const (Endo [a]) a) -&gt; (s -&gt; Const (Endo [a]) s)) -&gt; (s -&gt; [a])
    toListOf t x =  let aToFa = Const . Endo . (:)
                        sToFs = t aToFa
                        sEndo = getConst $ sToFs x
                    in  appEndo sEndo []",e6150378b70cc6e0396bb75ffe48a11ff128c406,True,False,,,,,0,1647622625,,0,{},i16aakl,True,t3_th4twn,False,True,t1_i165esm,/r/haskell/comments/th4twn/understanding_tolistof_with_van_laarhoven/i16aakl/,1647622636,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
643.0,[],False,,EntrepreneurAmazing4,,,[],,,,text,t2_812xilv1,False,False,"Sorry for the late reply! Thanks for this example, it's definitely a lot more readable that way.",20335d1890adc14fcf5095f1a590e31cadd7f043,True,False,,,,,0,1647622251,,0,{},i169bx3,True,t3_tgj6ko,False,True,t1_i14jex5,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i169bx3/,1647622264,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
644.0,[],False,,EntrepreneurAmazing4,,,[],,,,text,t2_812xilv1,False,False,Sorry for the late reply. Thanks for the advice and helpful examples.,b609f6a05b3e40052b74e61462abbbbf78ef5373,True,False,,,,,0,1647622074,,0,{},i168vlp,True,t3_tgj6ko,False,True,t1_i12urzo,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i168vlp/,1647622094,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
645.0,[],False,,Darwin226,,,[],,,,text,t2_byzre,False,False,"&gt;t expects a function from a to Const (Endo \[a\]) a, the only one I could think of is Const . Endo . map . const.

There's a better one.

&gt;!This function needs to turn the ""a"" into an operation of ""collecting"" this element.!&lt;",0bf08066fc727f17f18efe4a1741cc7d7bcd7332,True,False,,,,,0,1647620748,,0,{},i165esm,False,t3_th4twn,False,True,t3_th4twn,/r/haskell/comments/th4twn/understanding_tolistof_with_van_laarhoven/i165esm/,1647620760,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
646.0,[],False,,jakuzureno,,,[],,,,text,t2_5ds86uwg,False,False,"me too, `TERM=dumb ghci` does the trick for now as mentioned above. still haven't found a permanent solution for that though",84b708d1c6c408cb8ff52c82e2a6e7bbb2351612,True,False,,,,,0,1647615631,,0,{},i15sc3v,False,t3_ph2ge2,False,True,t1_i0ggfvg,/r/haskell/comments/ph2ge2/ghci_problem_with_arrow_key/i15sc3v/,1647615645,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
647.0,[],False,,jwiegley,,,[],,,,text,t2_3sm69,False,False,"Your function has too many type variables that only appear in the codomain, or not at all. In these cases, type applications are necessary to clarify:

    typeCheck ::
      forall repr gamma h t.
      (Symantics repr, Var gamma h) =&gt;
      t -&gt;
      ExpN -&gt;
      Maybe (DynTerm repr h)
    typeCheck gamma (IntN n) = return $ DynTerm TyInt (int @repr n)
    typeCheck gamma (AppN fN xN) = do
      DynTerm (TyArr ty1F ty2F) f &lt;- typeCheck @repr @gamma @h gamma fN
      DynTerm (tyX) x &lt;- typeCheck @repr @gamma @h gamma xN
      Refl &lt;- testEquality (ty2F) (tyX)
      return $ DynTerm ty2F (app f x)

The remaining error is unrelated to your question, I believe, but this should get you further.",c2083d570df44cbb464a565aba6b239d2a0347ff,True,False,,,,,0,1647614390,,0,{},i15p9vj,False,t3_th1sco,False,True,t3_th1sco,/r/haskell/comments/th1sco/conversion_to_tagless_style/i15p9vj/,1647614408,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
648.0,[],False,,ramin-honary-xc,,,[],,,,text,t2_8mof715w,False,False,I need one of these but for PureScript. Copy-pasting Haskell doesn't properly map what derive generic generates with Aeson to PureScript `type` declarations that can be coerced directly from JSON.,827d1df243e30a2dcc53158f92a27d75f7914bd5,True,False,,,,,0,1647613628,,0,{},i15nfo5,False,t3_tgt2bb,False,True,t3_tgt2bb,/r/haskell/comments/tgt2bb/ann_servanttypescript_typescript_client/i15nfo5/,1647613640,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
649.0,[],False,,gasche,,,[],,,,text,t2_556vu,False,False,"Hot take: functional programming is *not* declarative.

I like the ""it describes the *what*, not the *how*"" definition of ""declarative programming"", but if we think about it honestly we should realize that the vast majority of programming paradigms out there are not declarative in practice. Imperative programming (whether OO is used for structuration or not) is certainly not, but then neither is functional programming, or Prolog, etc. Declarativeness is a property of *how* we use a programming tool, a programming language: it is not declarative when our programming decision rely on a fine-grained understanding of the language/tool's operational model, ""the way things compute"". If you write functional code for most problem domains, you will be careful about how things compute to avoid, for example, performance issues (in time or space). Same with Prolog: toy examples feel declarative, but in fact Prolog programmers need a deep understanding of the resolution strategy of Prolog programs. For SQL, the illusion can last a bit longer: very naive uses of SQL feel declarative, it's only when you get into more advanced performance-conscious concerns (indexes, query plans, etc.) that you stop using it declaratively. Datalog is used more declaratively than Prolog, and (say) regular expressions are generally used in a very declarative way.

In functional programming, short snippets can look declarative (so can short snippets of Python where list comprehensions do the job), but any middle-size program requires some thinking about the computational model. Then we know how to make some dedicated problem domains ""feel declarative"" again, using combinator libraries for example (this can be done in most programming paradigms, but it works well with the general problem-decomposition and modelling approaches of functional programming).

Remark: In some respects the gap between the ideal of ""declarative programming"" and everyday programming has similarities with the gap between pen-and-paper mathematical proofs and ""proof scripts"" in proof assistants. Actual programs are much more detailed, and depend on much more fine-grained operational/computational details than our informal thinking when preparing the program, as could be expressed in natural language or sometimes in pseudo-code. Similarly, mechanized proofs are much more detailed than proofs that one would provide to a human reader. In both case the actual work feels ""not declarative"", even with state-of-the-art tools, except in some very constrained problm domains.",b441c91802f2a02d69f3345f85306121f56f93bd,True,False,,,,,0,1647611215,,0,{},i15hqy3,False,t3_tgmr1x,False,False,t3_tgmr1x,/r/haskell/comments/tgmr1x/the_imperative_bit_in_functional_programming_is/i15hqy3/,1647611233,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
650.0,[],False,,ChrisWohlert,,,[],,,,text,t2_v8h3i,False,False,"I've been trying [https://github.com/smaccoun/servant-ts](https://github.com/smaccoun/servant-ts), but it has a damning bug. I've changed to use servant-swagger, and then gen the typescript from swagger.",e662addb19127c5a27731245eeec7622d5480e27,True,False,,,,,0,1647606965,,0,{},i158zd7,False,t3_tgt2bb,False,True,t3_tgt2bb,/r/haskell/comments/tgt2bb/ann_servanttypescript_typescript_client/i158zd7/,1647606982,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
651.0,[],False,,SrPeixinho,,,[],,,,text,t2_7u4u3,False,False,Interesting.,7c5f3c731eb864fb669d23301fd2f445731fa3d7,True,False,,,,,0,1647606100,,0,{},i157eay,False,t3_o5ta34,False,True,t1_h2peew4,/r/haskell/comments/o5ta34/polysemey_algebraic_vs_extensible_effects_and/i157eay/,1647606117,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
652.0,[],False,,Tarmen,,,[],,,,text,t2_7mjdo,False,False,"This sounds a bit like the expression problem.

In Haskell you usually start by writing a data type and adding functions/transformations using those data types

    data Expr = Num Int | BOp BTag Expr Expr | UOp UTag Expr
    data BTag = Add | Sub | Mult
    data UTag = Abs

    eval :: Expr -&gt; Int
    prettyPrint :: Expr -&gt; String

This makes it easy to add another function like prettyPrint without changing existing code. It makes it hard to add a new entry to BTag because all existing functions must change


In OOP you might start by defining an interface containing eval and prettyPrint. All operations/node types are classes which instantiate the interface. This makes it easy to add new classes, but hard to add new operations.

Easy/hard means if this is defined in a library do you have to fork it to extend behaviour or can you do it separately. In Haskell the action-based direction is often done using a monadic DSL, so you start by writing the monadic steps and have some opaque data in a State monad.


The monadic DSL approach is easier to generalize into something fully extensible, like the MTL library where you can define new actions and new types separately if you are willing to write some boilerplate. The data type-based version would be `trees that grow`. Note that both are fairly heavy-weight and should probably be avoided unless you are actually writing a library that must be extendable.",a02788f8824808e0df800eaa7ef64a5a1a5f58e8,True,False,,,,,0,1647604785,,0,{},i1554tk,False,t3_tgmr1x,False,True,t3_tgmr1x,/r/haskell/comments/tgmr1x/the_imperative_bit_in_functional_programming_is/i1554tk/,1647604799,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
653.0,[],False,,maerwald,,,[],,,,text,t2_t8qgl,False,False,"You can use `,` instead of `&amp;&amp;` in guards. Makes it even more readable:

```
foo
  | cond1
  ,  cond2 = bar
```",c1ed43e95f2bd4159a12c63d56d27c454b111c8c,True,False,,,,,0,1647604746,,0,{},i1552go,False,t3_tgj6ko,False,True,t1_i12qrhx,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i1552go/,1647604758,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
654.0,[],False,,olstrak,,,[],,,,text,t2_5mujb5oz,False,False,"&gt; This may just be a bias from having learned C first

It is, you're trying to port a C idiom to Haskell but this isn't what `(&amp;&amp;)` is intended to be. Haskell control flow is should be written using monadic constructs, which is what you did in your definition of `mAnd`, rather than relying on laziness. Using plain `Bool`s for control flow in Haskell is an example of ""boolean blindness"", it ignores the tools you're given by the type system. As a direct analogue to your example, you could do something like this:

`&gt; import Control.Monad.Trans.Maybe`
`&gt; falsify = putStrLn ""It is a falsehood."" &gt;&gt; return Nothing`
`&gt; verify = putStrLn ""Verily, it is so."" &gt;&gt; return (Just ())`
`&gt; runMaybeT (MaybeT falsify &gt;&gt; MaybeT verify)`
`It is a falsehood.`
`Nothing`

Here it's the `MaybeT IO` Monad that provides the control flow and stops after `falsify` fails, which is exactly what `MaybeT` is for. This is somewhat contrived to be directly analogous to your example, so it still isn't very idiomatic Haskell (for a start, `verify` should return something more meaningful than `Just ()`), but hopefully this will point you in the right direction.",7f1f393953e772c73494da721a9b7cbefbf70e74,True,False,,,,,0,1647604291,,0,{},i154bhx,False,t3_tfqpeg,False,True,t1_i12m0y4,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i154bhx/,1647604303,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
655.0,[],False,,TheActualMc47,,,[],,,,text,t2_om5ms0g,False,False,"That wouldn't make sense though (you can't change it for IO as it's actually supplied by compiler magic). Let's talk about the state monad instead. The order of computations in the state monad needs to be respected, so in the case of `liftM2` 

    do { x1 &lt;- m1; x2 &lt;- m2; return (f x1 x2) }

I want the effects of m1 to be in the final result. That's the only sane definition that makes sense",1baa97f92b6f8c563c014e8828ab75c5bc74cce2,True,False,,,,,0,1647593647,,0,{},i14qdwl,False,t3_tfqpeg,False,True,t1_i121y9v,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i14qdwl/,1647593658,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
656.0,[],False,,Opposite-Platypus-99,,,[],,,,text,t2_clsnehel,False,False,"to noobs and posterity : the solution above is  a _joke_, don't do this",3cdb8b714fe533e02cb25f7a531b93a421160e56,True,False,,,,,0,1647592247,,0,{},i14ot0e,False,t3_tdh2nn,False,True,t1_i0mf2z3,/r/haskell/comments/tdh2nn/pattern_matching_rps/i14ot0e/,1647592257,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
657.0,[],False,,sullyj3,,,[],,,,text,t2_5b0kp,False,False,Thanks!,1da20795f84bb9c5e16697aea34f14720e38fc37,True,False,,,,,0,1647590033,,0,{},i14m9xb,False,t3_tdt8cb,False,True,t1_i14iaew,/r/haskell/comments/tdt8cb/ann_ihphsx_jsxlike_templating_syntax_for_haskell/i14m9xb/,1647590045,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
658.0,[],False,,Runderground,,,[],,,,text,t2_sfa4k,False,False,"I would echo what others are saying that you are better off using functions from `Data.Text` for a real application. But since you are doing this as an exercise, here's a more idomatic implementation that stays true to the KMP algorithm (you know it's idomatic because it uses helper functions named `go` ). Note that since you only traverse the text you are searching through once, it's not actually a problem to use `String`, but I do use `Vector` for the prefix table.

    import Data.Vector (Vector)
    import qualified Data.Vector as V
    
    kmp :: String -&gt; String -&gt; Int
    kmp """" _ = -1
    kmp pat s = go 0 0 s
      where
        piTable :: Vector (Char, Int)
        piTable = mkTable pat
    
        go :: Int -&gt; Int -&gt; [Char] -&gt; Int
        go i j ccs | endOfPattern j = i - j
        go i j [] = -1
        go i j ccs@(c:cs)
          | c == charAt j = go (i+1) (j+1) cs
          | j == 0 = go (i+1) j cs 
          | otherwise = go i (backtrackJ j) ccs
    
        endOfPattern j = j == length pat
        charAt i = fst (piTable V.! i)
        backtrackJ j = max 0 (snd (piTable V.! (j-1)))
    
    mkTable :: String -&gt; Vector (Char, Int)
    mkTable """" = V.empty
    mkTable pat@(_:ps) = V.fromList $ zip pat piTable
      where
        piTable :: [Int]
        piTable = 0 : go 0 ps
    
        go :: Int -&gt; String -&gt; [Int]
        go j [] = []
        go j ccs@(c:cs)
          | c == charAt j = j+1 : go (j+1) cs
          | j == 0 = 0 : go j cs
          | otherwise = go (backtrackJ j) ccs
    
        patVec = V.fromList pat
        charAt i = patVec V.! i
        backtrackJ j = max 0 (piTable !! (j-1))",b03af7b9e8e6a5f2c267a81aa3453fbe1c82dc91,True,False,,,,,0,1647587628,,0,{},i14jex5,False,t3_tgj6ko,False,True,t3_tgj6ko,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i14jex5/,1647587641,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
659.0,[],False,,_query,,,[],,,,text,t2_fjd8s,False,False,"HSX was designed to be the primary view syntax for IHP. IHP is aimed at Haskell beginner's to allow haskell to reach a more mainstream audience. This audience typically hasn't used other haskell templating systems before, but is very likely familiar with the react ecosystem and JSX. To make it easy to start with, we then developed HSX :)",7e65f54e32b498024a863456aab0de1944b0b5ab,True,False,,,,,0,1647586700,,0,{},i14iaew,True,t3_tdt8cb,False,True,t1_i14amin,/r/haskell/comments/tdt8cb/ann_ihphsx_jsxlike_templating_syntax_for_haskell/i14iaew/,1647586710,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
660.0,[],False,,AmbroseHaskell,,,[],,,,text,t2_ioythzj0,False,False,Add type annotations to each variable and the answer will be clear.  You won't be able to.,5f681eafe267456656a2532ca2b55be0b8beb05b,True,False,,,,,0,1647583588,,0,{},i14ebtj,False,t3_tgu4fy,False,True,t3_tgu4fy,/r/haskell/comments/tgu4fy/im_having_issues_with_applicative_effects/i14ebtj/,1647583600,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
661.0,[],False,,Competitive_Ad2539,,,[],,,,text,t2_8g6liftg,False,False,"When you're applying f.e.

Increment :: Count (Int -&gt; String) 

To

countValue :: Count Int
countValue = Count 0 0

You're supposed to get a 

result :: Count String
But there were no real function (Int -&gt; String) applied, 0 stays the same, hence the type mismatch.",5f3ed6a79d9c9e6f16ec87d7714cb1ea151e0c65,True,False,,,,,0,1647583483,,0,{},i14e6t0,False,t3_tgu4fy,False,True,t3_tgu4fy,/r/haskell/comments/tgu4fy/im_having_issues_with_applicative_effects/i14e6t0/,1647583499,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
662.0,[],False,,slopersloper,,,[],,,,text,t2_skpm1,False,False,"wow, just what I needed. Many thanks ö7",6b5891d042fd28211395176ae5017296e82a8090,True,False,,,,,0,1647582161,,0,{},i14ce7b,False,t3_tgt2bb,False,True,t3_tgt2bb,/r/haskell/comments/tgt2bb/ann_servanttypescript_typescript_client/i14ce7b/,1647582172,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
663.0,[],False,,sullyj3,,,[],,,,text,t2_5b0kp,False,False,Nice! Is there anywhere I can read about the rationale for going with a JSX alike rather than one of the existing haskell templating systems like shakespeare?,204b846cc4c0839894ab4fb48950cc477bc419ad,True,False,,,,,0,1647580923,,0,{},i14amin,False,t3_tdt8cb,False,True,t3_tdt8cb,/r/haskell/comments/tdt8cb/ann_ihphsx_jsxlike_templating_syntax_for_haskell/i14amin/,1647580935,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
664.0,[],False,,lgastako,,,[],,,,text,t2_1mp2i,False,False,"You might find this implementation on Hackage which uses `Array`s interesting:

https://hackage.haskell.org/package/KMP-0.2.0.0/docs/src/Data.Algorithms.KMP.html",985c9457cea4e64b56fdcf6153c4f44a7ed3f4dd,True,False,,,,,0,1647579773,,0,{},i148wbr,False,t3_tgj6ko,False,True,t1_i12nbng,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i148wbr/,1647579785,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
665.0,[],False,,lgastako,,,[],,,,text,t2_1mp2i,False,False,"One answer I usually give for questions like this is `where` in the context of laziness.  You can write something like this:

    f :: Int -&gt; Int
    f n = if even n
            then cheapResult
            else expensiveResult
      where
        cheapResult     = cheapComputation
        expensiveResult = expensiveComputation

and `expensiveComputation` will only be computed if `n` is odd (and likewise `cheapComputation` will only be computed if `n` is even).

There are ways to do this in mainstream imperative languages, eg. making `cheapComputation` a function that has to be called, but none feel quite so natural, expressive or clear to me.",df6d5177349d85b1a5c62bb13c5a042394b81a30,True,False,,,,,0,1647578003,,0,{},i145zmt,False,t3_tgmr1x,False,True,t3_tgmr1x,/r/haskell/comments/tgmr1x/the_imperative_bit_in_functional_programming_is/i145zmt/,1647578018,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
666.0,[],False,,thomasjm4,,,[],,,,text,t2_ye2d7h4,False,False,"This post inspired me to finally package up my approach for this into a library I've called `servant-typescript` :). It relies on my `aeson-typescript` library.

You can find it on [Hackage](https://hackage.haskell.org/package/servant-typescript) and [GitHub](https://github.com/codedownio/servant-typescript).",1b7602b3a878a4d306e06076811a861ac059b873,True,False,,,,,0,1647576675,,0,{},i143nrj,False,t3_temn9b,False,True,t3_temn9b,/r/haskell/comments/temn9b/generate_typescript_from_servant_api/i143nrj/,1647576692,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
667.0,[],False,,cdsmith,,,[],,,,text,t2_1trov,False,False,"Yes, the Church-Rosser theorem proves confluence.  Effectively, ""confluent"" and ""Church-Rosser"" are synonyms.

You've got it right about non-deterministic order.  In general, lambda terms have either zero or one normal form, which (if it exists) is defined independently of the evaluation strategy because of the Church-Rosser theorem.  If you like, though, you can choose to impose a specific evaluation order on the system.

A simple general-purpose choice is normal-order evaluation, since this will always reach the normal form if it exists.  But in practice, normal-order evaluation is slow, so the compiler doesn't really do that.  First of all, it uses so-called ""lazy evaluation"", which exploits a richer pointer-based heap representation to retain some sharing when normal order evaluation would copy an expression.  You can't do lazy evaluation in pencil-and-paper lambda calculus; it needs a different graph-based representation to make sense.  Then there are optimizations like strictness analysis that change the evaluation order in cases where the compiler can prove it doesn't change the result.  In general, it's best to think about Haskell's actual evaluation order as being some evaluation strategy which (like normal order) is guaranteed to terminate if there's a normal form.",3463c2ba80fa0ada4b2b15668d19932912dc76bf,True,False,,,,,0,1647566621,,0,{},i13j4hv,False,t3_tgmr1x,False,True,t1_i13bbc1,/r/haskell/comments/tgmr1x/the_imperative_bit_in_functional_programming_is/i13j4hv/,1647566634,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
668.0,[],False,,SolaTotaScriptura,,,[],,,,text,t2_5dpnr08,False,False,"I think purity is what really makes things ""declarative"", because you *declare* values in terms of other values. You say what things are.

On the other hand, imperative programs are about issuing commands, i.e. in the *imperative* mood: ""put this thing over there"".

I don't think it's particularly useful to overload these terms with notions of evaluation, compilation, control flow, etc. It's just about whether you're programming with declarations or instructions.",50c3d6712875ee55162e08d13c47ff1b42ddfea0,True,False,,,,,0,1647565589,,0,{},i13gw3d,False,t3_tgmr1x,False,True,t3_tgmr1x,/r/haskell/comments/tgmr1x/the_imperative_bit_in_functional_programming_is/i13gw3d/,1647565607,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
669.0,[],False,,retief1,,,[],,,,text,t2_8l3wu,False,False,"AFAIK, ""what"" vs ""how"" is mostly down to the abstraction level used.  The classic comparison is comparing `fmap (+2) lst` in haskell to 

    for (int i = 0; i &lt; lst.length; i++) {
        lst[i] += 2;
    }

in an imperative language.  The haskell version is what (""map this function over this list"").  The imperative version is how (""go through each element of the list in order and set it to itself + 2"").

Of course, imperative languages do have iterator-style abstractions, so this isn't an entirely fair comparison.  That being said, functional languages tend to make much heavier use of first class functions in order to let you separate what you want to do from how it is done.  And if you are comparing that haskell code to `lst.map((val) =&gt; val + 2)`, then yeah, the two versions are similar, but that's because the js version is written in a functional style.",1b9a90ba886d3ef2e1304f35bd14f85f2e6e05f4,True,False,,,,,0,1647564988,,0,{},i13fl27,False,t3_tgmr1x,False,True,t3_tgmr1x,/r/haskell/comments/tgmr1x/the_imperative_bit_in_functional_programming_is/i13fl27/,1647565001,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
670.0,[],False,,leighscullyyang,,,[],,,,text,t2_jddda4f8,False,False,"Amazing, thanks!

&amp;#x200B;

&gt;There's a theorem, called the Church-Rosser theorem, which guarantees that any two valid evaluations of a lambda term that eventually terminate will give the same answer, but they may reach that answer in very different ways!

Is this the property of confluence?

&amp;#x200B;

&gt;In functional programming, that notional machine isn't so fully defined. It's non-deterministic.

By non-deterministic, do you mean that you've essentially got some abstract rewriting system where you could have { ... A ↦ B, A ↦ C ... }? Doesn't an rewriting/reduction strategy make it deterministic since you force it to make a choice (eg A ↦ C)?

&amp;#x200B;

&gt;it's sufficient to think about lambda calculus, and to choose any evaluation strategy that works.

I've seen that, in general, simple rewriting systems can lead to wildly complex behavior (see Wolfram). Or, in dynamical systems, seemingly simple non-linear differential equations can quickly generate chaos. I know there are formal mathematical proofs of termination/confluence for evaluation strategies used in FP, but I'm still a little suspicious about their robustness haha.",c64cf18d0b95d9e8bccd9430d110eb5726fe1e3e,True,False,,,,,0,1647563031,,0,{},i13bbc1,True,t3_tgmr1x,False,True,t1_i138unj,/r/haskell/comments/tgmr1x/the_imperative_bit_in_functional_programming_is/i13bbc1/,1647563042,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
671.0,[],False,,Straight_Doubt2866,,,[],,,,text,t2_g5ggaddw,False,False,"I don't understand what you're saying. All compilers have to parse expressions, even imperative ones. Languages like Haskell are just particularly focused on everything being an expression (as opposed to a statement, e.g. a while loop). Even in imperative languages, when you write this:

    int f(int a, int b, int c)
    {
        return a + (b * c) + (a * b);
    }

Clang compiles it into this intermediate representation before it compiles into assembly.
    
    define dso_local i32 @g(i32 noundef %0, i32 noundef %1, i32 noundef %2) #0 !dbg !22 {
      %4 = alloca i32, align 4
      %5 = alloca i32, align 4
      %6 = alloca i32, align 4
      store i32 %0, i32* %4, align 4
      call void @llvm.dbg.declare(metadata i32* %4, metadata !25, metadata !DIExpression()), !dbg !26
      store i32 %1, i32* %5, align 4
      call void @llvm.dbg.declare(metadata i32* %5, metadata !27, metadata !DIExpression()), !dbg !28
      store i32 %2, i32* %6, align 4
      call void @llvm.dbg.declare(metadata i32* %6, metadata !29, metadata !DIExpression()), !dbg !30
      %7 = load i32, i32* %4, align 4, !dbg !31
      %8 = load i32, i32* %5, align 4, !dbg !32
      %9 = load i32, i32* %6, align 4, !dbg !33
      %10 = mul nsw i32 %8, %9, !dbg !34
      %11 = add nsw i32 %7, %10, !dbg !35
      %12 = load i32, i32* %4, align 4, !dbg !36
      %13 = load i32, i32* %5, align 4, !dbg !37
      %14 = mul nsw i32 %12, %13, !dbg !38
      %15 = add nsw i32 %11, %14, !dbg !39
      ret i32 %15, !dbg !40
    }


There are actually a lot of temp variables from evaluating that expression, as well as mutation in the form of reassignment. You just see notice expressions more in Haskell because everything is an expression, not just arithmetic and bit shift operators. I don't really think of it as compiler magic, because this is what compilers are for.",07970cb5c3dcf30a4c1f32b86850f7a057397599,True,False,,,,,0,1647562506,,0,{},i13a4qh,False,t3_tgmr1x,False,True,t1_i1353ro,/r/haskell/comments/tgmr1x/the_imperative_bit_in_functional_programming_is/i13a4qh/,1647562517,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
672.0,[],False,,leighscullyyang,,,[],,,,text,t2_jddda4f8,False,False,"Ah yes thanks haha, just wanted to use simple a example, but you're absolutely right.",ab3b16762023434a516ec93d37feb3acb014236a,True,False,,,,,0,1647562141,,0,{},i139b8d,True,t3_tgmr1x,False,True,t1_i138y80,/r/haskell/comments/tgmr1x/the_imperative_bit_in_functional_programming_is/i139b8d/,1647562159,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
673.0,[],False,,AmbroseHaskell,,,[],,,,text,t2_ioythzj0,False,False,"The definition of `+` is what takes you from `2 + 1` to `3`. For performance and real-world reasons, it is ""magic""

But define peano numbers and it becomes substitution all the way down

   data N = Z | S N

    plus :: N -&gt; N -&gt; N
    plus Z n = n -- case 1
    plus n Z = n -- case 2
    plus (S n) m = plus n (S m) -- case 3

    plus (S (S Z)) (S Z) -- 2 + 1
    plus (S Z) (S (S Z)) -- substitution per case 3
    plus Z (S (S (S Z))) -- substitution per case 3
    (S (S (S Z))) --- substitution per case 1
    -- ^ we now have 3!",3f21ef2f83afcd459ef93b26ccaeb3188be87ad2,True,False,,,,,0,1647561979,,0,{},i138y80,False,t3_tgmr1x,False,True,t1_i1353ro,/r/haskell/comments/tgmr1x/the_imperative_bit_in_functional_programming_is/i138y80/,1647561990,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
674.0,[],False,,cdsmith,,,[],,,,text,t2_1trov,False,False,"I think you've got the right idea, *except* for the fact that programs aren't actually compiled this way.  Instead, they are compiled to implementations that are much more efficient on modern computers, but which are guaranteed to produce the same results.  A more conventional way of saying this is that functional programming is based on lambda calculus, which is ultimately a *specific* term rewriting system.  Again, it's not that the compiler *actually* produces code that manipulates strings of symbols defining lambda terms as you'd do on paper, but it's doing something equivalent.

Here's where things get a bit weirder, though.  Lambda calculus isn't an exact algorithm for evaluation.  Rather, at any given point, a lambda term can be evaluated in several different ways.  There's a theorem, called the Church-Rosser theorem, which guarantees that any two valid evaluations of a lambda term that eventually terminate will give the same answer, but they may reach that answer in very different ways!  This is similar to solving an algebra equation, where there might be different things you try - factoring here, distributing there, etc. - and some require a lot more work than others, but as long as you don't make a mistake, if you reach the solution, you'll find the same solution regardless of whether you followed the easy path or something rather more round-about.

In this sense, then, functional programming is fundamentally more declarative than imperative programming.  In imperative programming, you're given a model of what's sometimes called a *notional machine* \-- a specific idealized kind of automaton that ""runs"" your program with exact deterministic steps.  (Granted, the machine doesn't run that way in reality.  Compilers apply optimizations all the time that result in running different steps from the ones you wrote in your code.  Still, the ideal machine is what defines the correct behavior.)  In functional programming, that notional machine isn't so fully defined.  It's non-deterministic.

So here's the rub: if you want to know what it really is doing, then you get to dig around in the runtime system and how it represents values, thunks, and so on.  This kind of understanding is crucial if you want to understand the memory usage and performance of Haskell code... but it's **not** crucial if you only want to understand why the code produces the result that it does.  To understand the result of your code (at least your purely functional code), it's sufficient to think about lambda calculus, and to choose any evaluation strategy that works.",fc441a66d0a2b961d3209271befd4a0cdd88f16d,True,False,,,,,0,1647561934,,0,{},i138unj,False,t3_tgmr1x,False,True,t3_tgmr1x,/r/haskell/comments/tgmr1x/the_imperative_bit_in_functional_programming_is/i138unj/,1647561946,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
675.0,[],False,,Darwin226,,,[],,,,text,t2_byzre,False,False,"I don't think it's about the evaluation strategy at all. You can very well write the same thing I wrote in basically any mainstream language now and none of them use rewriting as their execution strategy. It's just about how you structure your program.

There's no Haskell magic in the `filter isPrime [1..]` expression (except for the lazy infinite list but you can ignore that). `filter` is a function, `isPrime` is a function, `[1..]` is a list. If you look at the definitions of those functions you'll just find more normal functions.",0e2808179586cdc08b2d17e2e8bad497b9579529,True,False,,,,,0,1647560562,,0,{},i135rts,False,t3_tgmr1x,False,False,t1_i1353ro,/r/haskell/comments/tgmr1x/the_imperative_bit_in_functional_programming_is/i135rts/,1647560577,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
676.0,[],False,,leighscullyyang,,,[],,,,text,t2_jddda4f8,False,False,"Thanks for your response!

Yeah I can see how describing what the values actually are is quite nice when programming. But to get the program to work, doesn't there need something that takes an expression from one form to another? eg

```
    (\x -&gt; x + 1)(2)
    2 + 1 [substitution]
    3 [evaluation]

```

This feels a lot like state transition to me, but instead of a state transition function, we have some rewriting/reduction strategy. And so far, reduction algorithms I've seen have an imperative flavor to them.",484415bd4fe7310832f6f2106b322f6679fc92a6,True,False,,,,,0,1647560271,,0,{},i1353ro,True,t3_tgmr1x,False,True,t1_i1333eg,/r/haskell/comments/tgmr1x/the_imperative_bit_in_functional_programming_is/i1353ro/,1647560283,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
677.0,[],False,,Straight_Doubt2866,,,[],,,,text,t2_g5ggaddw,False,False,"For example, the way you would add one to every element of a list or array in C would be this:

    void add_one(int *arr, size_t n)
    {
        int i;

        for (i = 0; i &lt; n; i++)
            arr[n] += 1;
    }

Here, not only are you specifying that you want to add one to all the elements of an array, but you're saying that you want to do it in a sequential order starting from the address at `arr` and ending at the address at `arr + n`. Also, you're writing one function for a particular type of array.

In Haskell, you'd do this:

    newList = map (+1) oldList

You aren't specifying anything at all, except that you want to add one to every element of the list, no matter how, and you're doing it with composable higher order functions. `map` takes a function and a list, and returns a new list with the transformation applied by the function. `(+1)` is a function we just wrote on the spot using Haskell's + operator. You also could have written that as (\x -&gt; x + 1).",8b49b5759d2c707a5528f6ffb06ff16c9b29e505,True,False,,,,,0,1647559791,,0,{},i133zs4,False,t3_tgmr1x,False,True,t3_tgmr1x,/r/haskell/comments/tgmr1x/the_imperative_bit_in_functional_programming_is/i133zs4/,1647559809,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
678.0,[],False,,Darwin226,,,[],,,,text,t2_byzre,False,False,"It's about being more declarative than operational. It's not about compiler magic.

Various features of the language and the functional programming style allow you to structure your code so you're more directly describing what your values _are_ rather than how to produce them.

The usual examples are list transformers like:

    primes = filter isPrime [1..]

declares what primes is. It's a list of natural number where you only keep primes. It doesn't get into the lower level details about iteration, or taking values from one list and putting them into the other one or anything.",934f0cdf4822d265b0fb30401d0551d2bb24d0f1,True,False,,,,,0,1647559399,,0,{},i1333eg,False,t3_tgmr1x,False,True,t3_tgmr1x,/r/haskell/comments/tgmr1x/the_imperative_bit_in_functional_programming_is/i1333eg/,1647559410,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
679.0,[],False,,Endicy,,,[],,,,text,t2_mz4isnd,False,False,"Like other said, indexing feels really wrong to do with linked lists. Either don't use linked lists, or don't do it via indexing.

On just a readability standpoint, I see you're guarding in the following pattern:

    func a b =
      | a &amp;&amp; b &amp;&amp; c = doABC
      | a &amp;&amp; b = doAB
      | a = doA
      | otherwise = doOther

This makes for super long guards and ALSO potentially re-evaluating `a` in every guard. In this case reverse the logic:

    func a b =
      | !a = doOther
      | !b = doA
      | !c = doAB
      | otherwise = doABC

This does exactly the same thing without all the `&amp;&amp;` in there. To show the difference with your provided code (and some easy use of `where`):

    findPat :: String -&gt; String -&gt; Int -&gt; Int -&gt; [Int] -&gt; [Int]
    findPat txt pat indexTxt indexPat mIndexes
      | indexTxt &gt;= length txt = mIndexes
      | calcPref &lt; 0 =
          loop (indexTxt + 1) (calcPref + 1) mIndexes
      | pat !! indexPat /= txt !! indexTxt =
          loop indexTxt calcPrefix mIndexes
      | (indexPat + 1) /= length pat =
          loop (indexTxt + 1) (indexPat + 1) mIndexes
      | otherwise =
          loop (indexTxt + 1) (calcPref + 1) (mIndexes ++ [(indexTxt + 1) - (indexPat + 1)])
      where
        loop = findPat txt pat
        calcPref = calcPrefix pat 1 0 [] !! indexPat

So one key ""learning"" here: Instead of checking for the same thing over and over, check for _the opposite_ once, and then everything after is implied to be True.",7012e7cdaeaa6fb18bfec413462a13395134f96d,True,False,,,,,0,1647555862,,0,{},i12urzo,False,t3_tgj6ko,False,False,t3_tgj6ko,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i12urzo/,1647555879,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
680.0,[],False,,EntrepreneurAmazing4,,,[],,,,text,t2_812xilv1,False,False,"I see, I understand now. Thanks!",604ca8e5c77d5bc06df806a1c55956712f1f4e40,True,False,,,,,0,1647555836,,0,{},i12uppa,True,t3_tgj6ko,False,True,t1_i12sbr8,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i12uppa/,1647555850,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
681.0,[],False,,SolaTotaScriptura,,,[],,,,text,t2_5dpnr08,False,False,Thanks!,1da20795f84bb9c5e16697aea34f14720e38fc37,True,False,,,,,0,1647554895,,0,{},i12sfo5,False,t3_t3zw0x,False,False,t1_i10lpju,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i12sfo5/,1647554909,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
682.0,[],False,,Defrigeration,,,[],,,,text,t2_ghrwv,False,False,"If you were telling a person what your algorithm does, or answering the question ""what is this for?"", you would not talk about loops or the !! operator or adding 1 to i. You would something like: the result is the location of the pattern in the string. You might then explain further what that means by more definitions (of how to find a location, etc). 

It was not meant as specific advice about how to do the task, but how you should think about code when you are trying to write in a functional style.

For a simpler example, suppose you wanted the average of a list of numbers. In functional style you'd think of that as writing code that says: the average is the sum of the numbers divided by how many there are. 
average lst = (sum lst) / length(lst)
The procedural way of thinking about it is: To find the average, set aside some space for your running total. For each element in the list, add it to your running total. Then divide your total by the number of elements in your list. 
Since we don't care about the order in which the the numbers are added, or where the running total is stored, we don't need to talk about it and we can let the compiler figure out those details.",97f2a16833e4d8cf5ec9a8ad0f651ad1394a0f42,True,False,,,,,0,1647554851,,0,{},i12sbr8,False,t3_tgj6ko,False,True,t1_i12lcj0,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i12sbr8/,1647554864,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
683.0,[],False,,EntrepreneurAmazing4,,,[],,,,text,t2_812xilv1,False,False,"Thanks, that's something I didn't think of doing but makes alot of sense.",f5697f806bc6e957e7f1ce014fe438e3c71fda83,True,False,,,,,0,1647554464,,0,{},i12rcxn,True,t3_tgj6ko,False,True,t1_i12qrhx,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i12rcxn/,1647554476,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
684.0,[],False,,cdsmith,,,[],,,,text,t2_1trov,False,False,"You should definitely pay attention to the deeper advice you've gotten here... but here's something easy.  Pick your anomalous cases and test for them first, so that you don't need to exclude them in remaining branches.  For example, you wrote:

    findPat txt pat indexTxt indexPat mIndexes
      | indexTxt &lt; length txt &amp;&amp;
        pat !! indexPat == txt !! indexTxt &amp;&amp;
        (indexPat + 1) == length pat
        = ...
      | indexTxt &lt; length txt &amp;&amp;
        pat !! indexPat == txt !! indexTxt
        = ...
      | indexTxt &lt; length txt &amp;&amp;
        (calcPrefix pat 1 0 \[\] !! indexPat) &lt; 0
        = ...
      | indexTxt &lt; length txt
        = ...
      | otherwise = mIndexes

Clearly you should just handle the case where `indexTxt &gt;= length txt` up front:

    findPat txt pat indexTxt indexPat mIndexes
      | indexTxt &gt;= length txt = mIndexes
      ...

This shortens every one of your remaining cases.",807f65f588e7abbc432c733fa2c6a464d2ebe786,True,False,,,,,0,1647554226,,0,{},i12qrhx,False,t3_tgj6ko,False,True,t3_tgj6ko,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i12qrhx/,1647554243,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
685.0,[],False,,EntrepreneurAmazing4,,,[],,,,text,t2_812xilv1,False,False,Thanks for the tips! Will definitely look if I can implement these.,6d496fbf50ec8f93ef5e63b9dd0a624291f76a08,True,False,,,,,0,1647554009,,0,{},i12q88a,True,t3_tgj6ko,False,True,t1_i12phdw,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i12q88a/,1647554026,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
686.0,[],False,,bbdbdd,,,[],,,,text,t2_mn9upet,False,False,"Some ideas for incrementally improving this:

- break some of the long lines, particularly after the `=` of the guards
- the ""null array"" basecase in ""calcPrefix"" is weird, it seems it would be nicer to remove that and instead pass in the empty array from ""findPat"" (though I may be missing some need for the way things are)
- you could have the recursive base cases first (""i &gt;= length pat = array"") instead of the ""otherwise"", and drop the length check from the other cases
- looks to me like you might be able to get away with changing the ""array"" type from ""[Int]"" to ""Int -&gt; Int"" (i.e., the array's lookup function)",0252979b6e9aab0d1cbc8e4305bc266a341730cb,True,False,,,,,0,1647553716,,0,{},i12phdw,False,t3_tgj6ko,False,True,t3_tgj6ko,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i12phdw/,1647553734,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
687.0,[],False,,Defrigeration,,,[],,,,text,t2_ghrwv,False,False,"The value returned by putStrLn was never at issue. I don't understand why you bring that up. What's misleading is the suggestion that it works like imperative languages do. If I had 

    x = 0 &amp;&amp; (printf(""something""); 0)

in C, that ""something"" never gets printed.",7b62778ce5adff1afb1c8c643e70428b79634581,True,False,,,,,0,1647553134,,0,{},i12nzpo,True,t3_tfqpeg,False,True,t1_i12iyxi,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i12nzpo/,1647553146,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
688.0,[],False,,EntrepreneurAmazing4,,,[],,,,text,t2_812xilv1,False,False,"I see, that's definitely handy advice.",f48a142b8d2ba34c58b2051b26a6f2e2ee4626a4,True,False,,,,,0,1647552871,,0,{},i12nbng,True,t3_tgj6ko,False,True,t1_i12n2v3,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i12nbng/,1647552883,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
689.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"Still, don't use `[]` for indexing.  It's not an array.  Use `Array` or `Vector`.",2ff6a657d9ac23ad3a749c94f681cf2624d5794d,True,False,,,,,0,1647552778,,0,{},i12n2v3,False,t3_tgj6ko,False,True,t1_i12mhhi,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i12n2v3/,1647552791,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
690.0,[],False,,EntrepreneurAmazing4,,,[],,,,text,t2_812xilv1,False,False,"Thanks for the advice. But this is basically an exercise for me to get better familiarity with Haskell &amp; functional programming. I already knew ""isPrefixOf"" etc existed, but I wanted to write my own function(that I already wrote in python) and convert it to Haskell code.",f4efb81f9aafcb0c2c58287602864431e36a3caa,True,False,,,,,0,1647552547,,0,{},i12mhhi,True,t3_tgj6ko,False,True,t1_i12lm5p,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i12mhhi/,1647552565,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
691.0,[],False,,Defrigeration,,,[],,,,text,t2_ghrwv,False,False,"Well, what one would like is a question of taste and application. I would want liftM to preserve the strictness or laziness of the function it's lifting. This may just be a bias from having learned C first, but as mentioned, short circuiting in the logical operators can be used for flow control. e.g.

`askUserPermissionFor(thing) &amp;&amp; doThe(thing)`

Not only that, the State monad does the same thing. So if I have an expensive stateful computation on the right hand side, I expect liftedAnd to be smart enough to avoid it when possible because (&amp;&amp;) is.

Perhaps you can give an example of a monad that acts differently?",c0c062b6f6e79fac55dd2351f928f3ad518d5dc1,True,False,,,,,0,1647552371,,0,{},i12m0y4,True,t3_tfqpeg,False,True,t1_i12h0um,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i12m0y4/,1647552390,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
692.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"KMP isn't good for linked-lists.  You might want to implement it for vectors / arrays, but not for `String`.

    findSubstring :: String -&gt; String -&gt; [Int]
    findSubstring needle haystack =
      findIndices (isPrefixOf needle) $ tails haystack

-

    &gt; findSubstring ""abc"" ""abcxxxabcd""
    [0,6]

It's not _perfect_, but I think that it's the best asymptotic time you get for linked lists because you can't actually skip elements entirely; unconsing still has costs.",43ff9a2a05666998c187f90e8dca9a7c57eb30cf,True,False,,,,,0,1647552213,,0,{},i12lm5p,False,t3_tgj6ko,False,True,t1_i12i5v9,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i12lm5p/,1647552225,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
693.0,[],False,,EntrepreneurAmazing4,,,[],,,,text,t2_812xilv1,False,False,"Thanks for the advice, definitely helpful. 

&gt;Do not express your function in terms of the steps to compute it (indices, loops, etc). That is for the compiler to figure out. Instead, think about what defines the result you want.

Not sure I understand this one, maybe it's my lack of functional programming knowledge. But I don't understand how I would do that. After all, when I think of an solution to a problem, surely I can't just do that without first describing(or programming) the steps to make that solution a reality. And surely the compiler will also need those steps to define what result I want?",dcb055c66a720affea936cdc8b09434b2908a3e5,True,False,,,,,0,1647552109,,0,{},i12lcj0,True,t3_tgj6ko,False,True,t1_i12jp24,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i12lcj0/,1647552126,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
694.0,[],False,,hirep14316,,,[],,,,text,t2_gfsopjc1,False,False,Graves is just a device that is worth buying,0f2b42c95317ee69e51637d907c75b5ecc42abbb,True,False,,,,,0,1647551861,,0,{},i12kpcd,False,t3_t85efq,False,True,t1_hztqetw,/r/haskell/comments/t85efq/best_and_most_current_library_for_functional/i12kpcd/,1647551875,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
695.0,[],False,,Defrigeration,,,[],,,,text,t2_ghrwv,False,False,"If you were translating from English, to Spanish, you wouldn't translate the idiom ""a piece of cake"" to it's literal equivalent: even if it's grammatically correct, it doesn't convey the same meaning (facil). Similarly, if you are rewriting code from an imperative language to a functional one, you not only need to think about the differences in syntax, but also the differences in imperative versus functional style. So, some ideas:

1. functional thinking: Do not express your function in terms of the steps to compute it (indices, loops, etc). That is for the compiler to figure out. Instead, think about what defines the result you want.
2. recursion: Can you define the result of your function on some input in terms of that same function on some smaller piece or pieces of that input, then combine?
3. functional building blocks: Can you define the result of your function in terms of the usual functional tools, like map, fold, and filter? (fold is called reduce in python) Have you looked through the standard library for something that may help you, or for something that does almost what you need that you could adapt? This is what some people in your previous post were pointing to.
4. using the idioms of the new language: If your guards are too long, can you maybe express more of what you're doing with the pattern match left of the guard. Haskell lets you easily define helper functions internal to the scope of the main one with let and where. Perhaps that would help by breaking it up into smaller pieces that can be reused. Haskell strings are lists of characters. That makes it easy to treat strings as lists with : and ++, which may let you remove some use of subscripts.",1db215c1d7162d0e173cb8dc9619278984da6207,True,False,,,,,0,1647551474,,0,{},i12jp24,False,t3_tgj6ko,False,True,t3_tgj6ko,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i12jp24/,1647551490,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
696.0,[],False,,ysangkok,,,[],,,,text,t2_4qktt,False,False,"The value produced by putStrLn is a unit, and that value is indeed ignored. If you made putStrLn return undefined instead, `&gt;&gt;` would make sure the undefined never got evaluated. I don't understand how the statement is wrong.

You are not getting to the second action without performing the first. The fact that a monadic action can produce values that are themselves not evaluated doesn't seem to change that to me.",b6fa7ad3767dbcbe45216fb9b93f93729e5e286a,True,False,,,,,0,1647551192,,0,{},i12iyxi,False,t3_tfqpeg,False,True,t1_i0yjntr,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i12iyxi/,1647551208,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
697.0,[],False,,EntrepreneurAmazing4,,,[],,,,text,t2_812xilv1,False,False,"I added the entire code to my description! It's the KMP Algorithm(although it might be hard to see with how unreadable the code is). If you're not familiar with KMP, it basically finds patterns in texts you give it, so for example:

pattern to search: ""abc""

text: ""abcxxxabcd""

If I insert that into my function it will find the pattern at indices [0,6] of my text.",8fc368ba11500cd32f11ad4325cae3b9a100c049,True,False,,,,,0,1647550878,,0,{},i12i5v9,True,t3_tgj6ko,False,True,t1_i12hc94,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i12i5v9/,1647550889,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
698.0,[],False,,lomendil,,,[],,,,text,t2_bs6eo,False,False,"I agree we could use the full function and more details. From you wrote though, it looks like a redesign is in order. You appear to be comparing text with a pattern, using an index. Is the recursion for backtracking?

The first thing I'd do is check `Data.Text` for a function that does what you want to do. Assuming you are using `String`, tough, have a look at `Data.List`.

Otherwise, you'll likely want to move away from using indexes and instead work on the `head:tail` structure of a list/string. You don't need to check the length of the string, just have a case for `[]`, etc.

But really, this is probably not helpful without seeing your whole function.",e86dc8166a3359825c6a505e1c05159234742715,True,False,,,,,0,1647550567,,0,{},i12hc94,False,t3_tgj6ko,False,True,t3_tgj6ko,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i12hc94/,1647550577,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
699.0,[],False,,maonue,,,[],,,,text,t2_69rv9kya,False,False,"&gt; Would someone please explain why liftM2 behaves this way?

Indeed, that is exactly how one would like it to behave for the `IO` monad! `IO` forces everything, i.e. all arguments. 

&gt; Am I missing some key fact about liftM2? Perhaps I am not using it in the intended way.

It depends on the monad in question

    λ:&gt; (&amp;&amp;) &lt;$&gt; Just False &lt;*&gt; Just undefined
    Just False",c13ccdb94f86927463b3a3bc31e392354e2e6a69,True,False,,,,,0,1647550446,,0,{},i12h0um,False,t3_tfqpeg,False,True,t3_tfqpeg,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i12h0um/,1647550465,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
700.0,[],False,,EntrepreneurAmazing4,,,[],,,,text,t2_812xilv1,False,False,"    createEmptyArray :: String -&gt; [Int]
    createEmptyArray v = -1 : [0 | x &lt;- [1 .. (length v)]]
    
    replace :: Int -&gt; a -&gt; [a] -&gt; [a]
    replace pos newVal list = take pos list ++ newVal : drop (pos + 1) list
    
    calcPrefix :: String -&gt; Int -&gt; Int -&gt; [Int] -&gt; [Int]
    calcPrefix pat i prefixLength array
      | null array = calcPrefix pat i prefixLength (createEmptyArray pat)
      | i &lt; length pat &amp;&amp; pat !! prefixLength == pat !! i = calcPrefix pat (i + 1) (prefixLength + 1) (replace (i + 1) (prefixLength + 1) array)
      | i &lt; length pat &amp;&amp; prefixLength &gt; 0 = calcPrefix pat i (array !! prefixLength) array
      | i &lt; length pat = calcPrefix pat (i + 1) prefixLength (replace (i + 1) 0 array)
      | otherwise = array
    
    findPat :: String -&gt; String -&gt; Int -&gt; Int -&gt; [Int] -&gt; [Int]
    findPat txt pat indexTxt indexPat mIndexes
      | indexTxt &lt; length txt &amp;&amp; pat !! indexPat == txt !! indexTxt &amp;&amp; (indexPat + 1) == length pat = findPat txt pat (indexTxt + 1) (calcPrefix pat 1 0 [] !! indexPat + 1) (mIndexes ++ [(indexTxt + 1) - (indexPat + 1)])
      | indexTxt &lt; length txt &amp;&amp; pat !! indexPat == txt !! indexTxt = findPat txt pat (indexTxt + 1) (indexPat + 1) mIndexes
      | indexTxt &lt; length txt &amp;&amp; (calcPrefix pat 1 0 [] !! indexPat) &lt; 0 = findPat txt pat (indexTxt + 1) (calcPrefix pat 1 0 [] !! indexPat + 1) mIndexes
      | indexTxt &lt; length txt = findPat txt pat indexTxt (calcPrefix pat 1 0 [] !! indexPat) mIndexes
      | otherwise = mIndexes

Like I said, it's not very readable, so apologies in advance!

It's the KMP Algorithm, not sure how familiar you are with it? It basically searches for patterns in texts, for example:

pattern to search: ""abc""

text: ""abcxxxabcd""

If I insert that into my function it will find the pattern at indices [0,6] of my text.",c059fe6cc6b75014d752707af0533fbdf5af45d9,True,False,,,,,0,1647550304,,0,{},i12gnd2,True,t3_tgj6ko,False,True,t1_i12fie1,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i12gnd2/,1647550328,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
701.0,[],False,,cumtv,,,[],,,,text,t2_5hw1vsu3,False,False,Can you give the full function and describe what it's supposed to do?,be00c9d2af7285af07ee7eb3e3a12bb77ca8954c,True,False,,,,,0,1647549867,,0,{},i12fie1,False,t3_tgj6ko,False,True,t3_tgj6ko,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i12fie1/,1647549879,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
702.0,[],False,,[deleted],,,,,,dark,,,,,[removed],fe993932d6dced4c0a879e9aa5d7a6e0fbb467f5,True,False,,,,,0,1647549368,,0,{},i12e7jh,False,t3_tgj6ko,False,True,t3_tgj6ko,/r/haskell/comments/tgj6ko/making_my_haskell_function_more_readable/i12e7jh/,1647549382,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
703.0,[],False,,Defrigeration,,,[],,,,text,t2_ghrwv,False,False,"If that's true, can you demonstrate an alternate definition of `&gt;&gt;=` for IO which acts differently (while using the same definition of `liftM2`)?",0a2b26183554548fe59f33924c043ac080c285a1,True,False,,,,,0,1647544706,,0,{},i121y9v,True,t3_tfqpeg,False,True,t1_i11xnek,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i121y9v/,1647544718,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
704.0,[],False,,TheActualMc47,,,[],,,,text,t2_om5ms0g,False,False,"It absolutely is! As with the IO Monad, you want to conserve the order of changes to the state, and the bind operator is implemented accordingly. The binding is just syntactic sugar for, well, the bind operator",0b569df87686bec29a251c3c2216a04810b40afe,True,False,,,,,0,1647543030,,0,{},i11xnek,False,t3_tfqpeg,False,True,t1_i11ujgd,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i11xnek/,1647543047,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
705.0,[],False,,Defrigeration,,,[],,,,text,t2_ghrwv,False,False,"Thanks for the article. However, as mentioned, I first noticed this behaviour in the context of the `State` monad. I noticed that a computation was happening on both sides of my `liftedAnd` that was affecting my state which was not needed to compute the boolean return value. I tried it out with the `IO` monad as well and that's the version I showed here, because it's easier for people to try. As others have pointed out, it happens due to the binding `x2 &lt;- m2` in the code for `liftM2` you show above. It is *not* specific to the definition of `&gt;&gt;=` for the `IO` monad.",5a31d536a475993c7ba1d44a74248ddc446c90f8,True,False,,,,,0,1647541848,,0,{},i11ujgd,True,t3_tfqpeg,False,True,t1_i10257z,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i11ujgd/,1647541863,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
706.0,[],False,,[deleted],,,,,,dark,,,,,[removed],fe993932d6dced4c0a879e9aa5d7a6e0fbb467f5,True,False,,,,,0,1647539759,,0,{},i11p27p,False,t3_t3zw0x,False,True,t3_t3zw0x,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i11p27p/,1647539771,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
707.0,[],False,,nxnt,,,[],,,,text,t2_we1z6qx,False,False,Thanks. This seems quite interesting.,2a9d2f1e3a5d4ae4908332bc80343dea06e7bcb5,True,False,,,,,0,1647537161,,0,{},i11i8rs,True,t3_tff9it,False,True,t1_i0w70g6,/r/haskell/comments/tff9it/is_there_a_way_to_compare_the_associated_type_in/i11i8rs/,1647537173,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
708.0,[],False,,[deleted],,,,,,dark,,,,,[deleted],228f7d207920fb84335fac5b2b06ed7b472ece9e,True,False,,,,,0,1647530581,,0,{},i1114w5,False,t3_sgw3yb,False,True,t1_i10txed,/r/haskell/comments/sgw3yb/this_hls_binary_does_not_support_template_haskell/i1114w5/,1647530597,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
709.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,TIL!  That seems an odd choice.,177df9a8573e852f810a094c6921e67b5637f37d,True,False,,,,,0,1647529057,,0,{},i10xdhw,False,t3_t3zw0x,False,True,t1_i10v2sh,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i10xdhw/,1647529073,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
710.0,[],False,,sjakobi,,,[],,,,text,t2_sbvuw,False,False,[`IntMap.size`](https://hackage.haskell.org/package/containers-0.6.5.1/docs/Data-IntMap-Strict.html#v:size) is `O(n)`!,152639afbe6beab3fce3a6fdb8523be62abb2134,True,False,,,,,0,1647528123,,0,{},i10v2sh,False,t3_t3zw0x,False,True,t1_i0ieezu,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i10v2sh/,1647528138,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
711.0,[],False,,Martinsos,,,[],,,,text,t2_bng1b,False,False,"Its not, I also got it in (spac)emacs!",d47054ac8085d69032960b3004bed7b0e68c281d,True,False,,,,,0,1647527643,,0,{},i10txed,False,t3_sgw3yb,False,True,t1_hv0rd0t,/r/haskell/comments/sgw3yb/this_hls_binary_does_not_support_template_haskell/i10txed/,1647527656,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
712.0,[],False,,WhistlePayer,,,[],,,,text,t2_1ca69xys,False,False,"It's highly recommended to use an editor designed for writing code. [VS Code](https://code.visualstudio.com/) is a very popular option for Haskell and it provides a lot of additional features including Haskell support via the [Haskell](https://marketplace.visualstudio.com/items?itemName=haskell.haskell) extension. If you're just looking for something bare bones that just edits text, something like [Notepad++](https://notepad-plus-plus.org/downloads/) could also be fine.",27ac6e3dd35e14a65d1cb3d7611b32d6cb3c6a9b,True,False,,,,,0,1647524933,,0,{},i10nm7q,False,t3_t3zw0x,False,True,t1_i0yqqrr,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i10nm7q/,1647524949,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
713.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"Last time I was using MS Windows, I had the file manager set to show extensions, and I would rename .txt to .hs that way, or failing that use Cygwin or GitBash to `mv` the files from the old name to the new name.

But, I've never actually used MS Windows 10/11.  I last used MS Windows for work, and was able to switch to Linux for that role before we were allowed to upgrade to MS Windows 10.",4569f71fae01db2d20b63e0674f3cf162e6fdc55,True,False,,,,,0,1647524527,,0,{},i10mpp8,False,t3_t3zw0x,False,True,t1_i10aqnw,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i10mpp8/,1647524540,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
714.0,[],False,,ocharles,,,[],,,,text,t2_9ojk6,False,False,"See also the excellent blog post ""Parse, Don't Validate""' https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/",d8d637970eda9c7aef7d791b4055df3ba0821225,True,False,,,,,0,1647524388,,0,{},i10mete,False,t3_tfkteo,False,True,t1_i0x5oif,/r/haskell/comments/tfkteo/is_there_a_better_pattern_for_return_just_some/i10mete/,1647524405,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
715.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"Sometimes a generalization to star semigroups is quite powerful http://r6.ca/blog/20110808T035622Z.html

But, I think specializing to list here also isn't _bad_, especially if it helps inference.  `[a]` is effectively the free monoid over a, so it's not imposing much structure, and hopefully laziness and good consumption will prevent too much overhead if you do need to impose additional structure.",732bb940d0fd3cbd780b25e57d8c84779d62f0c7,True,False,,,,,0,1647524352,,0,{},i10mbwt,False,t3_t3zw0x,False,True,t1_i0zj9dp,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i10mbwt/,1647524369,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
716.0,[],False,,WhistlePayer,,,[],,,,text,t2_1ca69xys,False,False,"Often for these kinds of things, the [`Alternative`](https://hackage.haskell.org/package/base-4.16.0.0/docs/Control-Applicative.html#t:Alternative) class is used. For lists, the `Alternative` operations are the same as the `Monoid` operations.

Also, if all you're using these for are lists, you might be interested in `Control.Applicative.many` and `Data.Maybe.maybeToList`. `many` isn't exactly the same as your `star` but you may be able to use it for the same purpose depending on how you're using `star`.",e496caca4737c60ed6f063add66b7269e401dbb9,True,False,,,,,0,1647524062,,0,{},i10lpju,False,t3_t3zw0x,False,True,t1_i0zj9dp,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i10lpju/,1647524076,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
717.0,[],False,,Thomasvoid,,,[],,,,text,t2_14v06h,False,False,"On windows 10 you *can* use the native os, but I don't recommend you do. I'm not sure where you are finding difficult in the .txt -&gt; .hs, but it shouldn't cause much issue. What I recommend is using WSL2 for most things coding, as the Haskell ecosystem thrives on linux",2279ff950901953fc716e532cbdca88fddef437a,True,False,,,,,0,1647518292,,0,{},i10aqnw,False,t3_t3zw0x,False,True,t1_i0yqqrr,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i10aqnw/,1647518309,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
718.0,[],False,,MorrowM_,,,[],,,,text,t2_6l7exkda,False,False,"One issue you may run into is that this _can't_ be done with the `Applicative` instance alone, so you can't implement this with only `&lt;$&gt;`, `&lt;*&gt;`, `pure`, `liftA2`, etc. Or the monad equivalents such as `liftM`, `liftM2` and `ap` (since they do the same thing and frankly should mostly not be used anymore outside of bootstrapping `Applicative` instances). You'd need to use something like `&gt;&gt;=` or `join` etc. The difference between `Applicative` and `Monad` is that a `Monad` is powerful enough to let you branch on the result of a previous action, while `Applicative` just lets you set aside a bunch of actions to be run in parallel, yielding their results. So something like `f x y = x &gt;&gt;= \res -&gt;  if res then y else pure False` can't be done with applicative alone, since whether `y` is run depends on the result of `x`. You might be able to see why this is the case by considering this equivalent definition of the `Applicative` type class:

    class Functor f =&gt; Applicative f where
      pure :: a -&gt; f a
      (&lt;,&gt;) :: f a -&gt; f b -&gt; f (a, b)

(`(&lt;,&gt;)` is just `liftA2 (,)`)

So `&lt;,&gt;` can combine two actions into one, but it gives you no way of branching on the result of one of the actions, all you can do is build up larger and larger actions.",4d82c860149c170823bbbfde37a875177b2b35e6,True,False,,,,,0,1647516298,,0,{},i107l3g,False,t3_tfqpeg,False,True,t1_i0ye8ly,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i107l3g/,1647516310,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
719.0,[],False,,riftdc,,,[],,,,text,t2_10kz2q,False,False,that’s awesome!,49ada636b2522739735c4647b83ac1edbae1e7b2,True,False,,,,,0,1647512676,,0,{},i102jtp,False,t3_tfkteo,False,True,t1_i0x82zy,/r/haskell/comments/tfkteo/is_there_a_better_pattern_for_return_just_some/i102jtp/,1647512690,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
720.0,[],False,,TheActualMc47,,,[],,,,text,t2_om5ms0g,False,False,"This actually a very interesting post! This has nothing to do with`liftM2`, it's just how the `&gt;&gt;=` operator for the IO Monad is implemented. To drive the point home, let's look at the implementation of `liftM2`:

    liftM2  :: (Monad m) =&gt; (a1 -&gt; a2 -&gt; r) -&gt; m a1 -&gt; m a2 -&gt; m r
    liftM2 f m1 m2          = do { x1 &lt;- m1; x2 &lt;- m2; return (f x1 x2) }

That looks harmless, it does nothing more than it promises to do, and it doesn't make any assumptions about the underlying monad.

The thing about IO is that you want certain things to happen **immediately**. Things like printing something on the console or interacting with the operating system. The bind operator is implemented in a way that respects these assumptions. I advise looking at this [great article](https://www.fpcomplete.com/haskell/tutorial/primitive-haskell/) if you want to dig deeper.",22546dd78bc448e80ab2a9bdd72886ba9c4544b4,True,False,,,,,0,1647512365,,0,{},i10257z,False,t3_tfqpeg,False,False,t3_tfqpeg,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i10257z/,1647512380,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
721.0,[],False,,imihnevich,,,[],,,,text,t2_gtbhi7wu,False,False,"I don't know what is the real reason you want to do it in a ""better way"" but if you just wanna safe division the better way is to pattern match for 0. All of the examples look like overcomplicated fizzbuzz

KISS",7921740239db1bf2647eb590e10294402e4ed248,True,False,,,,,0,1647509145,,0,{},i0zy7eh,False,t3_tfkteo,False,True,t3_tfkteo,/r/haskell/comments/tfkteo/is_there_a_better_pattern_for_return_just_some/i0zy7eh/,1647509159,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
722.0,[],False,,rustyrush,,,[],,,,text,t2_2yvepzwa,False,False,Really good visualizations! Kudos from a fellow researcher,644e0dfbad3d3408d0279b7036806b89e5384a4b,True,False,,,,,0,1647498480,,0,{},i0zlmdv,False,t3_teq0tw,False,True,t1_i0v0mr5,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0zlmdv/,1647498492,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
723.0,[],False,,lightandlight,,,[],,,,text,t2_lggvj,False,False,"""Selective"" functors implement the extra-lazy boolean operators you describe: https://hackage.haskell.org/package/selective-0.5/docs/Control-Selective.html#v:-60--124--124--62-",52299a14a2138e1e2f6a2922f850723db02c63a0,True,False,,,,,0,1647497762,,0,{},i0zknuu,False,t3_tfqpeg,False,True,t3_tfqpeg,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i0zknuu/,1647497775,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
724.0,[],False,,magthe0,,,[],,,,text,t2_eofkc,False,False,"There is a way to configure git to translate one URL to another. We use it at work to some Go projects to build properly.

I'm not at a computer at the moment but as soon as I am I'll put an example here. (Unless someone beats me to it.)",5a6bd1d7ff3b9e038f683dcdb7ff849a223c7dc4,True,False,,,,,0,1647497623,,0,{},i0zkh5x,False,t3_tfgxnv,False,True,t3_tfgxnv,/r/haskell/comments/tfgxnv/use_authenticated_git_with_cabal/i0zkh5x/,1647497638,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
725.0,[],False,,SolaTotaScriptura,,,[],,,,text,t2_5dpnr08,False,False,"I jut landed on this slightly weird signature. Is this a common setup?

    star :: (Applicative f, Monoid (f a)) =&gt; Parser s (Maybe a) -&gt; Parser s (f a)
    star p = p &gt;&gt;= \case
      Just x -&gt; pure (pure x) &lt;&gt; star p
      Nothing -&gt; mempty

Another example:

    f :: (Applicative f, Monoid (f b)) =&gt; (a -&gt; Maybe b) -&gt; a -&gt; f b
    f g x = maybe mempty pure (g x)

Basically I just need to join up multiple of `a` into a data structure.

I think I might just use `[a]` because it has better type inference.",9e45339506da390a5824e447818dae295d5e2c07,True,False,,,,,0,1647496721,,0,{},i0zj9dp,False,t3_t3zw0x,False,True,t3_t3zw0x,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i0zj9dp/,1647496733,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
726.0,[],False,,juhp,,,[],,,,text,t2_3h495,False,False,"How do people catch HTTP timeouts?  
What is the best practice around that?  
I am mostly using http-client - any code examples would be really helpful.  
I see that req has built-in support for retry.",af07711505edd939993c2b91a717c6b51fd78fde,True,False,,,,,0,1647495392,,0,{},i0zhe4c,False,t3_t3zw0x,False,True,t3_t3zw0x,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i0zhe4c/,1647495407,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
727.0,[],False,,Tysonzero,,,[],,,,text,t2_7ckb4,False,False,"This is evil and shouldn’t be used but here is a liftM2 that is lazy in the way your OP wants, at the cost of being evil and actually significantly less lazy in other ways:

```
evilLazyLiftM2 :: Monad m =&gt; (a -&gt; b -&gt; c) -&gt; m a -&gt; m b -&gt; m c
evilLazyLiftM2 f ma mb = do
    a &lt;- ma
    case spoon (f a undefined) of
        Nothing -&gt; do
            b &lt;- mb
            pure $ f a b
        Just c -&gt; pure c
```

Please don’t use this.",1204af0b85f9efecbc11babd01186c34870e8e1a,True,False,,,,,0,1647484358,,0,{},i0ywzdc,False,t3_tfqpeg,False,True,t3_tfqpeg,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i0ywzdc/,1647484369,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
728.0,[],False,,anydalch,,,[],,,,text,t2_127z0q,False,False,"your version in do-notation looks like

    mAnd a b = do { a' &lt;- a
                  ; if a' then b else return False }

notice that it doesn't force/evaluate `b` by binding its result, it just returns `b` if taken. on the other hand, desugaring the definition of `liftM2` from `do`-notation into uses of `&gt;&gt;=` might be valuable to you:

    liftM2 f m1 m2 =
      m1 &gt;&gt;= \x1 -&gt;
        m2 &gt;&gt;= \x2 -&gt;
          return (f x1 x2)

note that, by the time `f` is applied to `x1` and `x2`, both `m1` and `m2` have already been evaluated.

essentially, what you're observing is that ""evaluating"" or ""forcing"" monads is not lazy. (this is an oversimplification, but a useful one.) monads are haskell's way of describing impure, side-effecting procedures, so it's necessary that dependencies expressed using `do`-notation bindings or the `&gt;&gt;=` operator introduce actual happens-before control flow dependencies. consider, as an example, this hypothetical usage of a made-up `Logging` monad:

    loggedAdd :: Int -&gt; Int -&gt; Logging Int
    loggedAdd a b = do { _ &lt;- log (""adding together "" ++ (show a) ++ "" and "" ++ (show b))
                       ; return (a + b) }

i did some partial desugaring there by binding the result of the `log` call to an ignored variable, for emphasis. it would be undesirable if invoking `loggedAdd` didn't print anything because the result of the `log` call is never used.",933cb671de7bbdc3ab97e098592dfe2b75e27c56,True,False,,,,,0,1647483630,,0,{},i0yvfow,False,t3_tfqpeg,False,True,t1_i0ygytc,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i0yvfow/,1647483644,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
729.0,[],False,,dagit,,,[],,,,text,t2_lj2p,False,False,"You've already been given some good answers and it sounds like you understand it now, but I want to take a moment to explain things from a different perspective.

Let's start with the type signature of `liftM2`:

    Prelude Control.Monad&gt; :t liftM2
    liftM2 :: Monad m =&gt; (a1 -&gt; a2 -&gt; r) -&gt; m a1 -&gt; m a2 -&gt; m r

Contrast that with the `mAnd` you defined: `mAnd :: Monad m =&gt; m Bool -&gt; m Bool -&gt; m Bool`

The `a1` and `a2` are implicitly `forall`'d type variables. They can be any type. As a result, `liftM2` can't actually do anything with values of those types, aside from passing them to its first argument. For instance, it cannot inspect the value of type `a1` to see if it is `True` or `False`.

In other words, this behavior of `liftM2` here is less about laziness and actually has more to do with the type system of haskell.

Generally, this sort of reasoning is known as parametericity and it has some interesting uses. Another very simple example is answering the question how many distinct functions are there in haskell with type `a -&gt; a`? Here, when I say distinct I mean you could tell them apart by looking at pairs of inputs/outputs.

Well, because the function cannot do anything with it's input aside from return it, the identity function is one such function. The only other one turns out to be equivalent to `undefined`; in other words some sort of program crash.",178f5284e51166928a69619a316300190c222dbb,True,False,,,,,0,1647481904,,0,{},i0yrmz4,False,t3_tfqpeg,False,True,t3_tfqpeg,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i0yrmz4/,1647481915,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
730.0,[],False,,Vegetable_Map_8535,,,[],,,,text,t2_7xpeajb5,False,False,"I am wanting to begin coding with haskell, however, I am having trouble converting .txt files to .hs on Windows 10, and therefore have been unable to start because I have nowhere to type out the code",7081750bc028a9bd83fbbc6f693eff78eb884893,True,False,,,,,0,1647481505,,0,{},i0yqqrr,False,t3_t3zw0x,False,True,t3_t3zw0x,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i0yqqrr/,1647481519,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
731.0,[],False,,simonmic,,,[],,,,text,t2_3a0g0,False,False,"""Modelling the neural code in large populations of correlated neurons"".

It sure is, and very nice plots!",1c79d8b5312a201b9f57e2383d5e4368a53aa2e2,True,False,,,,,0,1647480591,,0,{},i0yopbh,False,t3_teq0tw,False,True,t1_i0vyk2x,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0yopbh/,1647480604,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
732.0,[],False,,Defrigeration,,,[],,,,text,t2_ghrwv,False,False,"That does help, thanks. From the documentation for the  `&gt;&gt;` operator:

&gt;Sequentially compose two actions, discarding any value produced  
 by the first, like sequencing operators (such as the semicolon)  
 in imperative languages.

I took this to mean that it could not get to the second action, in your example `return undefined`, without performing the first, but as you demonstrate, that's not what happens.",bcbbe28981795e6d1247bc33840536997bddd8c1,True,False,,,,,0,1647478335,,0,{},i0yjntr,True,t3_tfqpeg,False,True,t1_i0xibia,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i0yjntr/,1647478347,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
733.0,[],False,,cartazio,,,[],,,,text,t2_367jq,False,False,Good summary!,fb0f8e81ae55a75b932be90a040e371d05005f02,True,False,,,,,0,1647477204,,0,{},i0yh70g,False,t3_tflwqq,False,True,t1_i0xw0ek,/r/haskell/comments/tflwqq/which_optimizations_does_unsafeperformio_block/i0yh70g/,1647477216,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
734.0,[],False,,Defrigeration,,,[],,,,text,t2_ghrwv,False,False,Thank you for your reply. So the question becomes: what is different about the binding `x2 &lt;- m2` from binding the second argument of `mAnd` to `y` that results in different behaviour?,8bea5f8671061a1c68e8faf8ed1b445c10621529,True,False,,,,,0,1647477097,,0,{},i0ygytc,True,t3_tfqpeg,False,True,t1_i0xh9f2,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i0ygytc/,1647477114,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
735.0,[],False,,Defrigeration,,,[],,,,text,t2_ghrwv,False,False,"You're right in saying that I was not thinking of the terminal output as part of the result.  I was thinking of the returned value as the ""result"". So haskell doesn't need to perform the IO action in order to get the returned value but it does need to perform it to get the ""result"". But then, why is it different with my `mAnd` function?",a0c06b7d759e3a49628f35faa6551699aa40240b,True,False,,,,,0,1647476851,,0,{},i0yggd4,True,t3_tfqpeg,False,True,t1_i0xpd6n,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i0yggd4/,1647476864,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
736.0,[],False,,Defrigeration,,,[],,,,text,t2_ghrwv,False,False,"Thank you for the interesting challenge, but I couldn't do it. I either ran into `Occurs check: cannot construct the infinite type` errors or got the behaviour of the stock function. 

I think what is happening is that it has to bind both arguments first, then start evaluating the function applied to the arguments. Right? 

However for one argument, 

    myLiftM :: Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r
    myLiftM f arg = f &lt;$&gt; arg

works as I'd expect:

    *Main&gt; myLiftM (&amp;&amp; undefined) falsify
    It is a falsehood.
    False",b038368ba1b7e45ea225f05d9f930f1cd926d118,True,False,,,,,0,1647475828,,0,{},i0ye8ly,True,t3_tfqpeg,False,True,t1_i0xaqm4,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i0ye8ly/,1647475843,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
737.0,[],False,,g__,,,[],,,,text,t2_37x9r,False,False,"Some libraries define that function: https://hoogle.haskell.org/?hoogle=m%20Bool%20-%3E%20m%20Bool%20-%3E%20m%20Bool, https://hoogle.haskell.org/?hoogle=andM.

I usually use an explicit ""if"" in a do block instead.",2f967e3c6f862d55206d449d93eea620598c6239,True,False,,,,,0,1647473177,,0,{},i0y86zc,False,t3_tfqpeg,False,True,t3_tfqpeg,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i0y86zc/,1647473191,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
738.0,[],False,,Tysonzero,,,[],,,,text,t2_7ckb4,False,False,"Oh I see what you mean.

Yes if you want a monad specifically designed for writing short circuiting code then something like `Maybe` or `Either` works well, depending on whether you need to spit out a result in the short circuit case or not.",9bdbffcba6d357b52adf357dd90ca14294794d6a,True,False,,,,,0,1647470153,,0,{},i0y10cr,False,t3_tfqpeg,False,True,t1_i0xypzm,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i0y10cr/,1647470164,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
739.0,[],False,,olstrak,,,[],,,,text,t2_5mujb5oz,False,False,"What I mean is that the sequencing/short-circuiting behaviour OP is looking for is usually seen in the form of the `Maybe` monad or the `MaybeT` transformer, if I'm not mistaken.",f0148351f55acc627d7d392416852b11b80e1aa5,True,False,,,,,0,1647469226,,0,{},i0xypzm,False,t3_tfqpeg,False,True,t1_i0xw3kt,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i0xypzm/,1647469242,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
740.0,[],False,,Tysonzero,,,[],,,,text,t2_7ckb4,False,False,Ah yes. I’ve definitely used `or` and `and` and similar plenty for dealing with `Maybe Bool`.,dcebd2ad756c6cf715da815a7242a8d2ceed068b,True,False,,,,,0,1647468175,,0,{},i0xw3kt,False,t3_tfqpeg,False,True,t1_i0xvvls,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i0xw3kt/,1647468191,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
741.0,[],False,,Tarmen,,,[],,,,text,t2_7mjdo,False,False,"Performance wise the big thing is that unsafePerformIO takes a lock. Also, you probably have to NOINLINE to keep things from breaking which alone is enough to disable most optimizations.


Using unsafeDupablePerformIO has little overhead (no lock, can't do resources because the computation can be cancelled without bracket handlers being run) and accursedUnutterablePerformIO (inlinable so GHC can do lifting/common subexpression elimination) is pretty much 0 overhead. The last one can only really read from immutable sources like read-only arrays, though.",c9e4517f892acb5fdf767b04a7a61c2aa586ded4,True,False,,,,,0,1647468141,,0,{},i0xw0ek,False,t3_tflwqq,False,True,t3_tflwqq,/r/haskell/comments/tflwqq/which_optimizations_does_unsafeperformio_block/i0xw0ek/,1647468154,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
742.0,[],False,,olstrak,,,[],,,,text,t2_5mujb5oz,False,False,"&gt; Personally I haven't ever run into that in practice.

I guess that's because the `Bool` value is implicit in `Maybe a`, which is probably what OP actually wants here.",b23da369c11b707da53ae0c5fba1851615763963,True,False,,,,,0,1647468089,,0,{},i0xvvls,False,t3_tfqpeg,False,False,t1_i0xb6mp,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i0xvvls/,1647468100,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
743.0,[],False,,lambduli,,,[],,,,text,t2_6oe9wc20,False,False,"&gt; We can not pass value to alpha to build a functor F, am I correct?

Function of type `forall a x . a -&gt; x` doesn't have a sensible implementation. Although it could be a bottom - then your definition of alpha would work fine.

I wonder whether there's a reason why in the first snippet the `a` is not closed under the forall. Is it intentional? Because like that it's not a valid type due to the forall-or-nothing rule in Haskell.

Unfortunately I don't know CT so I can't be of any real help, but it's interesting question so I wanted to stop by and share my thoughts. Hope you don't mind.",cf57aba94d9858f0ebdd04e9454c90e458b0dba2,True,False,,,,,0,1647466950,,0,{},i0xszl9,False,t3_tftl2r,False,True,t3_tftl2r,/r/haskell/comments/tftl2r/implementing_natural_transformation_in_yoneda/i0xszl9/,1647466968,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
744.0,[],False,,r3dnaz,,,[],,,,text,t2_2ornf0zo,False,False,"it is an important theoretical result that laziness does not change the *result* ([Church-Rosser theorem](https://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem)). so whether ""Verily, it is so."" is part of the output cannot depend on whether `(&amp;&amp;)` is strict in its second argument or not.

you think the terminal output is not part of the *result*? in a pure language the terminal output is as much part of the result as `""Verily, it is so.""` is part of the result of the following.

    falsify :: Writer [String] Bool
    falsify = tell [""It is a falsehood.""] *&gt; pure False
    verify :: Writer [String] Bool
    verify = tell [""Verily, it is so.""] *&gt; pure True
    liftedAnd :: Monad m =&gt; m Bool -&gt; m Bool -&gt; m Bool
    liftedAnd = liftA2 (&amp;&amp;)
    
    -- &gt;&gt;&gt; runWriter (falsify `liftedAnd` verify)
    -- (False,[""It is a falsehood."",""Verily, it is so.""])",cb6b29682336b298ad5dbc0ec4b467809f446985,True,False,,,,,0,1647465549,,0,{},i0xpd6n,False,t3_tfqpeg,False,True,t3_tfqpeg,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i0xpd6n/,1647465564,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
745.0,[],False,,SSchlesinger,,,[],,,,text,t2_jggeg,False,False,"There are lots of open source Haskell repositories, you can search GitHub and filter however you want, including desire for contribution. This search might work for you: [https://github.com/search?q=label%3Agood-first-issue+language%3AHaskell&amp;type=Issues&amp;ref=advsearch&amp;l=Haskell&amp;l=](https://github.com/search?q=label%3Agood-first-issue+language%3AHaskell&amp;type=Issues&amp;ref=advsearch&amp;l=Haskell&amp;l=)

On the other hand, you can always create your own open source project! In my opinion, building things from scratch is the best way to learn about programming. Some projects suggestions:

Implement [boids](https://en.wikipedia.org/wiki/Boids) using the [gloss](https://hackage.haskell.org/package/gloss) library for graphics.

Implement a [web crawler](https://en.wikipedia.org/wiki/Web_crawler) using [tagsoup](https://hackage.haskell.org/package/tagsoup) for extracting links in HTML pages.

Implement the [lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus).

If you want to stick to server programming, perhaps you could make a chat server or a distributed hash table or something like that.

My understanding of web3 is that it has to do with browsers interacting with cryptocurrencies and other decentralized applications, so if you want to do that in Haskell you probably want to use GHC JS, but I'm honestly not sure if that's advisable. If you want to make backend programs and servers to interact with cryptocurrencies and decentralized applications, you should look for the client libraries for those cryptocurrencies or decentralized applications. For instance, [here is a Haskell client for IPFS](https://hackage.haskell.org/package/ipfs). Here is [an RPC API for Bitcoin core](https://hackage.haskell.org/package/bitcoin-api). Here seems to be [a similar thing for Ethereum](https://hackage.haskell.org/package/web3-ethereum). I'm not up to speed on these things so I am not attesting to the quality of these libraries.",793c180341c6c477163f8d92c8646c3c11c74233,True,False,,,,,0,1647464678,,0,{},i0xn5j2,False,t3_tfep9q,False,True,t3_tfep9q,/r/haskell/comments/tfep9q/advice_a_project/i0xn5j2/,1647464691,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
746.0,[],False,,SSchlesinger,,,[],,,,text,t2_jggeg,False,False,"[https://hackage.haskell.org/package/squeal-postgresql](https://hackage.haskell.org/package/squeal-postgresql) is another great Postgres library in Haskell, it really does seem to be the most pleasant database to use in Haskell.",aeb2246f71ec610af0dbc47ac0a83125163ad35c,True,False,,,,,0,1647463631,,0,{},i0xkffx,False,t3_tfep9q,False,True,t1_i0wo64o,/r/haskell/comments/tfep9q/advice_a_project/i0xkffx/,1647463645,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
747.0,[],False,,Toricon,,,[],,,,text,t2_zi98c,False,False,"There's  difference between *evaluating* a value, and *performing* an IO action (which, in Haskell, is also a value). `liftM2 f a b` works by performing the action given by `a`, performing the action given by `b`, and then uses `f` to combine their results. This is exactly what it does in your example: it prints ""It is a falsehood."", ""Verily, it is so."", and returns the value `False`. Your `mAnd x y` performs the action given by `x`, and then uses that to decide whether or not to perform the action given by `y`, or to just return `False`.

To clear things up, let's introduce a new value:
```uncertainty :: IO Bool
uncertainty = putStrLn ""I'm not sure..."" &gt;&gt; return undefined```

`falsify \`mAnd\` uncertainty` will give the same result as `falsify \`mAnd\` verify`, because in both cases the second value is discarded entirely. But `liftedAnd falsify uncertainty` will give
```*Main&gt; falsify `liftedAnd` uncertainty
It is a falsehood.
I'm not sure...
False```

Note that, although `uncertainty`'s IO action was performed, `&amp;&amp;` still short-circuited and did not attempt to evaluate `uncertainty`'s actual result. `liftM2` did not remove its laziness. But if we had written `falsify \`liftedAnd\` undefined`, we would have gotten:
```*Main&gt; falsify `liftedAnd` undefined
It is a falsehood.
***Exception: Prelude.undefined```
because `liftM2` would have tried to perform the IO action given by `undefined`, which is, well, a runtime error. In this case, it didn't even get far enough for `&amp;&amp;` to take a look at things.

In conclusion: performing an IO action and evaluating a value are two different tasks. In order for an IO action to be performed, it must first be evaluated, but functions that deal with the evaluation of values don't usually deal with performing IO actions directly. Does this help? Is there anything in this explanation that confuses you?",7a81457d4a66d8e3d9b068f5a2e7b9fffb9b4d0d,True,False,,,,,0,1647462811,,0,{},i0xibia,False,t3_tfqpeg,False,True,t3_tfqpeg,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i0xibia/,1647462826,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
748.0,[],False,,anydalch,,,[],,,,text,t2_127z0q,False,False,"the semantics of `liftM2 func left right` are to (create an object which when evaluated will) evaluate `left` to produce `left', then evaluate `right` to produce `right'`, then apply `func` to `left'` and `right'`. it's defined at from https://hackage.haskell.org/package/base-4.16.0.0/docs/Control-Monad.html#v:liftM2 as:

    liftM2 f m1 m2 = do { x1 &lt;- m1
                        ; x2 &lt;- m2
                        ; return (f x1 x2) }",2aab3cfab1e59fe6c6ddfae8e831a26820bbd9c0,True,False,,,,,0,1647462393,,0,{},i0xh9f2,False,t3_tfqpeg,False,True,t3_tfqpeg,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i0xh9f2/,1647462404,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
749.0,[],False,,Tysonzero,,,[],,,,text,t2_7ckb4,False,False,"Specifically I'm curious what your function will return when given:

```
result = liftLazyM2 (,) (Just 5) Nothing

five = case result of
    Just (n, _) -&gt; n
    Nothing -&gt; 0

zero = case result of
    Just (_, n) -&gt; n
    Nothing -&gt; 0
```

Keeping in mind that

```
fst (5, undefined) = 5
```

So returning `0` both times would be inconsistent with your desire for full monadic laziness.",446486c6f22c2446d3ad7acef99bcf8ee0c77f2a,True,False,,,,,0,1647460771,,0,{},i0xd4pa,False,t3_tfqpeg,False,True,t1_i0xaqm4,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i0xd4pa/,1647460786,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
750.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,liftM2 / liftA2 always has to have the effects of both arguments.,7d83996fd57e66c65e9115fa133199d423ec00c5,True,False,,,,,0,1647460265,,0,{},i0xbv5q,False,t3_tfqpeg,False,True,t3_tfqpeg,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i0xbv5q/,1647460279,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
751.0,[],False,,Tysonzero,,,[],,,,text,t2_7ckb4,False,False,"`liftM2` didn't *destroy* laziness, it just didn't introduce *additional* laziness:

```
liftM2 (&amp;&amp;) (pure False) (pure undefined) == pure False
```

Laziness, or more precisely, non-strictness, can be unpredictable and erratic, particularly once you throw in various possible optimizations. For that reasons Haskell very intentionally doesn't easily let pure and largely unobservable laziness leak into impure and visible decision.

If you do frequently run into situations where you have two `m Bool`'s that you want to laziness and, then definitely define a helper like the one you created there. Personally I haven't ever run into that in practice.",2d99a4752ef94a9e2610f5c9627cfa6969b410a0,True,False,,,,,0,1647459998,,0,{},i0xb6mp,False,t3_tfqpeg,False,True,t3_tfqpeg,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i0xb6mp/,1647460012,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
752.0,[],False,,Puzzled-Bananas,,,[],,,,text,t2_b66sdh32,False,False,"Hi sorry took a bit longer, here’s the amazing slides repo https://github.com/takenobu-hs/haskell-ghc-illustrated

Take also a look at the corresponding chapters in http://dev.stephendiehl.com/hask/",442a4131133de6d8e8dbea0156947f62b604422a,True,False,,,,,0,1647459968,,0,{},i0xb3yu,False,t3_teq0tw,False,True,t1_i0rvrfk,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0xb3yu/,1647459982,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
753.0,[],False,,ct075,,,[],,,,text,t2_dghk9,False,False,Try to implement `liftM2` for yourself in such a way to preserve short-circuit execution in the way you describe. What do you observe?,095065abf71f671f9535af42ba63eaec58240fc3,True,False,,,,,0,1647459819,,0,{},i0xaqm4,False,t3_tfqpeg,False,True,t3_tfqpeg,/r/haskell/comments/tfqpeg/liftm_destroys_laziness/i0xaqm4/,1647459833,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
754.0,[],False,,NNOTM,,,[],,,,text,t2_6ztbu,False,False,"With MonadComprehensions you can write

    divSafe :: Rational -&gt; Rational -&gt; Maybe Rational
    divSafe p q = [ p/q | q /= 0 ]",575ffa1bb188e301b1b654e20dd81bc6f5ea83ec,True,False,,,,,0,1647458762,,0,{},i0x82zy,False,t3_tfkteo,False,True,t3_tfkteo,/r/haskell/comments/tfkteo/is_there_a_better_pattern_for_return_just_some/i0x82zy/,1647458781,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
755.0,[],False,,thefybe,,,[],,,,text,t2_118sdr,False,False,"Yeah I figured locally there isn't much room for improvement. I think I prefer the more global approaches suggested below, but thank you anyway!",69e8974907acdaf9c1305cd58f1977f70bc6c5dc,True,False,,,,,0,1647458033,,0,{},i0x69d7,True,t3_tfkteo,False,True,t1_i0wiewq,/r/haskell/comments/tfkteo/is_there_a_better_pattern_for_return_just_some/i0x69d7/,1647458048,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
756.0,[],False,,thefybe,,,[],,,,text,t2_118sdr,False,False,This looks just as promising as the suggested Ghosts of a departed proof. I will look into which approach works best in my case. Thank you!,f1d4ad5c68290afcd8e038422f6405798749ff1e,True,False,,,,,0,1647457802,,0,{},i0x5oif,True,t3_tfkteo,False,False,t1_i0wnkx6,/r/haskell/comments/tfkteo/is_there_a_better_pattern_for_return_just_some/i0x5oif/,1647457816,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
757.0,[],False,,SSchlesinger,,,[],,,,text,t2_jggeg,False,False,"Sometimes you’ll have to mark your code to not be inlined if you use unsafePerformIO, which means that it will not be inlined, so optimizations which would have been able to help you if it were inlined will not have an opportunity to do so. The GHC optimizations all work together and inlining is a key aspect of that.

For instance, opportunities for floating let bindings closer to their use site can sometimes show up after an inline, the liberate-case transformation might see more opportunities in a similar way, and certain rewrite rules may not get the opportunity to fire.",f8b03a960d0c63f487d2701f1ff654a916ec404d,True,False,,,,,0,1647457579,,0,{},i0x54el,False,t3_tflwqq,False,True,t3_tflwqq,/r/haskell/comments/tflwqq/which_optimizations_does_unsafeperformio_block/i0x54el/,1647457593,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
758.0,[],False,,thefybe,,,[],,,,text,t2_118sdr,False,False,"Yeah I read that a while ago, but totally forgot about it. Thank you!",81300d04215cbfe2a9d06e2df185e92484d336cb,True,False,,,,,0,1647457332,,0,{},i0x4i9o,True,t3_tfkteo,False,True,t1_i0wp1eh,/r/haskell/comments/tfkteo/is_there_a_better_pattern_for_return_just_some/i0x4i9o/,1647457347,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
759.0,[],False,,c_wraith,,,[],,,,text,t2_7kbl2,False,False,"This is basically right. The biggest issue is with inlining. If a definition using unsafePerformIO gets inlined, the IO will be performed multiple times. If it isn't actually a pure operation, you can observe inconsistent results.

Basically, unsafePerformIO is a promise to the compiler that the IO it performs will behave as if it is pure. GHC ignores the presence of unsafePerformIO when doing its optimization passes.",ea050f13bfec253de779887dd911001efabe1652,True,False,,,,,0,1647456256,,0,{},i0x1s2d,False,t3_tflwqq,False,True,t1_i0wqkab,/r/haskell/comments/tflwqq/which_optimizations_does_unsafeperformio_block/i0x1s2d/,1647456270,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
760.0,[],False,,epoberezkin,,,[],,,,text,t2_13t18x,False,False,"we will probably prepare the template repo with the instructions how to build Haskell apps a bit later, not there yet indeed.",28828fe1c7656ff95c348661017858c908c09f44,True,False,,,,,0,1647456059,,0,{},i0x1a17,True,t3_t9ljld,False,True,t1_i0wi4w3,/r/haskell/comments/t9ljld/simplex_chat_the_first_chat_platform_that_is_100/i0x1a17/,1647456078,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
761.0,[],False,,zsome,,,[],,,,text,t2_gvnql7,False,False,"Thx, I'll take a look at it",c74845cf5a725b9b59d006b59b788cf6e56b0bf8,True,False,,,,,0,1647453782,,0,{},i0wvhrs,True,t3_tfep9q,False,True,t1_i0wo64o,/r/haskell/comments/tfep9q/advice_a_project/i0wvhrs/,1647453800,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
762.0,[],False,,arnemcnuggets,,,[],,,,text,t2_7egzysxc,False,False,"The way i understood it is that its the opposite: the optimizations make unsafePerformIO appear unintuitively and by chance unpredictable.  Memoization and Laziness can mess up your control flow.

I might be wrong and I dont know if optimizations are blocked by it however",cf60b4280d51b8afa33ebef32399ede32d511297,True,False,,,,,0,1647451821,,0,{},i0wqkab,False,t3_tflwqq,False,True,t3_tflwqq,/r/haskell/comments/tflwqq/which_optimizations_does_unsafeperformio_block/i0wqkab/,1647451835,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
763.0,[],False,,dpwiz,,,[],,,,text,t2_4xjof,False,False,"Yes, search ""ghosts of departed proofs"".",b878904813d853d77d4fa6c1e7020fe263d23e17,True,False,,,,,0,1647451218,,0,{},i0wp1eh,False,t3_tfkteo,False,True,t3_tfkteo,/r/haskell/comments/tfkteo/is_there_a_better_pattern_for_return_just_some/i0wp1eh/,1647451236,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
764.0,[],False,,dpwiz,,,[],,,,text,t2_4xjof,False,False,"For starters, I'd recommend switching to PostgreSQL and checking out [rel8](https://rel8.readthedocs.io/en/latest/) for a taste of what Haskell brings to the table.",439c755aabe34debe7c47c1329fb4fc713b589aa,True,False,,,,,0,1647450865,,0,{},i0wo64o,False,t3_tfep9q,False,True,t1_i0walyz,/r/haskell/comments/tfep9q/advice_a_project/i0wo64o/,1647450878,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
765.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"Potentially a good case for a `newtype` wrapper to indicate the preservation of that predicate at the type level, but you'd still have a `Maybe` / `Just` layer.

    newtype NonZero a = AssertNonZero { getNonZero :: a }

    -- Do not export `AssertNonZero` or `getNonZero` directly.
    -- A unidirectional pattern can be exported instead of the constructor
    -- A pure getter can be exported instead of the field

    nonZero :: (Num a, Eq a) =&gt; a -&gt; Maybe (NonZero a)
    nonZero x | x /= 0 = Just $ AssertNonZero x
    nonZero _ = Nothing

    divSafe :: Rational -&gt; NonZero Rational -&gt; Rational
    divSafe n d = n / getNonZero d

    divCheck :: Rational -&gt; Rational -&gt; Maybe Rational
    divCheck n = fmap (divSafe n) . nonZero",b894b2800c5545641375df4a965624eb890d7dbc,True,False,,,,,0,1647450623,,0,{},i0wnkx6,False,t3_tfkteo,False,True,t3_tfkteo,/r/haskell/comments/tfkteo/is_there_a_better_pattern_for_return_just_some/i0wnkx6/,1647450640,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
766.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"Yes, that is true (actually only up to 10) and I fully agree, but I think that is what /u/Financial_Low_6144 is asking for.",b6a5a0845a6f71d33323c3a9a58bd8538744cba7,True,False,,,,,0,1647450175,,0,{},i0wmhku,False,t3_t3zw0x,False,True,t1_i0wlwwz,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i0wmhku/,1647450188,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
767.0,[],False,,Iceland_jack,,,[],,,,text,t2_3qjdu,False,False,"You can write it with a type synonym `type ModifiableOf value a = (Modifiable a, value ~ Value a)` but you lose partial application.",4c4813ab1f15922bfbc5fcfba4b8816bad6e906f,True,False,,,,,0,1647450021,,0,{},i0wm45u,False,t3_tff9it,False,True,t1_i0w70g6,/r/haskell/comments/tff9it/is_there_a_way_to_compare_the_associated_type_in/i0wm45u/,1647450032,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
768.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"I'm not familiar with the `Each` typeclass, but I'd bet that there's an `instance` for each tuple size up to 15, which is equivalent to ""writing a function for each tuple size"".",773a1232a8d1251838a4174e75b7829604e803ea,True,False,,,,,0,1647449939,,0,{},i0wlwwz,False,t3_t3zw0x,False,True,t1_i0whb1m,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i0wlwwz/,1647449956,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
769.0,[],False,,HKei,,,[],,,,text,t2_kugiq,False,False,You need to state the condition and the value you want to return somewhere. You could save like a character _sometimes_ by writing `guarded p x = guard p $&gt; x` but that's about it?,941c6cc2933ea25cb5d31ca1cc9488a2d1bcb848,True,False,,,,,0,1647448521,,0,{},i0wiewq,False,t3_tfkteo,False,True,t3_tfkteo,/r/haskell/comments/tfkteo/is_there_a_better_pattern_for_return_just_some/i0wiewq/,1647448535,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
770.0,[],False,,runeks,,,[],,,,text,t2_5doju,False,False,"How does this work? I can't find any build scripts that mention the word ""flake"" when I search the repo.",ce224ca76cb81f089aa00d6a9e6c237a52a4e66e,True,False,,,,,0,1647448408,,0,{},i0wi4w3,False,t3_t9ljld,False,True,t1_i0wen30,/r/haskell/comments/t9ljld/simplex_chat_the_first_chat_platform_that_is_100/i0wi4w3/,1647448420,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
771.0,[],False,,HKei,,,[],,,,text,t2_kugiq,False,False,It's not really concerning. This looks like it probably was misconfiguration on user end.,436cb4b519d023ec00ec186f1c04102bee9adeef,True,False,,,,,0,1647448168,,0,{},i0whjvm,False,t3_tfgxnv,False,False,t1_i0vq7r9,/r/haskell/comments/tfgxnv/use_authenticated_git_with_cabal/i0whjvm/,1647448180,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
772.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"&gt; Can you assign this proposed function a type?

    toListOf each :: Each i s s a a =&gt; s -&gt; [a]",a1dbbc60f4efc6d39e1634d8c328ad890be21ed7,True,False,,,,,0,1647448069,,0,{},i0whb1m,False,t3_t3zw0x,False,True,t1_i0wfkyy,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i0whb1m/,1647448081,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
773.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"You can do it with `each`:

    (1,2,3,4) ^.. each

Or without operators:

    toListOf each (1,2,3,4)

To do bimap in a lensy way you can do this:

    (1,True) &amp; _1 %~ (+ 1) &amp; _2 %~ not

Or without operators:

    over _1 (+ 1) (over not f2 (1, True))

But note that in the end the `each`, `_1`, and `_2` functions do have to be implemented separately for each tuple size. There is no free lunch.",0cf114cc6a7d897dffc88e4c5e476de4333f6fed,True,False,,,,,0,1647448043,,0,{},i0wh8oe,False,t3_t3zw0x,False,True,t1_i0wb9y7,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i0wh8oe/,1647448057,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
774.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"&gt; Also, is the a lens way to ‘bimap’ 2 functions on a pair

`(,)` is a `Bifunctor` so `bimap` is exactly what you want.  There's also `(***)` from Control.Arrow.

&gt; Is there a way to transform a tuple into a list like with lenses or something else without writing a function for each tuple size?

Can you assign this proposed function a type?",d0bd5af9a0f5e78f22c509157cd2b320791964d1,True,False,,,,,0,1647447370,,0,{},i0wfkyy,False,t3_t3zw0x,False,True,t1_i0wb9y7,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i0wfkyy/,1647447384,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
775.0,[],False,,epoberezkin,,,[],,,,text,t2_13t18x,False,False,there is a flake file in the repo that configures the build,884be0cabafbcf43dfa94a2b8462324c876b552c,True,False,,,,,0,1647446987,,0,{},i0wen30,True,t3_t9ljld,False,True,t1_i0wehf1,/r/haskell/comments/t9ljld/simplex_chat_the_first_chat_platform_that_is_100/i0wen30/,1647446998,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
776.0,[],False,,runeks,,,[],,,,text,t2_5doju,False,False,"I see you use Nix, but why are there no Nix build instructions?",acfcec66587b25a58412a759d7dec215dbbc0b61,True,False,,,,,0,1647446922,,0,{},i0wehf1,False,t3_t9ljld,False,True,t3_t9ljld,/r/haskell/comments/t9ljld/simplex_chat_the_first_chat_platform_that_is_100/i0wehf1/,1647446938,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
777.0,[],False,,Charlesu49,,,[],,,,text,t2_3jgfeb10,False,False,"Hi, did you finally get a fix for this? I am having this challenge at the moment.",5ba63ea159e8aa4b7900ef8d7d3bbcd4b8d9f703,True,False,,,,,0,1647445980,,0,{},i0wc69g,False,t3_93kako,False,True,t1_e3lgd9s,/r/haskell/comments/93kako/stack_newbie_i_cant_stack_exec_pacman_s_make/i0wc69g/,1647445998,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
778.0,[],False,,Financial_Low_6144,,,[],,,,text,t2_9ns3j5ep,False,False,"Is there a way to transform a tuple into a list like with lenses or something else without writing a function for each tuple size?
Also, is the a lens way to ‘bimap’ 2 functions on a pair (like ‘both’ but with distinct functions)",af25355b4dfcb785383c32018113abd8506a1206,True,False,,,,,0,1647445621,,0,{},i0wb9y7,False,t3_t3zw0x,False,True,t3_t3zw0x,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i0wb9y7/,1647445636,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
779.0,[],False,,Iceland_jack,,,[],,,,text,t2_3qjdu,False,False,Most notable example being from Edward Kmett's categorical functor: [`FunctorOf from to f`](https://www.reddit.com/r/haskell/comments/eoo16m/base_category_polymorphic_functor_and_functorof/) being a shorthand for `Functor f` with `from ~ Source f` and `to ~ Target f`.,7771248bee39a3108c3984df9d3f92aa971ae9b4,True,False,,,,,0,1647445591,,0,{},i0wb76f,False,t3_tff9it,False,True,t1_i0w70g6,/r/haskell/comments/tff9it/is_there_a_way_to_compare_the_associated_type_in/i0wb76f/,1647445605,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
780.0,[],False,,zsome,,,[],,,,text,t2_gvnql7,False,False,I have a yesod based small web app with MySQL in production... A few small app with servant. What were you thinking like these ones ?,2e22f15c9280f6b9d11496f810511aa67d1b8f16,True,False,,,,,0,1647445353,,0,{},i0walyz,True,t3_tfep9q,False,True,t1_i0vzht0,/r/haskell/comments/tfep9q/advice_a_project/i0walyz/,1647445369,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
781.0,[],False,,Iceland_jack,,,[],,,,text,t2_3qjdu,False,False,Most notable example: [`FunctorOf source target f`](https://www.reddit.com/r/haskell/comments/eoo16m/base_category_polymorphic_functor_and_functorof/) being a shorthand for `Functor f` with `source ~ Source f` and `target ~ Target f`.,1ca0c6edcebede0d278a4245d3aae10c98379c07,True,False,,,,,0,1647445092,,0,{},i0w9yth,False,t3_tff9it,False,True,t1_i0w70g6,/r/haskell/comments/tff9it/is_there_a_way_to_compare_the_associated_type_in/i0w9yth/,1647445103,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
782.0,[],False,,Iceland_jack,,,[],,,,text,t2_3qjdu,False,False,"You can also use what I informally call the `..Of`-pattern where you create a [class synonym](https://gist.github.com/Icelandjack/5afdaa32f41adf3204ef9025d9da2a70#constraint-synonym-encoding-or-class-synonym) that lets you specify an associated type family like you're using a MPTC

    type ModifiableOf :: Type -&gt; Type -&gt; Constraint
    class    (Modifiable a, value ~ Value a) =&gt; ModifiableOf value a
    instance (Modifiable a, value ~ Value a) =&gt; ModifiableOf value a

then you can write them like the first example

    move :: ModifiableOf value a =&gt; ModifiableOf value a' =&gt; a -&gt; a' -&gt; IO ()",b367097badeacdaba3506ce6d30a94711ac2ddab,True,False,,,,,0,1647443898,,0,{},i0w70g6,False,t3_tff9it,False,True,t1_i0vdni2,/r/haskell/comments/tff9it/is_there_a_way_to_compare_the_associated_type_in/i0w70g6/,1647443915,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
783.0,[],False,,Iceland_jack,,,[],,,,text,t2_3qjdu,False,False,"You can also use what informally call the `..Of`-pattern where you create a [class synonym](https://gist.github.com/Icelandjack/5afdaa32f41adf3204ef9025d9da2a70#constraint-synonym-encoding-or-class-synonym) that lets you specify an associated type family like you're using a MPTC

    type ModifiableOf :: Type -&gt; Type -&gt; Constraint
    class    (Modifiable a, value ~ Value a) =&gt; ModifiableOf value a
    instance (Modifiable a, value ~ Value a) =&gt; ModifiableOf value a

then you can write them like the first example

    move :: ModifiableOf value a =&gt; ModifiableOf value a' =&gt; a -&gt; a' -&gt; IO ()",fda96a0cccfdf7f4f777078fe1b86bb3ed484e6e,True,False,,,,,0,1647443471,,0,{},i0w5z3c,False,t3_tff9it,False,True,t1_i0vdni2,/r/haskell/comments/tff9it/is_there_a_way_to_compare_the_associated_type_in/i0w5z3c/,1647443483,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
784.0,[],False,,NixOverSlicedBread,,,[],,,,text,t2_1s3ukhhs,False,False,"lol, thanks!",ca5cad0347606d34b7f813ecb1615c4b193c27b4,True,False,,,,,0,1647441648,,0,{},i0w1hpe,True,t3_tfhdpm,False,True,t1_i0vt3r2,/r/haskell/comments/tfhdpm/tooling_support_for_automatically_putting_lines/i0w1hpe/,1647441665,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
785.0,[],False,,dpwiz,,,[],,,,text,t2_4xjof,False,False,Web3 may be a little too hard for starting. Try Web2 first. /not-quite-s,394bbf4914a6d995ef162dfe78f39edeb4ecdb80,True,False,,,,,0,1647440813,,0,{},i0vzht0,False,t3_tfep9q,False,False,t3_tfep9q,/r/haskell/comments/tfep9q/advice_a_project/i0vzht0/,1647440829,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
786.0,[],False,,AdhesivenessTrue9696,,,[],,,,text,t2_5jzjx1br,False,False,This is cool,ee7e21ae5406bc59f8e1ad5f15f95a535824c457,True,False,,,,,0,1647440418,,0,{},i0vyk2x,False,t3_teq0tw,False,True,t1_i0v0mr5,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0vyk2x/,1647440429,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
787.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"&gt; in the long run is to have a symbiosis between Haskell and a language like Rust that has a more modern type system than C/C++?

I don't think that's possible until both the compiler teams start stablizing ABIs.  And my understanding is neither RustC nor GHC teams make any ABI guarantees between releases -- *except* for foreign exports to the C ABI!",58e9687005eb76db5c55aea870f730befeb227c8,True,False,,,,,0,1647438995,,0,{},i0vvate,False,t3_teq0tw,False,False,t1_i0v83c8,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0vvate/,1647439012,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
788.0,[],False,,epoberezkin,,,[],,,,text,t2_13t18x,False,False,"and yes, https works indeed! thank you!",27209daad9d46ebce606a076cb8b73c601ea3dcd,True,False,,,,,0,1647438221,,0,{},i0vtkog,True,t3_tfgxnv,False,False,t1_i0vr8gm,/r/haskell/comments/tfgxnv/use_authenticated_git_with_cabal/i0vtkog/,1647438239,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
789.0,[],False,,epoberezkin,,,[],,,,text,t2_13t18x,False,False,you are probably right that my ssh is not configured correctly... it just never was a problem before :),b49a82c0780302c8473f89e985b5e377617448a6,True,False,,,,,0,1647438128,,0,{},i0vtdd0,True,t3_tfgxnv,False,True,t1_i0vr8gm,/r/haskell/comments/tfgxnv/use_authenticated_git_with_cabal/i0vtdd0/,1647438142,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
790.0,[],False,,bryjnar,,,[],,,,text,t2_151sg2,False,False,Check the GHC users guide. Cost centres can be attached to arbitrary expressions: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#inserting-cost-centres-by-hand,b69be1deecd8e2fd2c853aa8e593d5c15ad932ac,True,False,,,,,0,1647438010,,0,{},i0vt3r2,False,t3_tfhdpm,False,True,t3_tfhdpm,/r/haskell/comments/tfhdpm/tooling_support_for_automatically_putting_lines/i0vt3r2/,1647438026,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
791.0,[],False,,tomejaguar,,,[],,,,text,t2_45sug,False,False,I've just done an experiment to depend on a private GitHub repo over `ssh://` in `cabal.project` and it works fine. Am I missing something? I'm not sure what the anticipated problem is.,249fab2c1dc33959a9dd6b621bef84661430377f,True,False,,,,,0,1647437138,,0,{},i0vr8gm,False,t3_tfgxnv,False,True,t1_i0vq8zf,/r/haskell/comments/tfgxnv/use_authenticated_git_with_cabal/i0vr8gm/,1647437154,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
792.0,[],False,,epoberezkin,,,[],,,,text,t2_13t18x,False,False,"looking...

The only workaround I can think of is to clone via git into sibling folders and have cabal.project reference these sibling folders...",6896ea33dcd8eda84122e92ecc3f31a5a535e62c,True,False,,,,,0,1647436750,,0,{},i0vqfa3,True,t3_tfgxnv,False,True,t1_i0vq7r9,/r/haskell/comments/tfgxnv/use_authenticated_git_with_cabal/i0vqfa3/,1647436761,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
793.0,[],False,,tomejaguar,,,[],,,,text,t2_45sug,False,False,"Are the dependencies on GitHub public? If so then why not switch to the `https://` source for them?

In any case I think we might need to see the `cabal.project` file to be able to know how to help. This doesn't sound like a cabal problem, rather a problem with your ssh configuration.",1d8183ac114bc7d9baf267c98f65690417fac42c,True,False,,,,,0,1647436666,,0,{},i0vq8zf,False,t3_tfgxnv,False,False,t3_tfgxnv,/r/haskell/comments/tfgxnv/use_authenticated_git_with_cabal/i0vq8zf/,1647436679,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
794.0,[],False,,recursion-ninja,,,[],,,,text,t2_l5pcx,False,False,"This is concerning as I have projects, plural, which rely on that functionality...

Any known solution(s)?",55354ed6b98516957001a7a123d7c17d04ee6bdd,True,False,,,,,0,1647436649,,0,{},i0vq7r9,False,t3_tfgxnv,False,True,t3_tfgxnv,/r/haskell/comments/tfgxnv/use_authenticated_git_with_cabal/i0vq7r9/,1647436664,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
795.0,[],False,,jimenezrick,,,[],,,,text,t2_3qr41,False,False,fixed link: https://www.cis.upenn.edu/~plclub/blog/2020-05-15-Defunctionalize-the-Continuation/,234f83b2b639e57e444ebfbab36aa36e31c1d3f3,True,False,,,,,0,1647431869,,0,{},i0vh9ng,False,t3_te7fso,False,True,t1_i0p5cgd,/r/haskell/comments/te7fso/is_it_true_that_continuation_passing_style_allows/i0vh9ng/,1647431881,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
796.0,[],False,,nxnt,,,[],,,,text,t2_we1z6qx,False,False,Thanks a lot. Exactly what I was looking for.,9206103c2083ddce7253289d8996cc17454d11e9,True,False,,,,,0,1647429563,,0,{},i0vdni2,True,t3_tff9it,False,True,t1_i0vdj6n,/r/haskell/comments/tff9it/is_there_a_way_to_compare_the_associated_type_in/i0vdni2/,1647429576,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
797.0,[],False,,arybczak,,,[],,,,text,t2_76rdi,False,False,"Yes, `Value a ~ Value a'`.",7e4abd8a916963fec4474431fac7d7a39a55f293,True,False,,,,,0,1647429482,,0,{},i0vdj6n,False,t3_tff9it,False,True,t3_tff9it,/r/haskell/comments/tff9it/is_there_a_way_to_compare_the_associated_type_in/i0vdj6n/,1647429493,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,True
798.0,[],False,,maerwald,,,[],,,,text,t2_t8qgl,False,False,"I meant ""hackage won't help"", because the package is not there. So my original suggestion to switch to cabal to gain proper access to hackage and have the cabal resolver figure out the correct versions (which stack cannot do), won't help much.",ebe4ebb3990dd15d1c6c62ecaa2c6e1218ff2fc4,True,False,,,,,0,1647428636,,0,{},i0vcc0a,False,t3_temn9b,False,True,t1_i0u3jf3,/r/haskell/comments/temn9b/generate_typescript_from_servant_api/i0vcc0a/,1647428651,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
799.0,[],False,,internallogictv,,,[],,,,text,t2_ceohopyo,False,False,"&gt;  There's also some concept shear as Haskell programmers generally expect more compile-time errors and have worse run time debugging facilities

Sorry if this is a naive question, but I wonder whether the right approach in the long run is to have a symbiosis between Haskell and a language like Rust that has a more modern type system than C/C++?

Calling out to another language that has full control over memory and optimization makes a lot of sense for numerical libraries. But Haskell-to-C bindings seem like a transition between the walled garden and the wild west. Maybe binding to something like Rust would be less of a stark contrast and would allow the bindings to be ""smarter"" in how they handled errors.

Juts a thought. Let me know if I'm totally off base or if people are working along these lines already.",98fb5ef330c7aa60871c8a07d6a8faa8ea7673f7,True,False,,,,,0,1647425438,,0,{},i0v83c8,False,t3_teq0tw,False,True,t1_i0rfwn3,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0v83c8/,1647425456,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
800.0,[],False,,sacha-sokoloski,,,[],,,,text,t2_55hv4l96,False,False,"I maintain a [collection of machine learning libraries for Haskell](https://gitlab.com/sacha-sokoloski/goal), and most of the core functionality I need is provided by hmatrix, and a handful of other libraries, and so for my purposes Haskell is in a relatively good place. My main limitation is a lack of of GPU computation, and if hasktorch would get more stable I would probably try and rebase my libraries on it.

Also a tip about plotting: I used to use the haskell Chart library, and always bemoaned the lack of comprehensive Haskell plotting tools. Now though my strategy is just to dump everything to .csv files and run them in gnuplot.

On one hand, this does add a couple more steps, and isn't ideal if you want to throw together some exploratory data analysis. Nevertheless, in my experience it's very good practice to separate the data analysis/generation from the plotting itself, especially if your long term goal is to publish the results. It just means you can fine tune plots without regenerating data, and your csvs + gnuplot scripts can even operate entirely independently from your main code.",4834b01f235c518f3f1ac0b3936702bbd97da887,True,False,,,,,0,1647419141,,0,{},i0v0mr5,False,t3_teq0tw,False,True,t3_teq0tw,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0v0mr5/,1647419156,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
801.0,[],False,,EdgyQuant,,,[],,,,text,t2_3nwn14y7,False,False,Or Python,4a61bae32ad9c415be6386d3f48e08bc94207051,True,False,,,,,0,1647406057,,0,{},i0ujaqi,False,t3_tezr5y,False,True,t1_i0tw4lz,/r/haskell/comments/tezr5y/comparison_of_targeted_strengths_between_rust_go/i0ujaqi/,1647406076,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
802.0,[],False,,howtonotwin,,,[],,,,text,t2_niyg2,False,False,"a) I really hope you don't actually have anything in `~/Users/Li/.cabal/cpsa`. It should be `/Users/Li/.cabal/cpsa`, which is the same as `~/.cabal/cpsa`. b) Well, *is* `~/.cabal` in your your path or not? Check with `echo ""$PATH""`. If not, you should edit `~/.bash_profile` (I assume you're using `bash` since that's the Mac default) and add the line 

    export PATH=""$HOME/.cabal:$PATH""

Exit and reopen your shell to have it reread this file.",1ff37ea789a58154b15d8a5d89a3a0b92165d07c,True,False,,,,,0,1647401305,,0,{},i0ualkc,False,t3_tf6x0r,False,True,t3_tf6x0r,/r/haskell/comments/tf6x0r/i_have_cabal_installed_cpsa_installed_but_it_is/i0ualkc/,1647401320,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
803.0,[],False,,Reptoidal,,,[],,,,text,t2_hkp0r,False,False,try adding .cabal/bin to your PATH `PATH=~/Users/Li/.cabal/bin:${PATH}`,34724d5aa5a1f572810d8644aab7537efe1d5cd7,True,False,,,,,0,1647401172,,0,{},i0uac2c,False,t3_tf6x0r,False,True,t3_tf6x0r,/r/haskell/comments/tf6x0r/i_have_cabal_installed_cpsa_installed_but_it_is/i0uac2c/,1647401189,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
804.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,Bad bot. ;),7b49b3773efa96715187443ea584decf88dfd47a,True,False,,,,,0,1647399285,,0,{},i0u6ddb,False,t3_tezr5y,False,True,t1_i0tvxly,/r/haskell/comments/tezr5y/comparison_of_targeted_strengths_between_rust_go/i0u6ddb/,1647399302,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
805.0,[],False,,ulysses4ever,,,[],,,,text,t2_68b11,False,False,"You say ""cabal won't help"" and right away give a link to cabal doc that solves exactly the problem at hand. I'm confused. Am I missing something?",e44cb157c8001a6f775ff4392f2966e737b58eb5,True,False,,,,,0,1647397973,,0,{},i0u3jf3,False,t3_temn9b,False,True,t1_i0r464k,/r/haskell/comments/temn9b/generate_typescript_from_servant_api/i0u3jf3/,1647397988,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
806.0,[],False,,dagit,,,[],,,,text,t2_lj2p,False,False,"It's also really easy, in haskell, to have your precious optimizations not fire. It's easy to write a vector library that assumes `Double` everywhere, but it's very tempting to want to generalize that to `Double` or `Float`.

If you do what most people do, now you have type classes in your type signatures. All it takes to miss out on a boatload of optimizations is to have some bit of code in the mix where GHC can't be certain it's always specialized to a specific one (`Float` or `Double`) in your application and you end up with terrible generated code.

So then you start marking everything as `INLINE`/`INLINEABLE` and/or sprinkling in some `SPECIALIZE` since you know 90% of people will use `Double` or `Float`. Then you start benchmarking things and realize you need to plug all your spaceleaks, double check core, make sure unboxed things are unboxed, etc.

In my experience it's a different kind of task than most Haskellers want in a library they're maintaining as a side thing or to scratch a hobby interest. And then when you start throwing in representation changes to get better performance, the elegance of Haskell starts to go out the window too.

I think now that Rust exists and is a safe by default language with a C++-ish runtime and level of control, that the sweet spot has likely moved. Implement your high performance numerical stuff in Rust and bind to it from Haskell. Or, even more practical, use a mature fortran library or something like that.

I usually feel like time is better spent reusing mature libraries via FFI, or similar, and writing some better API on top. There's going to be exceptions, of course, but as rule of thumb I think it's the right place to start most of the time.",c5b1a9edd2d62eb4ccf54bc1f31486ec32fa5ad6,True,False,,,,,0,1647396471,,0,{},i0u09ar,False,t3_teq0tw,False,True,t1_i0rfwn3,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0u09ar/,1647396485,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
807.0,[],False,,InvertedDick,,,[],,,,text,t2_63k3q4qp,False,False,"Sorry if this comes off as rude. None of these really make any sense, nor does it mean anything for the most part. But it’s understandable since you’re new. 

Any of these can be good for ”compute”, and Haskell is quite fast especially if you know GHC well. Haskell and Rust are reliable, and Go can be sufficiently reliable depending on what your goals are.",661790aba5a84d50fd980fdf34aa0f9fa39f3dd8,True,False,,,,,0,1647394728,,0,{},i0twa9t,False,t3_tezr5y,False,True,t3_tezr5y,/r/haskell/comments/tezr5y/comparison_of_targeted_strengths_between_rust_go/i0twa9t/,1647394741,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
808.0,[],False,,lgastako,,,[],,,,text,t2_1mp2i,False,False,It's JavaScript and/or TypeScript.,486e3750facc6db94f7cb37f68acf60cf0406d8d,True,False,,,,,0,1647394662,,0,{},i0tw4lz,False,t3_tezr5y,False,True,t1_i0tgqzk,/r/haskell/comments/tezr5y/comparison_of_targeted_strengths_between_rust_go/i0tw4lz/,1647394673,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
809.0,[],False,,lgastako,,,[],,,,text,t2_1mp2i,False,False,"Under [alpha equivalence](https://en.wikipedia.org/wiki/Lambda_calculus#Alpha_equivalence) `reliability -&gt; concurrency -&gt; abstraction` is the same as `a -&gt; b -&gt; c` which makes it easier to see that this type describes (hand waving a little bit) a function which takes two values of any type and returns a third value of any type _of the caller's choosing_, a function for which there is no reasonable implementation in Haskell (not counting bottom values).",76c105d4973b8144fed2913f0ac2fee2bacdef55,True,False,,,,,0,1647394580,,0,{},i0tvxly,False,t3_tezr5y,False,True,t1_i0sqlwk,/r/haskell/comments/tezr5y/comparison_of_targeted_strengths_between_rust_go/i0tvxly/,1647394597,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
810.0,[],False,,man-vs-spider,,,[],,,,text,t2_5by84,False,False,I just want to put it out there that as a Numpy/Matplotlib equivalent is at the top of my Haskell wishlist.,7faff10009230c37607b74435387493aa783ae77,True,False,,,,,0,1647389782,,0,{},i0tl0r3,False,t3_teq0tw,False,True,t3_teq0tw,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0tl0r3/,1647389792,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
811.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"That's what I'd reach for, but I haven't debugged ELF binaries in probably a decade.  There might be better tools.  (I did some remote debugging on 4690 binaries, but you need a special IBM debugger to that because gcc/gdb doesn't support the calling convention [OS/2-style].)",edc88efbc1416b2f5b9688ed0d23dc1210e5b4e1,True,False,,,,,0,1647389676,,0,{},i0tks43,False,t3_teq0tw,False,True,t1_i0thch8,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0tks43/,1647389687,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
812.0,[],False,,someacnt,,,[],,,,text,t2_euebihog,False,False,"Oh, so gdb? :)",7acbcc222726a92f03a6d5e6307b8b947ba8bef9,True,False,,,,,0,1647388148,,0,{},i0thch8,False,t3_teq0tw,False,True,t1_i0tefi1,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0thch8/,1647388166,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
813.0,[],False,,Instrume,,,[],,,,text,t2_xfalw,False,False,"The most important thing is to figure out what your goals are.

  
Like, do you want to become a hobbyist programmer? Do you want to become a professional programmer? Haskell, IMO, has a fairly steep learning curve but it's a good ""high-ground"" for beginning programmers, you'll just have to supplement exercises and projects with those from other languages.

&amp;#x200B;

On the other hand, if you want to become a professional programmer, just pick whatever is most likely to get you a job (which is not Haskell). You can always come back to Haskell later.",c8b58d78f82a6206457209c5a713fbebbfe3f461,True,False,,,,,0,1647387880,,0,{},i0tgqzk,False,t3_tezr5y,False,True,t3_tezr5y,/r/haskell/comments/tezr5y/comparison_of_targeted_strengths_between_rust_go/i0tgqzk/,1647387897,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
814.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,Use a C debugger. :),ac4a81a8aaf858a583b2570c4c3f4641720d3b6e,True,False,,,,,0,1647386864,,0,{},i0tefi1,False,t3_teq0tw,False,True,t1_i0tdld1,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0tefi1/,1647386879,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
815.0,[],False,,someacnt,,,[],,,,text,t2_euebihog,False,False,"Interesting, how could you put breakpoint here? I thought it would be hard as IDE won't help with FFI-involved debugging.",604c0226607a497e8430d00041147efe5607a702,True,False,,,,,0,1647386506,,0,{},i0tdld1,False,t3_teq0tw,False,True,t1_i0rsmpd,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0tdld1/,1647386519,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
816.0,[],False,,WJWH,,,[],,,,text,t2_dhu9y,False,False,"I think the main difference is not so much in the language features themselves but in the community around them, their philosophy, aims, how they formed and what they strive for. The language features just flow from that.

* Haskell was formed by and for academic researchers, to have a language ""platform"" for research into programming language design. There is some commercial use (ie the financial sector has been using it for a long time, facebook spam filtering, the fairly recent IOHP web framework, etc) but by and large you will find more focus on research and less focus on ""business"" topics. One aspect to this is that newbie-friendlyness can sometimes take a back seat to ever increasing levels of mathematical abstraction.
* Go was created by Google to allow developers to quickly and correctly develop large-scale services. It aggressively focuses on simplicity to the point of omitting many features that other languages have and even to the point of making developers type a lot of boilerplate code, in the service of keeping the language small and the compiler fast.
* Rust was originally developed at Mozilla for improving the rendering engine of Firefox and is focused around the ideas of memory safety and speed. It really doesn't mind adding big complex features like borrow checking or async, but only if they can be made ""zero cost"" (ie if you don't use them they will not take any extra memory or CPU time).",77aa39754a45c693f2d5528d577b9bc99e7681a8,True,False,,,,,0,1647383174,,0,{},i0t5os9,False,t3_tezr5y,False,True,t3_tezr5y,/r/haskell/comments/tezr5y/comparison_of_targeted_strengths_between_rust_go/i0t5os9/,1647383187,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
817.0,[],False,,MWatson,,,[],,,,text,t2_1q75,False,True,"Other people here mentioned Hasktorch. Last week I spent a few hours experimenting with the many included examples. I looks like a great project!

And unlike the old TensorFlow for Haskell bindings, it was easy to build.

I don't intend to complain, but I was so very bummed out when the TensorFlow for Haskell was mothballed.",675c567afb92998f0d3183a664b8ca063929121d,True,False,,,,,0,1647383005,,0,{},i0t59zf,False,t3_teq0tw,False,True,t3_teq0tw,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0t59zf/,1647383020,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
818.0,[],False,,sheepforce1,,,[],,,,text,t2_4dek96xp,False,False,"From my perspective of computational chemistry; There is some core functionality missing or hard to access.

These are parts, that I severely miss:

* Sparse linear algebra
* tensor algebra, especially convenient stuff like einsum in python
* automatic differentiation for linear algebra
* a mature and powerful scientific plotting library like matplotlib, that is easily usable (there are gnuplot bindings, the chart library, matplot bindings, plotly bindings, ... however, they are hard to use, look very imperative, or lack important features)
* Statistics and data analysis; Clustering algorithms, correlation analysis, even some basic non-linear regression functions.

Also many things do not interact nicely, also some examples:

* For general array operations there is [Massiv](https://hackage.haskell.org/package/massiv) (wonderful library), [Repa](https://hackage.haskell.org/package/repa), [Array](https://hackage.haskell.org/package/array-0.5.4.0/docs/Data-Array.html), [Accelerate](https://hackage.haskell.org/package/accelerate). Each has its own array type and I am not aware of any reasonable way to have them interoperate.
* Linear algebra: [hmatrix](https://hackage.haskell.org/package/hmatrix) again with its own array type (and [linear](https://hackage.haskell.org/package/linear) but this is restricted to low dimensions)
* Fourier Transformations: [fft](https://hackage.haskell.org/package/fft), again with its own array type

So if I would write for example a quantum dynamics code, that requires series of tensor contractions and in between Fourier transformations, it already becomes difficult. With some look one can type cast array types in O(1) (Massiv to HMatrix for example).

The advantage of ecosystems such as Python with Numpy, Scipy, Sympy is, that they are all well integrated.",0b5f221f073dd4d55d6c622138888955d4f12cd1,True,False,,,,,0,1647382143,,0,{},i0t347e,False,t3_teq0tw,False,True,t3_teq0tw,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0t347e/,1647382154,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
819.0,[],False,,yourdigitalvoice,,,[],,,,text,t2_4fjkjj7g,False,False,Thank you for picking that up!,e84f957f96f8bf6107703dddf9e6536a055446b6,True,False,,,,,0,1647381703,,0,{},i0t1z38,True,t3_telf9t,False,True,t1_i0qcpau,/r/haskell/comments/telf9t/haskellers_functional_conf_2022_is_online_and/i0t1z38/,1647381715,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
820.0,[],False,,ConfEngine,,,[],,,,text,t2_4rfhxpaq,False,False,Thank you for picking that up!,e84f957f96f8bf6107703dddf9e6536a055446b6,True,False,,,,,0,1647381640,,0,{},i0t1t31,False,t3_telf9t,False,True,t1_i0qcpau,/r/haskell/comments/telf9t/haskellers_functional_conf_2022_is_online_and/i0t1t31/,1647381655,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
821.0,[],False,,leo_richardson,,,[],,,,text,t2_74r8njzr,False,False,Yeah basically op can’t b explained,4fb2f46442f12700050888670569240daa18308a,True,False,,,,,0,1647377768,,0,{},i0srrke,False,t3_t91tjq,False,True,t1_hzrs5r8,/r/haskell/comments/t91tjq/if_a_type_signature_is_a_float_and_the_input_is/i0srrke/,1647377785,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
822.0,[],False,,pm_me_r34_r34,,,[],,,,text,t2_vdd44hm,False,False,"Yeah I wasn't clear in the post but I implicitly meant that easy abstraction implies easy concurrency, and easy concurrency implies easy reliability.

Or `reliability -&gt; concurrency -&gt; abstraction`",2abef5edfdd31c55d35e99517c78f7f50d3c69b5,True,False,,,,,0,1647377332,,0,{},i0sqlwk,True,t3_tezr5y,False,True,t1_i0sq1uh,/r/haskell/comments/tezr5y/comparison_of_targeted_strengths_between_rust_go/i0sqlwk/,1647377348,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
823.0,[],False,,AmbroseHaskell,,,[],,,,text,t2_ioythzj0,False,False,"I would say Haskell has as-easy or easier concurrency compared to go

`go = forkIO` and now you even have equivalently terse syntax",6d8df72bc6149e4f00f6d7d0876bfd012d24c5d0,True,False,,,,,0,1647377123,,0,{},i0sq1uh,False,t3_tezr5y,False,True,t3_tezr5y,/r/haskell/comments/tezr5y/comparison_of_targeted_strengths_between_rust_go/i0sq1uh/,1647377138,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
824.0,[],False,,leo_richardson,,,[],,,,text,t2_74r8njzr,False,False,Everybody says that 😏,f163fe7dd54c60ee8d3b155e0be535225f5f519b,True,False,,,,,0,1647377072,,0,{},i0spwv5,False,t3_t3zk03,False,True,t1_hz08n7d,/r/haskell/comments/t3zk03/help_with_dp_algorithm_performance/i0spwv5/,1647377088,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
825.0,[],False,,dun-ado,,,[],,,,text,t2_ihltqlra,False,False,I didn't realize that. I wasn't sure how much of lapack was exposed to Haskell via hmatrix. Your recommendation makes more sense to me.,2fefaa94e802b28a3dea497be3e434d5d461c92f,True,False,,,,,0,1647374088,,0,{},i0si3yu,False,t3_teq0tw,False,True,t1_i0shab6,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0si3yu/,1647374105,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
826.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,Doesn't `hmatrix` already cover lapack? And it seems there is also a `hmatrix-gsl` library. I'd recommend extending that work if it is not sufficient yet.,dd3be9c820e7ad80aafa1efcb3432dbb94ed92fb,True,False,,,,,0,1647373771,,0,{},i0shab6,False,t3_teq0tw,False,True,t1_i0sg6sb,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0shab6/,1647373788,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
827.0,[],False,,dun-ado,,,[],,,,text,t2_ihltqlra,False,False,"You may want to start with these projects and add haskell interops much like Ed Kmett's gl package:

* https://performance.netlib.org/lapack/#_related_projects

* https://www.gnu.org/software/gsl/",4943034baaa65eeb0f608c47ea8d9da10fcbf92d,True,False,,,,,0,1647373350,,0,{},i0sg6sb,False,t3_teq0tw,False,True,t3_teq0tw,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0sg6sb/,1647373366,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
828.0,[],False,,ShalokShalom,,,[],,,,text,t2_gehcq,False,False,"I mean, Elm is successful since it focused on one thing.
A domain specific language.",1c13b4f8d318d3ff1cc2c6a4c3de75d6d2e38fae,True,False,,,,,0,1647367946,,0,{},i0s29d5,False,t3_tc7g4q,False,False,t1_i0h3b0a,/r/haskell/comments/tc7g4q/any_haskelllike_languages_with_native_frp/i0s29d5/,1647367959,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
829.0,[],False,,AdOdd5690,,,[],,,,text,t2_77ggiprk,False,False,"I am currently watching the following talk on Levity If you could provide the slide deck I would appreciate it. These topics are new to me, so any resource is more than welcome.

&amp;#x200B;

&gt;As for matrix multiplication, strict type coherence would benefit from dependent types but in Fortean or C you don’t have that luxury either.

By strict type coherence do you mean that when performing matrix multiplication the resulting types (at the low-level unboxing and boxing) do not change?  

&amp;#x200B;

&gt;Oh it’s in no way ignorant. It’s a good approach indeed. I’ve used it extensively and it’s all been quite great.

Thanks for you kind words. I hope to share the same great experience :)",1ca37d4235e81220817bc9582a279d6dad3f9434,True,False,,,,,0,1647365425,,0,{},i0rvrfk,True,t3_teq0tw,False,True,t1_i0rtujn,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0rvrfk/,1647365439,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
830.0,[],False,,Puzzled-Bananas,,,[],,,,text,t2_b66sdh32,False,False,"What’s missing in my opinion is the completion of the hmatrix tutorial that follows step with NumPy’s. A lot of numerical work is experimental. And we already are lucky to have a Jupyter kernel (IHaskell). What’s missing is the onboarding and ergonomics. Linear algebra is good. If I recall correctly I think I missed some PDE solvers, but I just wrote them myself, no big issue really, with some pieces via inline-c.

I think it’s best to look at what’s popular in the Julia community and just focus on porting some of it. They put a lot of effort to popularize their platform. However I’ve had a couple of professional issues with their flagship differential equations library. Perhaps inline-julia would be nice to have and open up the window to more robust interop, unless someone already has gone this route.

Off the top of my head, it’s classical ODE and modern PDE problems, SPDEs, linear algebra problems, I also do some mathematical physics, which means numerical problems formulated in the language of differential geometry and statistics. The statistics package provides some fundamental methods, it needs attention regarding more modern methods, but we can interop with R.
And now there’s the gorilla in the room - deep learning. Better GPU, Vulkan, TPU support. I think the order I’ve phrased it in this paragraph even mirrors the priorities as I perceive them.

Oh and thanks for raising this issue. It’s indeed a very important field of application for Haskell and one that requires more attention.",fd7a827cc60a2ebacf05564da6218ae7ab9321d4,True,False,,,,,0,1647364892,,0,{},i0rue1a,False,t3_teq0tw,False,False,t3_teq0tw,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0rue1a/,1647364904,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
831.0,[],False,,Puzzled-Bananas,,,[],,,,text,t2_b66sdh32,False,False,"Oh it’s in no way ignorant. It’s a good approach indeed.
I’ve used it extensively and it’s all been quite great. 

A lot of numerical work can be done by unboxing and careful strictness annotations. There’s a great slide deck that describes GHC internals. Sorry I‘ve been out of the loop on these things for a few months now. I‘ll look for a link to the most recent version unless someone posts it before. Take a look at hmatrix too. In addition you c an leverage inline-r and inline-c to access R and C bindings.

I don’t think GHC makes it “unflexible” in any reasonable way. Same for type-level formalisms.

So as usual you need to understand GHC’s operational semantics, essentially the evaluation strategies, in order to write efficient Haskell number crunchers.

As for matrix multiplication, strict type coherence would benefit from dependent types but in Fortean or C you don’t have that luxury either.",d3771a059b4b3aaeedf510c810402753e3624245,True,False,,,,,0,1647364685,,0,{},i0rtujn,False,t3_teq0tw,False,True,t1_i0rov92,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0rtujn/,1647364696,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
832.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"&gt; What do you think could be a workaround this?

I don't have one, sorry; especially if you want to fix **Haskell** and not just GHC (or another language).

There's already smarter, more driven people working on reducing the pain of those complexities in GHC.

&gt; Based on that, could a workaround could be doing some low-level programming in C (or Haskell) to help with efficiency?

It's already pretty easy to bind to C / call C from Haskell.  So, if it's acceptable to use C implementations, you can do that today.  You might run into the run time debugging problem, but oddly enough C FFI barriers help there, because all the arguments and results are in NF and you can breakpoint on the ABI-guaranteed C symbols.",523254e992389954ef26d33e76778023aac98b59,True,False,,,,,0,1647364212,,0,{},i0rsmpd,False,t3_teq0tw,False,True,t1_i0rov92,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0rsmpd/,1647364229,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
833.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"&gt; ""Note that this project is in early development and should only be used by contributing developers.""

Anyone who wants to do ML in Haskell should probably become a contributing developer then :)


&gt; The docs didn't generate on hackage

I believe the documentation is not generating because they use backpack which still doesn't have good support.

&gt; I don't see which package I would even start with for building a matrix and finding the determinant (e.g.).

I think the determinant function is [here](https://github.com/hasktorch/hasktorch/blob/9560d149b06af17e2d4e73d1e116afd2b0baff86/hasktorch/src/Torch/Typed/Functional.hs#L2880-L2893).",e4da5a774fcaa4f68d3586071cfb4f87fbde8a01,True,False,,,,,0,1647364089,,0,{},i0rsbdm,False,t3_teq0tw,False,True,t1_i0rogah,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0rsbdm/,1647364102,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
834.0,[],False,,AdOdd5690,,,[],,,,text,t2_77ggiprk,False,False,"It’s a shame they are unmaintained. But I believe that a native implementation could motivate the Haskell community to maintain it. 

&gt;Native Haskell implementations also tend to be slow (due to the boxing), inflexible (working only with GHC unboxed types), or complex (type classes and existentials and levity polymorphism, oh my!).

What do you think could be a workaround this? 

I understand that Travis Oliphant (SciPy and NumPy creator) used C and FORTRAN to overcome some issues in Python like memory allocation, and to help with the effort of building the alogrithms using FORTRAN subroutines. 

Based on that, could a workaround could be doing some low-level programming in C ([or Haskell](https://www.youtube.com/watch?v=Ip51xutCDPo)) to help with efficiency? I would assume that the effort would be high, also developing numerical algorithms requires tons of effort.

P.S. I apologize if this last question is ignorant in any sense, just trying to understand better :)",85914b25518d8f720196841ad2a6c4b717e165e2,True,False,,,,,0,1647362763,,0,{},i0rov92,True,t3_teq0tw,False,True,t1_i0rfwn3,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0rov92/,1647362778,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
835.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"&gt; HaskTorch

""Note that this project is in early development and should only be used by contributing developers.""

The docs didn't generate on hackage, but I don't see which package I would even start with for building a matrix and finding the determinant (e.g.).

Not sure I'd even count it yet.

&gt; grenade

I wasn't aware of this one.  Could be useful, though I see some KnownNat constraints in there, and while my experience with singletons is limited, I've found error messages difficult to deal with.  (I really should spend more time with dependent GHC, but when I know I'm going to need DTs, I just start with Idris.)",4b308823550a4bc16ba7318a02a25201f3bd2a77,True,False,,,,,0,1647362603,,0,{},i0rogah,False,t3_teq0tw,False,True,t1_i0rh4ba,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0rogah/,1647362618,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
836.0,[],False,,AmbroseHaskell,,,[],,,,text,t2_ioythzj0,False,False,An abandoned project sometimes means someone else worked through half the hard problems for you ;),b36cb6b9ceda277fec96f4f4330a46af38563c49,True,False,,,,,0,1647361289,,0,{},i0rl14z,False,t3_temn9b,False,True,t1_i0r2pim,/r/haskell/comments/temn9b/generate_typescript_from_servant_api/i0rl14z/,1647361305,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
837.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"&gt; I don't know of any statically typed TensorFlow-like libraries, even if you go to a full dependently-type language or use every GHC extenion you can spell.


Like [grenade](https://hackage.haskell.org/package/grenade) or [HaskTorch](https://hackage.haskell.org/package/hasktorch)? Neither is anywhere near the maturity of TensorFlow of course, but I think at least HaskTorch is very promising.",9811f318ec0ace1401dbf98c78f2e7d6bc970649,True,False,,,,,0,1647359766,,0,{},i0rh4ba,False,t3_teq0tw,False,True,t1_i0rfwn3,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0rh4ba/,1647359783,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
838.0,[],False,,rigidSkolem,,,[],,,,text,t2_7on3d2m4,False,False,"lol, that was a mistake!",b8529011dcc9d671887f3c65f2748c8203f7a96b,True,False,,,,,0,1647359759,,0,{},i0rh3p6,False,t3_te7fso,False,True,t1_i0r63t1,/r/haskell/comments/te7fso/is_it_true_that_continuation_passing_style_allows/i0rh3p6/,1647359775,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
839.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"AFAIK, it's all in the libraries.  No one is maintaining bindings to NumPy, TensorFlow, etc. (or their underlying C libraries) to Haskell.

There's also _some_ concept shear as Haskell programmers generally expect more compile-time errors and have worse run time debugging facilities, but well-typed matrix multiplication (which involes rather simple typing compare to tensor calculus) is rather annoying to implement and use in Haskell-by-the-report.  I don't know of _any_ statically typed TensorFlow-like libraries, even if you go to a full dependently-type language or use every GHC extenion you can spell.

Native Haskell implementations also tend to be slow (due to the boxing), inflexible (working only with GHC unboxed types), or complex (type classes and existentials and levity polymorphism, oh my!).  Though I'm pretty sure there's still some brilliant hard-worker putting together something great I just am not aware of, yet.",4e9769e411f8206f057d12e6d7b06594c46deb68,True,False,,,,,0,1647359300,,0,{},i0rfwn3,False,t3_teq0tw,False,True,t3_teq0tw,/r/haskell/comments/teq0tw/what_are_the_current_challenges_in_numerical/i0rfwn3/,1647359313,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
840.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"&gt; Also it seems that not all pair of adjoint functors for Haskell monads can be expressed using Haskell functors so i guess it's of limited use as an implementation strategy

Yeah.  That's been my experience so far as well.  There does seem to be some ""deep"" categorical meaning/truth/reality, but I've not yet been able to use it to design or implement good code.  For me, which I think something might (not) be a monad, I just do my best to implement `join` and if I fail at that (and `bind`, but I usually try `join` first), I don't give it a `Monad` instance.

I'd _guess_ that using a language with dependent types might make more adjunctions translate directly into code if the `Functor` equivalent wasn't limited to endofunctors, but that's mere speculation on my part.",fe274058b20a41df149bbc26ab5cc9642064e0f1,True,False,,,,,0,1647358256,,0,{},i0rd958,False,t3_te8tn1,False,False,t1_i0qdoj8,/r/haskell/comments/te8tn1/why_are_monad_transformer_types_not_wrapping/i0rd958/,1647358268,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
841.0,[],False,,imsekun,,,[],,,,text,t2_96x7erfk,False,False,"No, but not because it doesn't work since I haven't tried it. More on prioritization, and doing more leg work for that to work is currently at the bottom of the list.",1f65f0bcdbdcde36e9993ba0439ff0947477aef4,True,False,,,,,0,1647355722,,0,{},i0r70a0,False,t3_temn9b,False,True,t1_i0r4y1o,/r/haskell/comments/temn9b/generate_typescript_from_servant_api/i0r70a0/,1647356786,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
842.0,[],False,,imihnevich,,,[],,,,text,t2_gtbhi7wu,False,False,"Thanks for all the info! Though, the first link opens up a video with a deadlift. Lifting is important for a true Haskeller, but I'm not sure if that was your intention",4cc9f32a59b7aa45c2a5dc9dd1c95f5a35aac1a7,True,False,,,,,0,1647355350,,0,{},i0r63t1,True,t3_te7fso,False,True,t1_i0r423k,/r/haskell/comments/te7fso/is_it_true_that_continuation_passing_style_allows/i0r63t1/,1647355361,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
843.0,[],False,,Odd-Fox-8410,,,[],,,,text,t2_7pefb5kd,False,False,"Thanks, great info. Did you end up using it?",41a312014601cb60c33e87ea642b6641a5271544,True,False,,,,,0,1647354866,,0,{},i0r4y1o,True,t3_temn9b,False,True,t1_i0r4apb,/r/haskell/comments/temn9b/generate_typescript_from_servant_api/i0r4y1o/,1647354877,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
844.0,[],False,,imsekun,,,[],,,,text,t2_96x7erfk,False,False,"I asked a somewhat relevant question recently. Maybe you'll find this discussion somewhat helpful: https://github.com/haskell-servant/servant/issues/1547; two packages were talked about. One of the folks from Well Typed replied, and said they tried it recently (and worked fine).

But yeah, since none of them are on Hackage, much more on Stackage, you'll have to refer to either one of these via `git` instead.",f888b88c898d93bc8167e0534e21ba93bfa7196f,True,False,,,,,0,1647354592,,0,{},i0r4apb,False,t3_temn9b,False,True,t3_temn9b,/r/haskell/comments/temn9b/generate_typescript_from_servant_api/i0r4apb/,1647354609,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
845.0,[],False,,maerwald,,,[],,,,text,t2_t8qgl,False,False,"Ah, true. Then cabal won't help you.

In that case your only option is:

* https://docs.haskellstack.org/en/stable/yaml_configuration/#extra-deps
* https://cabal.readthedocs.io/en/3.6/cabal-project.html#specifying-packages-from-remote-version-control-locations

or... fork the package and publish it to hackage yourself. There's nothing stopping that.",05179b0ed7fd008d15126efee4de7216d6ee91cb,True,False,,,,,0,1647354540,,0,{},i0r464k,False,t3_temn9b,False,True,t1_i0r06g8,/r/haskell/comments/temn9b/generate_typescript_from_servant_api/i0r464k/,1647354556,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
846.0,[],False,,rigidSkolem,,,[],,,,text,t2_7on3d2m4,False,False,"I'm not sure about ""tail calls"", everything in GHC is converted to Core, as another commenter said. There's really no distinction between a ""tail call"" and a regular call, and ghc is doing a lot of work that is more clever than eliminating a stack return when a function call is the final call of a function.  


Continuations can be used for efficiency gains in Haskell, though. One use case of them the ""Codensity"" monad, a continuation, to avoid quadratic time traversals of ADTs: [https://hackage.haskell.org/package/kan-extensions-5.2.3/docs/Control-Monad-Codensity.html#t:Codensity](https://www.youtube.com/watch?v=AwhuE2h44A0&amp;ab_channel=AustinWhite) The linked paper includes a working example of how you could use the Codensity monad to speed up a Tree traversal.  


An example library that uses this is ""fast-parser"": [https://github.com/bartavelle/fastparser/blob/master/src/ByteString/Parser/Fast.hs#L99](https://github.com/bartavelle/fastparser/blob/master/src/ByteString/Parser/Fast.hs#L99) , although the library authors warn ""this isn't a battle tested lib"".  


Still, writing code a continuation passing style is a lot harder to read, and certainly harder for me to debug. I've worked on a test suite that used continuation style for mocking data in a database then cleaning it up in the same transaction, and was constantly surprised by errors and anomalies that were the ""spooky action at a distance"" flavor. This could easily be a result of the requirements and development practices, but my opinion on using continuation passing is that it should be avoided in all cases except where you have a relatively small thing to model and that thing needs to be fast, like a parser. Hope this helps!",27f6eee920df138e4be08962a90524152a73b389,True,False,,,,,0,1647354491,,0,{},i0r423k,False,t3_te7fso,False,True,t3_te7fso,/r/haskell/comments/te7fso/is_it_true_that_continuation_passing_style_allows/i0r423k/,1647354504,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
847.0,[],False,,Odd-Fox-8410,,,[],,,,text,t2_7pefb5kd,False,False,"Oh, that's smart! Yeah - I noticed that too, and it might be a fun little thing to do myself.",7974ce62fa4f1dcfb59b6074ccf27a6fbd202458,True,False,,,,,0,1647353915,,0,{},i0r2pim,True,t3_temn9b,False,True,t1_i0r1zv7,/r/haskell/comments/temn9b/generate_typescript_from_servant_api/i0r2pim/,1647353929,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
848.0,[],False,,dnikolovv,,,[],,,,text,t2_1jfr3jmr,False,False,"Just add the repository in your `extra-deps` in `stack.yaml` like so:

```yaml
- git: https://github.com/smaccoun/servant-ts.git
  commit: da86b8434c67f228f2f7b3098f4d6ed44e842e61
```

The project seems abandoned though.",2fbfd0ede1ddbddb03f357e0be367b2101cf004c,True,False,,,,,0,1647353599,,0,{},i0r1zv7,False,t3_temn9b,False,True,t3_temn9b,/r/haskell/comments/temn9b/generate_typescript_from_servant_api/i0r1zv7/,1647353617,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
849.0,[],False,,Odd-Fox-8410,,,[],,,,text,t2_7pefb5kd,False,False,"Hmm, not sure I'm willing to change completely for that. And it doesn't even seem like the project is on Hackage either. 

I might just download the source.",4dbb493e6d436962c60982a663c525fa366ae78d,True,False,,,,,0,1647352787,,0,{},i0r06g8,True,t3_temn9b,False,True,t1_i0qxi6i,/r/haskell/comments/temn9b/generate_typescript_from_servant_api/i0r06g8/,1647352800,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
850.0,[],False,,maerwald,,,[],,,,text,t2_t8qgl,False,False,"Just ditch stack and use cabal directly: https://cabal.readthedocs.io/en/3.6/getting-started.html

Also check out https://hackage.haskell.org/package/stack2cabal

So, for starters, you could try:

1. run `stack2cabal --no-pin-ghc` (there are binaries [here](https://github.com/hasufell/stack2cabal/releases/tag/v1.0.13))
2. add the servant-ts to your `&lt;project-name&gt;.cabal` file
3. run `cabal build`

If you encounter problems, share your repository/project.",98b9ce45e6a63d069b980c0ad668b58e063baf54,True,False,,,,,0,1647351558,,0,{},i0qxi6i,False,t3_temn9b,False,True,t1_i0qw1fc,/r/haskell/comments/temn9b/generate_typescript_from_servant_api/i0qxi6i/,1647351569,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
851.0,[],False,,Odd-Fox-8410,,,[],,,,text,t2_7pefb5kd,False,False,"Use cabal and stack at the same time? Sorry, I'm just a hobby-haskeller, and will forever find the environment confusing.  
How do I go about doing that?",054581c1eeab35b9f76a1b455928c7c76080691f,True,False,,,,,0,1647350852,,0,{},i0qw1fc,True,t3_temn9b,False,True,t1_i0quexe,/r/haskell/comments/temn9b/generate_typescript_from_servant_api/i0qw1fc/,1647350864,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
852.0,[],False,,maerwald,,,[],,,,text,t2_t8qgl,False,False,You can just use cabal and have proper hackage support.,1c8d4e76441d7fc96ae403934b6a318ca980ce38,True,False,,,,,0,1647350060,,0,{},i0quexe,False,t3_temn9b,False,True,t3_temn9b,/r/haskell/comments/temn9b/generate_typescript_from_servant_api/i0quexe/,1647350075,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
853.0,[],False,,usernameqwerty005,,,[],,,,text,t2_2b0vq4qb,False,False,"I thought maybe you guys would be interested in this attempt, to convert the tagless-final use-case to PHP (or any OOP scripting language). :)",8fdbf9664fd200d20055451c3710ca50a6046a77,True,False,,,,,0,1647348681,,0,{},i0qrrcq,True,t3_teo9ze,False,True,t3_teo9ze,/r/haskell/comments/teo9ze/one_universal_dryrun_mockspy_ast_evaluator_to/i0qrrcq/,1647348698,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
854.0,[],False,,Dasher38,,,[],,,,text,t2_25jago8f,False,False,"Had a quick look at adjoint functors and while I dont really understand what it is, it's interesting to see that monads can be split somehow. Also it seems that not all pair of adjoint functors for Haskell monads can be expressed using Haskell functors so i guess it's of limited use as an implementation strategy",6a3b53f0ed486d895b0fdcee2049c00353a14ee9,True,False,,,,,0,1647339557,,0,{},i0qdoj8,True,t3_te8tn1,False,True,t1_i0pm26y,/r/haskell/comments/te8tn1/why_are_monad_transformer_types_not_wrapping/i0qdoj8/,1647339568,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
855.0,[],False,,imihnevich,,,[],,,,text,t2_gtbhi7wu,False,False,"Got it, thanks",61034b405101744bea34d9b5d6c8b09d4ad5c7b7,True,False,,,,,0,1647339301,,0,{},i0qdctk,True,t3_te7fso,False,True,t1_i0qcz5r,/r/haskell/comments/te7fso/is_it_true_that_continuation_passing_style_allows/i0qdctk/,1647339317,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
856.0,[],False,,mauganra_it,,,[],,,,text,t2_17gks2,False,False,"No, GHC converts Haskell code into Core, which gets in turn converted into opcodes for the backends. There is not really any dedicated CPS transformation involved in GHC's compilation pipeline.",bd7189a7e55db9332b5d4430b23298fec94a437c,True,False,,,,,0,1647338992,,0,{},i0qcz5r,False,t3_te7fso,False,True,t1_i0q2rls,/r/haskell/comments/te7fso/is_it_true_that_continuation_passing_style_allows/i0qcz5r/,1647339005,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
857.0,[],False,,kaol,,,[],,,,text,t2_4h9in,False,False,https://www.functionalconf.com/ The link in title text is not clickable.,e2b0c550f1749d976c58e70fe88ec8a0db673cef,True,False,,,,,0,1647338763,,0,{},i0qcpau,False,t3_telf9t,False,True,t3_telf9t,/r/haskell/comments/telf9t/haskellers_functional_conf_2022_is_online_and/i0qcpau/,1647338778,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
858.0,[],False,,Venom_moneV,,,[],,,,text,t2_t80um,False,False,"Hi, I'm learning yesod and I was wondering if anyone has setup tailwindcss with yesod. Is there any stack templates that I can use?",4341b56f6141429eb11f55b4ee4b55f27fb78f19,True,False,,,,,0,1647338464,,0,{},i0qcc5m,False,t3_t3zw0x,False,True,t3_t3zw0x,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i0qcc5m/,1647338476,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
859.0,[],False,,Tarmen,,,[],,,,text,t2_7mjdo,False,False,"All FRP implementations I really liked (kotlin compose, swift ui, and kind of svelte) quite extensively use compiler rewrites so a language build around this would be interesting. 

The closest I know of is skiplang which is incremental by default, but I don't know if there is any ui tooling for it. Also Facebook doesn't use it anymore so not sure how much development it will see.",20735ad13ae324ca73c0106086049ac806f98f0b,True,False,,,,,0,1647337239,,0,{},i0qavyo,False,t3_tc7g4q,False,True,t3_tc7g4q,/r/haskell/comments/tc7g4q/any_haskelllike_languages_with_native_frp/i0qavyo/,1647337255,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
860.0,[],False,,pdpi,,,[],,,,text,t2_5l7a7,False,True,"For all the problems it causes, laziness-by-default is still one of the most interesting features of Haskell.",5a0c873dad709dbab31a4cb4b49b8c857802be04,True,False,,,,,0,1647337217,,0,{},i0qav14,False,t3_te7fso,False,True,t1_i0pp8mz,/r/haskell/comments/te7fso/is_it_true_that_continuation_passing_style_allows/i0qav14/,1647337229,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
861.0,[],False,,imihnevich,,,[],,,,text,t2_gtbhi7wu,False,False,So can I think of it as because of laziness Haskell turns my recursion into CPS?,259a83516117b1519a6519dc15611f631684ffd7,True,False,,,,,0,1647330237,,0,{},i0q2rls,True,t3_te7fso,False,False,t1_i0pp8mz,/r/haskell/comments/te7fso/is_it_true_that_continuation_passing_style_allows/i0q2rls/,1647330249,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
862.0,[],False,,tomejaguar,,,[],,,,text,t2_45sug,False,False,Nice! Well done. If you have any more questions about product-profunctors or Opaleye then please let me know. It's best to ask by \[opening an issue\](https://github.com/tomjaguarpaw/haskell-opaleye/issues/new).,999d87b2154531e1a7221ec1b84b1cf9f2c1649d,True,False,,,,,0,1647329821,,0,{},i0q29nr,False,t3_tbn46e,False,True,t1_i0obekl,/r/haskell/comments/tbn46e/out_of_memory_when_building_productprofunctors/i0q29nr/,1647329833,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
863.0,[],False,,Tarmen,,,[],,,,text,t2_7mjdo,False,False,"Do you know how appending strings can be become quadratic?

    (""Foo"" &lt;&gt; ""bar"") &lt;&gt; ""Baz"" -- copies foo twice
    ""Foo"" &lt;&gt; (""bar"" &lt;&gt; ""Baz"") -- copies foo once

For lists `&lt;&gt;` has to walk to the end of the first linked list, so the first version has to walk to the leaf of `""foo""` and `""foo"" &lt;&gt; ""bar""`.

One trick to fix this is to use a builder

    data StringBuilder = Leaf String | Append StringBuilder StringBuilder

Here we can generate the string in a single pass - we essentially re-associate the append calls. Another way to do this is Endo https://hackage.haskell.org/package/base-4.16.0.0/docs/Data-Semigroup.html#t:Endo


We can replace the Append constructor with function composition. This might build a binary tree of continuations on the heap, or GHC might do eta expansion and end up with the nice ordering. Either way it's linear rintime:

    (""Foo""&lt;&gt;) . (""Bar""&lt;&gt;) . (""Baz""&lt;&gt;) $ """"


Anyway. Some tree-like monads have the same problem, `&gt;&gt;=` must walk to the leaves of the tree so the wrong associativity will be quadratic. We can use CPS to re-associate the `&gt;&gt;=` calls, either with the ContT or CodensityT types.

We also could use an explicit builder tree in memory,  this is the pattern from the `A smart view in datatypes` paper!",03a536e080ad74e426566637c21eb9b0ed6aa4b2,True,False,,,,,0,1647325198,,0,{},i0pwe49,False,t3_te7fso,False,True,t1_i0oaxn6,/r/haskell/comments/te7fso/is_it_true_that_continuation_passing_style_allows/i0pwe49/,1647325210,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
864.0,[],False,,benjaminhodgson,,,[],,,,text,t2_dp6v0,False,False,"You didn’t ask, but you might find it interesting: the reason Haskell’s runtime stack is different is because of laziness. Haskell’s runtime stack is a stack of “thunks currently being evaluated”, rather than a stack of function calls. If your program tries to evaluate something to WHNF, but it finds that it needs the (WHNF) result of some other computation in order to do that, it’ll put the current thunk into the runtime stack and go about evaluating the second one, then return to the initial computation.

Because of the way people tend to write Haskell code, these nested chains of thunks don’t usually get long (although they certainly _can_). So stack overflows aren’t so much of a concern as they are in strict functional languages (in which the “obvious” strategy of pushing a stack frame for every function call is liable to blow the stack, because recursive functions are common.)",92b16c8a989f4081e9e91bbf4c20aff9116c34f9,True,False,,,,,0,1647320239,,0,{},i0pp8mz,False,t3_te7fso,False,True,t1_i0omcoa,/r/haskell/comments/te7fso/is_it_true_that_continuation_passing_style_allows/i0pp8mz/,1647320251,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
865.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"Often the other way isn't a monad.  Ultimately this depends on what parts of the adjunction are affected by the transform.  For reader it's all on the left side (left . m; left = (-&gt;) env); for writer its all on the right side (m . right; right = (,) w); for state it's sort of reader+writer, so it's partially on the left and partially on the right (left . m . right; left = (-&gt;) s; right = flip (,) s).",752cd07d1d20a9399bb9da29275aca9592d522cd,True,False,,,,,0,1647318355,,0,{},i0pm26y,False,t3_te8tn1,False,True,t3_te8tn1,/r/haskell/comments/te8tn1/why_are_monad_transformer_types_not_wrapping/i0pm26y/,1647318370,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
866.0,[],False,,Opposite-Platypus-99,,,[],,,,text,t2_clsnehel,False,False,"do you guys ever ""log off""",70c677d805aa646ea46357af4bb5b3df9f8c80b1,True,False,,,,,0,1647316980,,0,{},i0pjjkd,False,t3_td4xbd,False,True,t1_i0jrrvy,/r/haskell/comments/td4xbd/property_testing_textbook/i0pjjkd/,1647316991,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
867.0,[],False,,cdsmith,,,[],,,,text,t2_1trov,False,False,https://www.cis.upenn.edu/\~plclub/blog/2020-05-15-Defunctionalize-the-Continuation/,fc90f01428d0e5e49a78d9b424a28d86877a8118,True,False,,,,,0,1647310121,,0,{},i0p5cgd,False,t3_te7fso,False,True,t1_i0oaxn6,/r/haskell/comments/te7fso/is_it_true_that_continuation_passing_style_allows/i0p5cgd/,1647310132,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
868.0,[],False,,nrnrnr,,,[],,,,text,t2_3h0sf,False,False,"It’s a specialized trick, but when you need it, it is super useful.  For example, CPS makes it super easy to implement a backtracking search. (The time change is killing me so I am not thinking of any other good examples.) CPS is also killer for anything you would implement using `goto`.  For example, a lexical analyzer.

The heart of CPS is that everything is tail calls.   But tail calls are useful independent of CPS.  I find that it helps to think of the tail call as “goto with arguments.” And if the target if your goto is a parameter passed in, rather than a destination you know at compile time, now you have CPS.",b6f55c0a35cbc05fc91622ab16d68e8365fd21b4,True,False,,,,,0,1647304796,,0,{},i0otjhf,False,t3_te7fso,False,True,t1_i0oaxn6,/r/haskell/comments/te7fso/is_it_true_that_continuation_passing_style_allows/i0otjhf/,1647304813,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
869.0,[],False,,Dasher38,,,[],,,,text,t2_25jago8f,False,False,"Indeed, that also works with State. If when inspecting the result you have to unwrap a Maybe before running the State function, you are basically guaranteed to always have a Just (why would you ever get anything else ?) and then it's just a plain State. 

Given 

StateT s m a  contains  s -&gt; m (a, s)
 And MaybeT m a contains m (Maybe a)

StateT s (MaybeT Identify) a gives s -&gt; (Identity (Maybe a), s)

MaybeT (StateT s Identity) a gives s -&gt; Identity (Maybe a, s)

With that definition it commutes and gives almost the same type (modulo an Identity layer). With the wrong definition it becomes:

StateT s (MaybeT Identify) a gives s -&gt; (Maybe (Identity a), s)

MaybeT (StateT s Identity) a gives Maybe (s -&gt; Identity (a, s))


So interestingly it still seems to work if MaybeT is the inner transformer (but maybe the implementation does not work out). Since IO has no transformer, it has to be the bottom one.

Another interesting point (to me) is that I just witnessed that commuting issue today in a transformer I'm coming up with, so there is a chance I somewhat have to swap the base monad with something else like this MaybeT example ...",271056741323e44e97ec7a3378a0cb517fde98b8,True,False,,,,,0,1647304178,,0,{},i0os62y,True,t3_te8tn1,False,True,t1_i0oo1bz,/r/haskell/comments/te8tn1/why_are_monad_transformer_types_not_wrapping/i0os62y/,1647304189,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
870.0,[],False,,korreman,,,[],,,,text,t2_9tvgnu8q,False,False,"Monad transformers are pretty aptly named. They take a monad type and transform it in some way. There isn't a rule for what should 'contain' what,  just a convention that transforming the `Identity` monad should result in the non-transformer equivalent. So `MaybeT Identity a` should be equivalent to `Maybe a`.

It might be helpful to look at the kind signatures:

- Type: `*`
- Type constructor (fx. monad): `* -&gt; *`
- Monad transformer: `(* -&gt; *) -&gt; (* -&gt; *)`

As you can see, the monad transformer takes a monad and spits out a new one.",9c759499eceef7a29ee13bba88820a5a01d0ada1,True,False,,,,,0,1647302470,,0,{},i0oodx2,False,t3_te8tn1,False,True,t3_te8tn1,/r/haskell/comments/te8tn1/why_are_monad_transformer_types_not_wrapping/i0oodx2/,1647302484,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
871.0,[],False,,amalloy,,,[],,,,text,t2_6f5lu,False,False,"`Maybe (IO a)` is not a very useful type. It can't do IO in order to decide whether the result is `Just` or `Nothing`, for example - it has to compute, purely, either an IO action or decide to do no IO at all. That's fine in some niche contexts, but much, much more often, you want to do some IO that you maybe abort early, for which `IO (Maybe a)` is suitable.",f0f30cb92d43d52e767be63266300b8f7f2c9f37,True,False,,,,,0,1647302315,,0,{},i0oo1bz,False,t3_te8tn1,False,True,t1_i0oe57e,/r/haskell/comments/te8tn1/why_are_monad_transformer_types_not_wrapping/i0oo1bz/,1647302327,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
872.0,[],False,,neros_greb,,,[],,,,text,t2_3fw0t1i3,False,False,"The io result is needed in order to compute the maybe, so it needs to be inside. An IO (Maybe a) is an io that returns a maybe, so the io action can be used to compute the maybe. With a Maybe (IO a), the maybe is used to compute the io, so the io action can't be run until it's extracted from the maybe. So the maybe result can't depend on the IO making it pretty useless",6c5112470dffe0ec34bfce7a60c557963cdd52d1,True,False,,,,,0,1647302123,,0,{},i0onm5t,False,t3_te8tn1,False,True,t1_i0oe57e,/r/haskell/comments/te8tn1/why_are_monad_transformer_types_not_wrapping/i0onm5t/,1647302141,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
873.0,[],False,,neros_greb,,,[],,,,text,t2_3fw0t1i3,False,False,"In ocaml it's used for this exact purpose; the stack, in ocaml, is limited in size, so putting things on the heap avoids a stack overflow. I think Haskell manages its stack differently so this is not as much of an issue",bae260b27aa5a54ddc2cc876206ce997e3d3ae8c,True,False,,,,,0,1647301550,,0,{},i0omcoa,False,t3_te7fso,False,True,t1_i0oaxn6,/r/haskell/comments/te7fso/is_it_true_that_continuation_passing_style_allows/i0omcoa/,1647301568,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
874.0,[],False,,dkl_prolog,,,[],,,,text,t2_dcbt0,False,False,"CPS is very useful for compilation for reasons I probably should not attempt to convey, since my understanding is fairly weak. My recollection is that CPS is close to a ""linear"" style intermediate representation you would want for code generation or to convert to a truly linear IR.

It also gives you the possibility to interrupt the program at various places, which is useful if you're trying to create a suspendable language runtime. More about CPS can be found in the book _Compiling with Continuations_ by Andrew Appel.",637ed297b2ccf0a96758077c169cea17508323fc,True,False,,,,,0,1647301458,,0,{},i0om55s,False,t3_te7fso,False,True,t1_i0oaxn6,/r/haskell/comments/te7fso/is_it_true_that_continuation_passing_style_allows/i0om55s/,1647301469,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
875.0,[],False,,Dasher38,,,[],,,,text,t2_25jago8f,False,False,"Does it ? For MaybeT, that would give ""Maybe (IO a)"" which does not look especially wrong, as ""IO a"" can be seen as an action providing an ""a"".

That said I can imagine that having IO as the outer layer is more efficient, as the IO will always be the outer layer of the final optimized program anyway.",6a60a781e2ccfb659d93aeca442b56ff402a96fc,True,False,,,,,0,1647297890,,0,{},i0oe57e,True,t3_te8tn1,False,True,t1_i0o945j,/r/haskell/comments/te8tn1/why_are_monad_transformer_types_not_wrapping/i0oe57e/,1647297913,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
876.0,[],False,,paf31,,,[],,,,text,t2_4s09r,False,False,"Yes, the context that is being managed is organized like a stack, and the indices of the terms on that stack are the DeBruijn indices. Indices can be related by &lt;=, and the cast terms themselves could be seen as evidence for those relationships.",a91b98690c6b07380e44ec2d975aa43fe30c8b94,True,False,,,,,0,1647297690,,0,{},i0odoj3,False,t3_tbtjxs,False,True,t1_i0mic9x,/r/haskell/comments/tbtjxs/higherorder_abstract_syntax_for_cartesian_closed/i0odoj3/,1647297718,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
877.0,[],False,,Swordlash,,,[],,,,text,t2_2fpxe4mw,False,False,"Seems that I solved the problem:

https://gitlab.haskell.org/ghc/ghc/-/issues/21230#note\_415215",4220fd62c1e24cba107d2663af3e5d51716201ff,True,False,,,,,0,1647296721,,0,{},i0obekl,True,t3_tbn46e,False,True,t1_i0mzz03,/r/haskell/comments/tbn46e/out_of_memory_when_building_productprofunctors/i0obekl/,1647296737,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
878.0,[],False,,imihnevich,,,[],,,,text,t2_gtbhi7wu,False,False,Is there anything else that makes this pattern valuable?,6d3f161da6e2a3c00bf6fb8ffc6a3497f99f4fb0,True,False,,,,,0,1647296521,,0,{},i0oaxn6,True,t3_te7fso,False,True,t1_i0o4ah3,/r/haskell/comments/te7fso/is_it_true_that_continuation_passing_style_allows/i0oaxn6/,1647296534,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
879.0,[],False,,Swordlash,,,[],,,,text,t2_2fpxe4mw,False,False,"I think there has been such a question recently.

So, roughly speaking, transforming a monad is adding a new functionality *to the existing monad*. Therefore, the ""runXXX"" return type will live in the base monad, but the underlying result will be enriched with a functionality provided by the transformer.",e82ae3e6666c5efd6f6aa451e59a77d1904bd985,True,False,,,,,0,1647296065,,0,{},i0o9v7s,False,t3_te8tn1,False,False,t3_te8tn1,/r/haskell/comments/te8tn1/why_are_monad_transformer_types_not_wrapping/i0o9v7s/,1647296080,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
880.0,[],False,,andrewthad,,,[],,,,text,t2_j765z,False,False,"The really bad handwaving explanation, which is really the only explanation I’m aware of, is to just imagine what happens when m is IO. Only one order for the layers makes sense in that case.",2c337b288127c66da5dc7e238351607c1eef6a36,True,False,,,,,0,1647295739,,0,{},i0o945j,False,t3_te8tn1,False,True,t3_te8tn1,/r/haskell/comments/te8tn1/why_are_monad_transformer_types_not_wrapping/i0o945j/,1647295758,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
881.0,[],False,,AmbroseHaskell,,,[],,,,text,t2_ioythzj0,False,False,"Yes, but worst-case you're turning some of that stack allocation into heap allocation via the continuation you're passing",73de15ad6de3a996cfabead8d546786fbc6cdcf1,True,False,,,,,0,1647293538,,0,{},i0o4ah3,False,t3_te7fso,False,True,t3_te7fso,/r/haskell/comments/te7fso/is_it_true_that_continuation_passing_style_allows/i0o4ah3/,1647293553,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
882.0,[],False,,shiraeeshi,,,[],,,,text,t2_2ob9l434,False,False,You people feed off other people's resumes or something?,e3d6557804176e253dd6ff822f652260e6083d26,True,False,,,,,0,1647291285,,0,{},i0nyspy,False,t3_tdze8u,False,True,t3_tdze8u,/r/haskell/comments/tdze8u/hiring_adeva_is_hiring_remote_haskell_developers/i0nyspy/,1647291301,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
883.0,[],False,,Martinsos,,,[],,,,text,t2_bng1b,False,False,"How do you ensure that \`cabal\` uses freeze file?  
Does \`cabal build\` automatically use freeze file over myproject.cbal?

Or do we have to somehow specify that freeze file should be used?",3e376b836a8dc5456681aef59ccc5f849f10bad0,True,False,,,,,0,1647285466,,0,{},i0nk29d,False,t3_s4fcoy,False,True,t1_hsqv0fe,/r/haskell/comments/s4fcoy/should_i_commit_cabal_freeze_files_to_my_repo/i0nk29d/,1647285483,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
884.0,[],False,,tomejaguar,,,[],,,,text,t2_45sug,False,False,"That's OK, I'm happy to help!",b74efdd6b5d3100fc4b00eca81dc9e7e3ef5a1d8,True,False,,,,,0,1647277715,,0,{},i0mzz03,False,t3_tbn46e,False,True,t1_i0mwzg7,/r/haskell/comments/tbn46e/out_of_memory_when_building_productprofunctors/i0mzz03/,1647277731,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
885.0,[],False,,Swordlash,,,[],,,,text,t2_2fpxe4mw,False,False,"So I guess it's really a problem with my installation handling TH. Sorry for taking your time, it was just a first time I have ever had such an issue.",f0f7300445e3a1d241ba5f39647a5e1913b5691e,True,False,,,,,0,1647276567,,0,{},i0mwzg7,True,t3_tbn46e,False,True,t1_i0mwlmq,/r/haskell/comments/tbn46e/out_of_memory_when_building_productprofunctors/i0mwzg7/,1647276582,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
886.0,[],False,,tomejaguar,,,[],,,,text,t2_45sug,False,False,"Aha, that's good evidence that the problem is indeed the problem.",cd76ebc211015b6e9264bfabc76b3f4a5e74942f,True,False,,,,,0,1647276417,,0,{},i0mwlmq,False,t3_tbn46e,False,True,t1_i0mvjo7,/r/haskell/comments/tbn46e/out_of_memory_when_building_productprofunctors/i0mwlmq/,1647276434,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
887.0,[],False,,Swordlash,,,[],,,,text,t2_2fpxe4mw,False,False,"I tried to check other packages using TH, and I got the same error with `th-orphans`:

    mateusz@Mateuszs-MacBook-Pro ~ % cabal repl --build-depends=th-orphans
Resolving dependencies...
Build profile: -w ghc-8.10.7 -O1
In order, the following will be built (use -v for more details):
 - th-orphans-0.13.12 (lib) (requires build)
 - fake-package-0 (lib) (first run)
Starting     th-orphans-0.13.12 (lib)
Building     th-orphans-0.13.12 (lib)
cabal: Failed to build th-orphans-0.13.12 (which is required by
fake-package-0). The build process was killed (i.e. SIGKILL). The typical
reason for this is that there is not enough memory available (e.g. the OS
killed a process using lots of memory).",f3b4f1ee64e72ba00513d63e137c1c1f5ae61634,True,False,,,,,0,1647276010,,0,{},i0mvjo7,True,t3_tbn46e,False,True,t1_i0mjxd7,/r/haskell/comments/tbn46e/out_of_memory_when_building_productprofunctors/i0mvjo7/,1647276024,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
888.0,[],False,,_query,,,[],,,,text,t2_fjd8s,False,False,"Thanks!

Nesting could be implemented if you change the syntax a little bit, removing the inner `[hsx||]`:

`[hsx| &lt;div&gt;{ xs &lt;&amp;&gt; \x -&gt; &lt;p&gt;{ xName x }&lt;/p&gt; } |]`

[In the splice parser](https://github.com/digitallyinduced/ihp/blob/master/ihp-hsx/IHP/HSX/Parser.hs#L240) we use a Haskell parser to turn the inner string (e.g. `""xs &lt;&amp;&gt; \x -&gt; &lt;p&gt;{ xName x }&lt;/p&gt;""`) into a Haskell expression. To make nested splices work, we would need to apply a pre-parser function that replaces all HTML tags with the correct blaze syntax (basically recursively calling the HSX parser on itself). Might be a bit hacky, but will work :)",619fc5877e3069453926bbe8ac9c4ff8c9e5e906,True,False,,,,,0,1647272463,,0,{},i0mmjda,True,t3_tdt8cb,False,True,t1_i0mev10,/r/haskell/comments/tdt8cb/ann_ihphsx_jsxlike_templating_syntax_for_haskell/i0mmjda/,1647272475,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
889.0,[],False,,tomejaguar,,,[],,,,text,t2_45sug,False,False,"This is rather curious. Perhaps `cabal repl` works because it is not generating native code, just byte code?

If you're willing to spend time diagnosing this it could make a useful bug report (I guess for GHC?). I'm willing to help you continue diagnosing if you like.",aee6b9d328ed8142391a5042f3e56f432f7038eb,True,False,,,,,0,1647271375,,0,{},i0mjxd7,False,t3_tbn46e,False,True,t1_i0mcdew,/r/haskell/comments/tbn46e/out_of_memory_when_building_productprofunctors/i0mjxd7/,1647271388,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
890.0,[],False,,blamario,,,[],,,,text,t2_4mp51,False,False,I think your `Cast` instances boil down to DeBruijn indices.,65d7b341e2953a099d3a896a7b5444018e182a91,True,False,,,,,0,1647270714,,0,{},i0mic9x,False,t3_tbtjxs,False,True,t3_tbtjxs,/r/haskell/comments/tbtjxs/higherorder_abstract_syntax_for_cartesian_closed/i0mic9x/,1647270726,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
891.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,In GHCi without a type signature will default the result type to `()` which has a `toEnum` implementation that fails for all inputs except 0.,a238433ae7d2a2eb48ed4ba4ffcaa8fdb5e15d6e,True,False,,,,,0,1647270436,,0,{},i0mhos8,False,t3_tdh2nn,False,True,t1_i0makgh,/r/haskell/comments/tdh2nn/pattern_matching_rps/i0mhos8/,1647270454,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
892.0,[],False,,LordGothington,,,[],,,,text,t2_1s8lhray,False,False,"How about no functions at all?

    {-# LANGUAGE DataKinds #-}
    {-# LANGUAGE PolyKinds #-}
    {-# LANGUAGE TypeFamilyDependencies #-}
    import Data.Proxy (Proxy(..))
    import Data.Typeable (Typeable, typeOf)
    
    ------------------------------
    -- | game types &amp; logic
    ------------------------------
    
    -- | hand signals
    data Throw = Rock | Paper | Scissors
       deriving (Eq, Ord, Read, Show, Enum, Typeable)
    
    -- | Winner
    data Winner
      = Player1 | Player2 | Draw
      deriving (Eq, Ord, Read, Show, Enum, Typeable)
    
    -- | game logic
    type family DeclareWinner (throw1 :: Throw) (throw2 :: Throw) :: winner where
      DeclareWinner Rock Scissors   = Player1
      DeclareWinner Scissors Paper  = Player1
      DeclareWinner Paper Rock      = Player1
      DeclareWinner a a             = Draw
      DeclareWinner a b             = Player2
    
    ------------------------------
    -- | some optional sugar
    ------------------------------
    
    -- | useful for displaying the winner
    
    class WinnerVal (w :: Winner) where
      winnerVal :: Proxy w -&gt; Winner
    
    instance WinnerVal Player1 where
      winnerVal _ = Player1
    
    instance WinnerVal Player2 where
      winnerVal _ = Player2
    
    instance WinnerVal Draw where
      winnerVal _ = Draw
    
    -- | some helper functions
    play :: Proxy throw1 -&gt; Proxy throw2 -&gt; Proxy (DeclareWinner throw1 throw2)
    play _ _ = Proxy
    
    player1 :: Proxy Player1
    player1 = Proxy
    
    player2 :: Proxy Player1
    player2 = Proxy
    
    rock :: Proxy Rock
    rock = Proxy
    
    paper :: Proxy Paper
    paper = Proxy
    
    scissors :: Proxy Scissors
    scissors = Proxy
    
    -------------------------
    -- | main
    -------------------------
    main =
      do -- no sugar
         putStrLn $ ""Scissors vs Rock  -&gt; "" &lt;&gt; show ( typeOf (Proxy :: Proxy ((DeclareWinner Scissors Rock) :: Winner)) )
         -- some sugar
         putStrLn $ ""Rock vs Rock      -&gt; "" &lt;&gt; show (winnerVal (Proxy :: Proxy (DeclareWinner Rock Rock)))
         putStrLn $ ""Rock vs Paper     -&gt; "" &lt;&gt; show (winnerVal (Proxy :: Proxy (DeclareWinner Rock Paper)))
         -- the most sugar
         putStrLn $ ""Scissors vs Paper -&gt; "" &lt;&gt; show (winnerVal (play scissors paper))",40fa8e233f3de33b958b2ab792a69f136211d756,True,False,,,,,0,1647269329,,0,{},i0mf2z3,False,t3_tdh2nn,False,True,t3_tdh2nn,/r/haskell/comments/tdh2nn/pattern_matching_rps/i0mf2z3/,1647269355,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
893.0,[],False,,ocharles,,,[],,,,text,t2_9ojk6,False,False,"Wow, impressive timing - I was literally days away from writing this myself (but I was going to target `lucid`). Great work! Something I really want from this - which is unfortunately impossible due to how quasiquotes work - is the ability to arbitrarily nest splices. I'd like to be able to say: `[hsx| &lt;div&gt;{ xs &lt;&amp;&gt; \x -&gt; [hsx|&lt;p&gt;{ xName x }&lt;/p&gt;|] } |]`. Unfortunately quasiquotes can't be nested like this though, and the first `|]` terminates the whole thing, causing a parse error :( It's a real shame, because you *can* do this for Template Haskell splices!",27e6bc7ffa4602b2081499c08bd866749d583d35,True,False,,,,,0,1647269236,,0,{},i0mev10,False,t3_tdt8cb,False,True,t3_tdt8cb,/r/haskell/comments/tdt8cb/ann_ihphsx_jsxlike_templating_syntax_for_haskell/i0mev10/,1647269250,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
894.0,[],False,,mihassan,,,[],,,,text,t2_eaxy8rp,False,False,"Interesting. I actually tested with the type annotation, but when posting here the format for garbled and decided to remove type annotation without testing.",5afa816709f129c62afb4da0193d843e625f385c,True,False,,,,,0,1647269162,,0,{},i0mep0x,False,t3_tdh2nn,False,False,t1_i0makgh,/r/haskell/comments/tdh2nn/pattern_matching_rps/i0mep0x/,1647269179,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
895.0,[],False,,Swordlash,,,[],,,,text,t2_2fpxe4mw,False,False,"I didn't have problems in a simple project. Also, running `cabal repl` on product-profunctors project compiles and works without problems.",2e488609ef36ef471075df47fd8d4d18ea9ed092,True,False,,,,,0,1647268126,,0,{},i0mcdew,True,t3_tbn46e,False,True,t1_i0luksu,/r/haskell/comments/tbn46e/out_of_memory_when_building_productprofunctors/i0mcdew/,1647268143,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
896.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"    Prelude&gt; play Rock Scissor
    *** Exception: Prelude.Enum.().toEnum: bad argument

But, yeah, if you skew positive before the `mod`, you should have something going.",46f5f9049b590f12a1ed666e0fa4c811dba1ae58,True,False,,,,,0,1647267314,,0,{},i0makgh,False,t3_tdh2nn,False,True,t1_i0lsb0i,/r/haskell/comments/tdh2nn/pattern_matching_rps/i0makgh/,1647267329,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
897.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"Property-based testing feels quite related to fuzz testing, though the former is more ""white box"" and the later is more ""black box"", both in the properties, and in the testing style.",4ebe1256aa0eccd2789f40077dc748b643fa2f01,True,False,,,,,0,1647267108,,0,{},i0ma4e6,False,t3_td4xbd,False,True,t1_i0lt9s6,/r/haskell/comments/td4xbd/property_testing_textbook/i0ma4e6/,1647267126,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
898.0,[],False,,blamario,,,[],,,,text,t2_4mp51,False,False,"&gt; We can implement a zipper-like wrapper over Text and give it Stream instance that keeps track of the current line/column as the parser consumes input (e.g. increment the line number every time we consume a newline)

That's already implemented as 
[a newtype wrapper](https://hackage.haskell.org/package/monoid-subclasses-1.1.3/docs/Data-Monoid-Instances-Positioned.html). You won't be able to use megaparsec with it unfortunately.",106c2c354f4dab584fbdae8be6a9ab3227805904,True,False,,,,,0,1647266255,,0,{},i0m8ai5,False,t3_tbumkw,False,True,t3_tbumkw,/r/haskell/comments/tbumkw/implementing_a_json_linter_with_line_column/i0m8ai5/,1647266269,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
899.0,[],False,,blamario,,,[],,,,text,t2_4mp51,False,False,The [`wai-logger` package](https://hackage.haskell.org/package/wai-logger-2.4.0/wai-logger.cabal) only depends on `cabal-doctest` for testing. You don't need to test `wai-logger` in order to use it.,ec6fe34d21fc195f5d61374303cda435f6fa7273,True,False,,,,,0,1647265816,,0,{},i0m7cuj,False,t3_tbnfjv,False,True,t3_tbnfjv,/r/haskell/comments/tbnfjv/build_issues_with_cabal/i0m7cuj/,1647265831,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
900.0,[],False,,aspiwack-tweag,,,[],,,,text,t2_u65on6,False,False,"The thing about streams is that they tend to want to escape their scopes a lot.

Say you want to define a stream of lines in a file

```haskell
lines :: Handle -&gt; Stream Text

openLines :: FilePath -&gt; IO (Stream Text)
openLines path = withFile path $ \handle -&gt;
  return $ lines handle
  -- oops: the handle will now close, but we will use it when we consume the stream later
```

With an explicit `delete`, we can control the exact lifetime of the handle, so we'd have

```haskell
-- Closes the Handle when the stream ends
lines :: Handle %1-&gt; Stream Text

openLines :: FilePath -&gt; IO (Stream Text)
openLines path = do
  handle &lt;- newFile
  return $ lines handle
```

Now, this comes with a bit of a trade-off, which can be annoying in some applications: we have basically no error-handling abilities with linear types (the slogan, here, is that `catch` isn't linearly typed). The errors are pushed to way up where there is no linear types anymore. That's enough for my use-cases (I write very few `catch`s in Haskell in practice), but it's certainly unpleasant that we have to give that up for safe resource handling.",418ad23b4194315d2f6ed3fce8bc9e0ed34453e5,True,False,,,,,0,1647261813,,0,{},i0lzni7,False,t3_tap2nu,False,True,t1_i0ltke2,/r/haskell/comments/tap2nu/what_is_the_longterm_status_of_xlineartypes/i0lzni7/,1647261834,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
901.0,[],False,,aspiwack-tweag,,,[],,,,text,t2_u65on6,False,False,I absolutely agree. It's cheaper to implement in the short term is all (I simply don't have a concrete implementation plan for `Int#` to behave freely even when it is a linear argument; which I think is the right interface).,6c388b98618e4219a5e4ca0a2d850fcc3bbc4cfb,True,False,,,,,0,1647261086,,0,{},i0lye1q,False,t3_tap2nu,False,True,t1_i0ln9kq,/r/haskell/comments/tap2nu/what_is_the_longterm_status_of_xlineartypes/i0lye1q/,1647261099,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
902.0,[],False,,aspiwack-tweag,,,[],,,,text,t2_u65on6,False,False,"Fair. It's still hard to do in the current implementation. I think that `-Wshadowing` doesn't warn in the `do` notation, though. So you could abuse that… but it's not a very satisfactory workaround.",a0e11d899234b847c76542f2fcb191e95c8f608a,True,False,,,,,0,1647260989,,0,{},i0ly875,False,t3_tap2nu,False,True,t1_i0lmzch,/r/haskell/comments/tap2nu/what_is_the_longterm_status_of_xlineartypes/i0ly875/,1647261000,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
903.0,[],False,,tomejaguar,,,[],,,,text,t2_45sug,False,False,"Perhaps you can try compiling a single file, outside of any project, with a simple use of TH. If that fails then that will help narrow down the cause.",8567666d4bb8bcac217f097a0539ffd828351955,True,False,,,,,0,1647258687,,0,{},i0luksu,False,t3_tbn46e,False,True,t1_i0ltrez,/r/haskell/comments/tbn46e/out_of_memory_when_building_productprofunctors/i0luksu/,1647258703,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
904.0,[],False,,Swordlash,,,[],,,,text,t2_2fpxe4mw,False,False,"\&gt; Did you try GHC 9.2.2, by the way?

Yes, same error.",e5dd5f07fda5ae4835a274975916298ffb7fc032,True,False,,,,,0,1647258154,,0,{},i0ltrez,True,t3_tbn46e,False,True,t1_i0ltab2,/r/haskell/comments/tbn46e/out_of_memory_when_building_productprofunctors/i0ltrez/,1647258166,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
905.0,[],False,,CoBuddha,,,[],,,,text,t2_12byxs,False,False,cool thanks for explaining I think that makes sense. Super curious what you mean about streams though - that seems the most persuasive to me personally,2f9b8112e9f4739b3e689bfa192f7afeda7098d7,True,False,,,,,0,1647258021,,0,{},i0ltke2,True,t3_tap2nu,False,True,t1_i0ljl5s,/r/haskell/comments/tap2nu/what_is_the_longterm_status_of_xlineartypes/i0ltke2/,1647258036,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
906.0,[],False,,tomejaguar,,,[],,,,text,t2_45sug,False,False,"Oh, and do you get a better error message when you're compiling the package directly from source? I wonder if some part of your toolchain is not set up.",e0f4ab90c888c07c01507a6566fe13a1a1c5e8bf,True,False,,,,,0,1647258006,,0,{},i0ltjl9,False,t3_tbn46e,False,True,t1_i0ltab2,/r/haskell/comments/tbn46e/out_of_memory_when_building_productprofunctors/i0ltjl9/,1647258022,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
907.0,[],False,,tomejaguar,,,[],,,,text,t2_45sug,False,False,"Interesting. Thanks for providing the exact Diff.

&gt; I wonder why it works for you and not for me though

Yes, it's strange. According to ""About this Mac"" I am using ""Model Identifier: MacBookPro17,1"" on ""Chip: Apple M1"". With GHC 8.10.7 and GHC 9.2.2, if that helps you determine any difference.

Did you try GHC 9.2.2, by the way?",24b76f5a89881951f26b057c2cf67e6bcc67c6f3,True,False,,,,,0,1647257830,,0,{},i0ltab2,False,t3_tbn46e,False,True,t1_i0lrsbt,/r/haskell/comments/tbn46e/out_of_memory_when_building_productprofunctors/i0ltab2/,1647257841,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
908.0,[],False,,sunnyata,,,[],,,,text,t2_4lxh3lrv,False,False,"Our version is normally called property-based testing though, so the confusion isn't too bad.",a6c3288d747b2cca6cceac5a447271894a5ff01c,True,False,,,,,0,1647257820,,0,{},i0lt9s6,False,t3_td4xbd,False,True,t1_i0jrrvy,/r/haskell/comments/td4xbd/property_testing_textbook/i0lt9s6/,1647257834,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
909.0,[],False,,mihassan,,,[],,,,text,t2_eaxy8rp,False,False,"Can it be done with 0 pattern match? Here is my approach which is very similar to u/Noughtmare's suggestion.

&amp;#x200B;

    data Move = Rock | Paper | Scissor deriving (Enum)
data Result = Draw | Win | Loss deriving (Enum)

play :: Move -&gt; Move -&gt; Result
play x y = toEnum $ (fromEnum x - fromEnum y) `mod` 3",4dccd2ba92ee42c3db821b7fe31009971604d3ce,True,False,,,,,0,1647257165,,0,{},i0lsb0i,False,t3_tdh2nn,False,True,t3_tdh2nn,/r/haskell/comments/tdh2nn/pattern_matching_rps/i0lsb0i/,1647257182,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
910.0,[],False,,Swordlash,,,[],,,,text,t2_2fpxe4mw,False,False,"Unfortunately neither ghcup nor I manually cannot compile ghc from sources, I get strange errors from my toolchain.

I deleted the TH directive and all dependencies entirely, then also another two in Flatten. This made it compile. Diff:

[gist](https://gist.github.com/Swordlash/265f32a99fe5cb04e1e702f430cb5a10)",569594fb777e9f7bda0ca37daae448a446066fbc,True,False,,,,,0,1647256796,,0,{},i0lrsbt,True,t3_tbn46e,False,True,t1_i0j0v30,/r/haskell/comments/tbn46e/out_of_memory_when_building_productprofunctors/i0lrsbt/,1647256812,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
911.0,[],False,,augustss,,,[],,,,text,t2_whj8,False,False,"Yes, it's the Mu compiler error messages. I found that just having location information for each identifier in the type goes a long way. The location is the place where the type checker introduced the type. So if you have the expression True then the Bool type will carry the location of the True.",2c7f5a6c8fd2d88374cf173d4ec253ee03923f2f,True,False,,,,,0,1647256389,,0,{},i0lr8cr,False,t3_tap2nu,False,True,t1_i0ljxk6,/r/haskell/comments/tap2nu/what_is_the_longterm_status_of_xlineartypes/i0lr8cr/,1647256405,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
912.0,[],False,,idkabn,,,[],,,,text,t2_4cgeo3ah,False,False,"Interesting suggestion re making I# unrestricted. While that would work, I think that would kind of miss the point of (3) of OP -- for that, Int# should really have copying behaviour. (I concede that this cannot be valid for Int.)",fb2f113a3e3bb56ad5e2397939ec74acc0bae83c,True,False,,,,,0,1647253329,,0,{},i0ln9kq,False,t3_tap2nu,False,True,t1_i0lj1ot,/r/haskell/comments/tap2nu/what_is_the_longterm_status_of_xlineartypes/i0ln9kq/,1647253342,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
913.0,[],False,,idkabn,,,[],,,,text,t2_4cgeo3ah,False,False,"Hm, good point about recursive lets. I guess my main point still stands if that was written `foo x = case bar x of x -&gt; baz x` instead.",54b985171ede880817695eaf50238de72238cca6,True,False,,,,,0,1647253102,,0,{},i0lmzch,False,t3_tap2nu,False,True,t1_i0lk91q,/r/haskell/comments/tap2nu/what_is_the_longterm_status_of_xlineartypes/i0lmzch/,1647253118,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
914.0,[],False,,aspiwack-tweag,,,[],,,,text,t2_u65on6,False,False,"I agree about the diagnostics. It's not good. I don't have a great solution yet, unfortunately.

Having `let`s be non-recursive when they speak about something linear variables is, on the other hand, probably out of scope for the medium term.",0580eeae0043aa5eb9501ffc56fd66e9809a2507,True,False,,,,,0,1647250829,,0,{},i0lk91q,False,t3_tap2nu,False,True,t1_i0cksr9,/r/haskell/comments/tap2nu/what_is_the_longterm_status_of_xlineartypes/i0lk91q/,1647250841,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
915.0,[],False,,aspiwack-tweag,,,[],,,,text,t2_u65on6,False,False,"Is the aforementioned bragging that you allegedly performed about the error messages of the Mu compiler?

For better error messages in GHC, there is also the [_SHErrLoc: a static holistic error locator_](https://www.microsoft.com/en-us/research/publication/sherrloc-static-holistic-error-locator/) paper. I believe it has had an implementation. The bottomline of this paper as I remember it is that GHC's constraint solver forgets a lot of information for performance reason. But it's ok for a constraint solver to be slow _when it produces an error message_ so you can make a second, slower error-oriented constraint solver that will produce much more robust blame.",c6ea1a296da04dd33a21c0df07f215c74da2b47b,True,False,,,,,0,1647250554,,0,{},i0ljxk6,False,t3_tap2nu,False,True,t1_i0jzius,/r/haskell/comments/tap2nu/what_is_the_longterm_status_of_xlineartypes/i0ljxk6/,1647250568,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
916.0,[],False,,aspiwack-tweag,,,[],,,,text,t2_u65on6,False,False,"(6): my opinion is that RAII is good because it's a (mostly) sound discipline without garbage collection. Not because I don't need to call `delete` manually.

It has restrictions, mostly that deallocations are stack-like (which, by the way, doesn't play super well with streams, I've been programming with streams a lot, of late, so my opinion is definitely coloured by that experience).

Calling `delete` manually, as long as the (type or otherwise) system prevents you from leaking resources, is not particularly less ergonomic in my opinion. And it gives you more flexibility. You do get RAII-like behaviour back using `withX` functions, but without some support for nested lifetimes it's not going to work well (it may be possible to add a notion of lifetime within our linear-type formalism, I have some ideas, but I've got to admit that they are very not well-formed yet. I should also mention [_Kindly bent free for us_](https://arxiv.org/abs/1908.09681) which incorporates borrowing primitively in their linearly type system).",4016bcc4b02cf160e7e39a9b8f14ccec05601cde,True,False,,,,,0,1647250261,,0,{},i0ljl5s,False,t3_tap2nu,False,True,t1_i0bs3cm,/r/haskell/comments/tap2nu/what_is_the_longterm_status_of_xlineartypes/i0ljl5s/,1647250273,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
917.0,[],False,,etorreborre,,,[],,,,text,t2_13ljg,False,False,"Nothing worse than stale job posts so I am glad to announce that we found someone for that position :-). We might open more positions in the future, stay tuned",81e1464216504b8b5e61706136f35fa7cfa0f761,True,False,,,,,0,1647250043,,0,{},i0ljc8t,True,t3_sc8wi3,False,True,t3_sc8wi3,/r/haskell/comments/sc8wi3/job_software_engineer_at_symbiont_still/i0ljc8t/,1647250056,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
918.0,[],False,,aspiwack-tweag,,,[],,,,text,t2_u65on6,False,False,"You're welcome, and hello again,

(3) is not really possible for `Int` (but it should be for `Int#`, and it would solve (4) as well), the reason being that in

```haskell
foo :: Int %1-&gt; (Int, Int)
foo x = (x, x)
```

`x` stands for a thunk, which may contain linear variables, so we very much can't share it (in Rust, this would not implement the `Copy` trait). We could generate some code that would force `x`, but that would be quite surprising (using `x` twice suddenly make the function strict). At any rate, I have no plan for custom code generation for the moment, there is quite enough to do with just a type system change.

We could say: ok, but it should be possible if we write:

```haskell
foo :: Int %1-&gt; (Int, Int)
foo !x = (x, x)
```

And, indeed, it could make sense, tough I have no idea how the type system would figure this out. So, for the time being, the plan is to be able to write something like

```haskell
foo :: Int %1-&gt; (Int, Int)
foo (I# x) = (I# x, I# x)
```

(we can actually solve this without doing (3) for `Int#`, just by making `I#` contain an unrestricted `Int#`, but I've refrained from touching the libraries for the time being)",1d999caa208b2e5d823f2294132816378e551be3,True,False,,,,,0,1647249784,,0,{},i0lj1ot,False,t3_tap2nu,False,True,t1_i0cgljm,/r/haskell/comments/tap2nu/what_is_the_longterm_status_of_xlineartypes/i0lj1ot/,1647249796,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
919.0,[],False,,_query,,,[],,,,text,t2_fjd8s,False,False,"Hey all,

we've just published IHP's HSX syntax as a standalone package on Hackage. Previously our HSX syntax was only available when building a full stack IHP app. [Over time a lot of people have asked if HSX can be used outside of IHP as well](https://github.com/digitallyinduced/ihp/issues/132), but because of our use of nix, this was not easily possible. We've now done the work and extracted the HSX code into it's own package.

HSX is just a nicer syntax for blaze-html. So if you use blaze-html, ihp-hsx could be useful to you!

Complete documentation on HSX [can be found in the IHP documentation](https://ihp.digitallyinduced.com/Guide/hsx.html). [The source code can be found in the IHP repo](https://github.com/digitallyinduced/ihp/tree/master/ihp-hsx).",fc4239ebf96889807338066526e9e8663f098e75,True,False,,,,,0,1647249394,,0,{},i0lil2h,True,t3_tdt8cb,False,True,t3_tdt8cb,/r/haskell/comments/tdt8cb/ann_ihphsx_jsxlike_templating_syntax_for_haskell/i0lil2h/,1647249408,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
920.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"Yeah, something like:

    winner :: RPS -&gt; RPS -&gt; Ordering
    winner l r = toEnum ((fromEnum l - fromEnum r + 4) `rem` 3)",7b457a929a8be75a4a6878b37522084f83830563,True,False,,,,,0,1647247154,,0,{},i0lfzz6,False,t3_tdh2nn,False,True,t1_i0k0hdu,/r/haskell/comments/tdh2nn/pattern_matching_rps/i0lfzz6/,1647247168,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
921.0,[],False,,ludvikgalois,,,[],,,,text,t2_dul9o,False,False,"I'm not sure how you're counting pattern matches (I assume deriving `Eq` and then using `(==)` counts as pattern matching since `(==)` will be defined in terms of pattern matching), but how about

    {-# LANGUAGE GADTs #-}
    {-# LANGUAGE RankNTypes #-}

    type RPS a = a -&gt; a -&gt; a -&gt; a
    rock, paper, scissors :: RPS a
    rock     x _ _ = x
    paper    _ x _ = x
    scissors _ _ x = x

    play :: (forall a . RPS a) -&gt; (forall b . RPS b) -&gt; c -&gt; c -&gt; c -&gt; c
    play l r win draw loss = l (r draw loss win) (r win draw loss) (r loss win draw)

    showRPS :: RPS String -&gt; String
    showRPS f = f ""Rock"" ""Paper"" ""Scissors""

    data WrappedRPS where
      Wrap :: (forall a . RPS a) -&gt; WrappedRPS

    moves :: [WrappedRPS]
    moves = [Wrap rock, Wrap paper, Wrap scissors]

    main :: IO ()
    main = mapM_ putStrLn [showRPS f ++ (play f g "" beats "" "" draws with "" "" loses to "") ++ showRPS g | (Wrap f) &lt;- moves, (Wrap g) &lt;- moves]",12567b6f43d2543b189a4ded248fccfa9c595de9,True,False,,,,,0,1647241056,,0,{},i0l8vvr,False,t3_tdh2nn,False,False,t3_tdh2nn,/r/haskell/comments/tdh2nn/pattern_matching_rps/i0l8vvr/,1647241072,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
922.0,[],False,,twitterStatus_Bot,,,[],,,,text,t2_d38zaa6k,False,False,"
\#haskell new basement, foundation, memory, and cryptonite releases, with compatibility with ghc 9.2 now.

also dropped anything GHC &amp;lt; 8.8 .. as per 3-compilers-supported-policy (I realized after the fact that meant 8.8 also)
___
 

posted by [@vincenthz](https://twitter.com/vincenthz/)



^(Media in original tweet is missing? Please PM me to let me know. If media is missing because a tweet is a reply to another tweet or a quote, I will add functionality to display media from these kind of tweets in the future.)",58a7bb9edf17d6204ec87e9033378b159288f376,True,False,,,,,0,1647227382,,0,{},i0kntck,False,t3_tdnph8,False,False,t3_tdnph8,/r/haskell/comments/tdnph8/basement_foundation_memory_and_cryptonite_updated/i0kntck/,1647227398,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
923.0,[],False,,benjaminhodgson,,,[],,,,text,t2_dp6v0,False,False,What are the salary ranges for the Senior/Staff positions?,3d944dfbb2fc3dbd9f053203b5facf2ee37d07ac,True,False,,,,,0,1647224757,,0,{},i0kimsa,False,t3_tcpk2q,False,True,t3_tcpk2q,/r/haskell/comments/tcpk2q/lumi_is_hiring_haskellpurescript_engineers_remote/i0kimsa/,1647224768,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
924.0,[],False,,LEDThereBeLight,,,[],,,,text,t2_83nb2,False,False,"This one is interesting, I do prefer your first one though. Even though I think it reads a little more cleanly, it’s harder for my to immediately grok that it’s correct.",cc710aec9abb0e83689eb990ad1856af10d7e024,True,False,,,,,0,1647218746,,0,{},i0k6a8y,False,t3_tdh2nn,False,True,t1_i0k1o0j,/r/haskell/comments/tdh2nn/pattern_matching_rps/i0k6a8y/,1647218764,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
925.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"You can make it read even nicer, if you try:

    rules =
      [ Rock `crushes` Scissors
      , Scissors `cut` Paper
      , Paper `covers` Rock
      ]

    winner rules = w
     where
      w l r | (l `beats` r) `elem` rules = Just L
      w l r | (r `beats` l) `elem` rules = Just R
      w l r = Nothing

    x `beats` y = (x, y)

    covers = beats
    crushes = beats
    cut = beats",f1a8a2522b133c4f59527ef431a30efb369d0180,True,False,,,,,0,1647216551,,0,{},i0k1o0j,False,t3_tdh2nn,False,True,t1_i0k0k42,/r/haskell/comments/tdh2nn/pattern_matching_rps/i0k1o0j/,1647216568,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
926.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,`winner` turns the two-state `beats` logic into the three-state logic.,ad8da17da9248edac1f61d2180025552032e8bee,True,False,,,,,0,1647216112,,0,{},i0k0q8m,False,t3_tdh2nn,False,True,t1_i0jzclx,/r/haskell/comments/tdh2nn/pattern_matching_rps/i0k0q8m/,1647216122,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
927.0,[],False,,LEDThereBeLight,,,[],,,,text,t2_83nb2,False,False,Great solution.,4e61ac93cb4132ba3fd72521e06ad1ca559f01d8,True,False,,,,,0,1647216033,,0,{},i0k0k42,False,t3_tdh2nn,False,True,t1_i0jryyk,/r/haskell/comments/tdh2nn/pattern_matching_rps/i0k0k42/,1647216050,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
928.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"I like that.  I'll bet there's a way to convert to a `Int`, substract (modulo 3), and then convert the result to an `Ordering` in a way that looks branchless.",f5ac9deb81ec7d48f0e1e2e06a565ea4fd38b9c2,True,False,,,,,0,1647215997,,0,{},i0k0hdu,False,t3_tdh2nn,False,True,t1_i0jt8lh,/r/haskell/comments/tdh2nn/pattern_matching_rps/i0k0hdu/,1647216012,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
929.0,[],False,,augustss,,,[],,,,text,t2_whj8,False,False,"It's pretty easy to get much better error diagnostics. Unfortunately, it will require a little changes in GHC, because the types need location info.",2bd1db8cbecee5071c9ba0b4602a0e3ec685db23,True,False,,,,,0,1647215545,,0,{},i0jzius,False,t3_tap2nu,False,False,t1_i0dp5h1,/r/haskell/comments/tap2nu/what_is_the_longterm_status_of_xlineartypes/i0jzius/,1647215559,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
930.0,[],False,,lurking_bishop,,,[],,,,text,t2_59q1m,False,False,"Technically incomplete, because RPS can have draws, so it's actually tri-state logic :p",599a27fa71cb2bdc21d760c3b78aa5ba3eb724e0,True,False,,,,,0,1647215464,,0,{},i0jzclx,False,t3_tdh2nn,False,False,t1_i0jt8lh,/r/haskell/comments/tdh2nn/pattern_matching_rps/i0jzclx/,1647215479,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
931.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"Untested, but:

    beats x y = fromEnum x == ((fromEnum y + 2) `rem` 3)

Assuming

    data RPS = Rock | Paper | Scissors deriving (Enum)

That saves you 4 pattern matches (depending on how you count).",64964b5c7163ac73e97480d8a56085b4fb76f1b8,True,False,,,,,0,1647212672,,0,{},i0jt8lh,False,t3_tdh2nn,False,False,t1_i0jryyk,/r/haskell/comments/tdh2nn/pattern_matching_rps/i0jt8lh/,1647212690,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
932.0,[],False,,orthocresol,,,[],,,,text,t2_es8zz,False,False,"Hmm... How about this?

    data Move = Rock | Paper | Scissors deriving (Enum, Show)

    outcome :: Move -&gt; Move -&gt; Int
    outcome p1 p2 = case (fromEnum p1 - fromEnum p2) `mod` 3 of
                       1 -&gt; ""Player 1 wins""
                       2 -&gt; ""Player 2 wins""
                       0 -&gt; ""Draw""
                       _ -&gt; ""uh oh""

    main :: IO ()
    main = mapM_ (uncurry showOutcome) games
      where
        moves = [Rock, Paper, Scissors]
        games = [(p1, p2) | p1 &lt;- moves, p2 &lt;- moves]
        showOutcome p1 p2 =
          putStrLn $ concat [show p1, "" vs "", show p2, "": "", outcome x y]",72d60b6928d9f25b3982f81446ecc2238a4e5e5e,True,False,,,,,0,1647212605,,0,{},i0jt31x,False,t3_tdh2nn,False,True,t3_tdh2nn,/r/haskell/comments/tdh2nn/pattern_matching_rps/i0jt31x/,1647212623,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
933.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"    beats Rock Scissors = True
    beats Scissors Paper = True
    beats Paper Rock = True
    beats _ _ = False

    winner l r | beats l r = Just L
    winner l r | beats r l = Just R
    winner _ _ = Nothing",845379be19d87b8587626001ad4d38ece33f974f,True,False,,,,,0,1647212113,,0,{},i0jryyk,False,t3_tdh2nn,False,True,t3_tdh2nn,/r/haskell/comments/tdh2nn/pattern_matching_rps/i0jryyk/,1647212125,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
934.0,[],False,,WikiMobileLinkBot,,,[],,,,text,t2_ctj9ecbj,False,False,"Desktop version of /u/bitconnor's link: &lt;https://en.wikipedia.org/wiki/Property_testing&gt;

 --- 

 ^([)[^(opt out)](https://reddit.com/message/compose?to=WikiMobileLinkBot&amp;message=OptOut&amp;subject=OptOut)^(]) ^(Beep Boop.  Downvote to delete)",39b53427868e958bf44edcae6856cdde9ea3bd96,True,False,,,,,0,1647212045,,0,{},i0jrtji,False,t3_td4xbd,False,True,t1_i0jrrvy,/r/haskell/comments/td4xbd/property_testing_textbook/i0jrtji/,1647212058,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
935.0,[],False,,bitconnor,,,[],,,,text,t2_be0esdi4,False,False,"The concept of ""Property Testing"" in computer science: https://en.m.wikipedia.org/wiki/Property_testing

...seems to be completely different from the technique of property testing (QuickCheck) that is popular in the Haskell world. Quite confusing",82f76cfae236e79efc5bf8227ee6dc1aa4e075f3,True,False,,,,,0,1647212024,,0,{},i0jrrvy,False,t3_td4xbd,False,True,t1_i0heos5,/r/haskell/comments/td4xbd/property_testing_textbook/i0jrrvy/,1647212036,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
936.0,[],False,,orangejake,,,[],,,,text,t2_7tk2b,False,False,"Yeah property testing is very different. The ""standard example"" of a property test (in the sense of this book) is linearity testing a function f by querying the relation f(x+y) = f(x) + f(y) on many random points (x,y). There are many fancier versions of this test for other properties, but property testing is most closely related to topics such as

* (boolean) fourier analysis, and
* additive combinatorics.

This book also seems to discuss testing properties of graphs, which is slightly different, but in general still much closer to combinatorics than anything directly related to functional programming.",cdc0a6f648a7221d94593a2c08fe216ca3071fe6,True,False,,,,,0,1647210555,,0,{},i0jodea,False,t3_td4xbd,False,True,t1_i0heos5,/r/haskell/comments/td4xbd/property_testing_textbook/i0jodea/,1647210570,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
937.0,[],False,,VirusReaper,,,[],,,,text,t2_hkefi,False,False,You were correct. Thank you !,0568f88f1a8676cc3e000abf13436ff66bb68ccd,True,False,,,,,0,1647208541,,0,{},i0jjnq7,True,t3_tdhakm,False,True,t1_i0jiium,/r/haskell/comments/tdhakm/question_can_you_filter_with_strings/i0jjnq7/,1647208558,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
938.0,[],False,,AsykoSkwrl,,,[],,,,text,t2_qzmzx,False,False,"I believe your confusion comes from having tried to filter the characters in a string, versus filtering the strings in a list of strings, which would explain your problem.

    badJohn = filter (/=""john"")",61cc4057e21dce0cc21d48cbed4324167fec00b8,True,False,,,,,0,1647208058,,0,{},i0jiium,False,t3_tdhakm,False,True,t3_tdhakm,/r/haskell/comments/tdhakm/question_can_you_filter_with_strings/i0jiium/,1647208070,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
939.0,[],False,,elvecent,,,[],,,,text,t2_bwz58lm,False,False,"It's definitely a code smell if it's in your business logic. However, if it only emerges when you interpret that logic into something you really intend to use IO calls, then it's fine.

In your business logic, ideally you should have custom effects/typeclasses forming a vocabulary that makes sense to a domain expert who is not necessarily a programmer.",51e047d22777550b2beda91518c11cfd0e23890b,True,False,,,,,0,1647204353,,0,{},i0j9w8v,False,t3_td22b3,False,True,t3_td22b3,/r/haskell/comments/td22b3/question_from_a_beginner_is_liftio_a_code_smell/i0j9w8v/,1647204370,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
940.0,[],False,,tomejaguar,,,[],,,,text,t2_45sug,False,False,"&gt; And taking the maxTupleSize down to 30, 10, 5, even 0 and -1 doesn't help, still out of memory

What happens if you just delete the contents of that module entirely?

&gt; I'm going to ask ghcup to compile GHC from source, perhaps it'll help

Hmm ... I can't quite imagine that working, but if it does then great!",0b4da1f6b4b7a70770afb3e8bce4866b23edb106,True,False,,,,,0,1647200417,,0,{},i0j0v30,False,t3_tbn46e,False,True,t1_i0ixbn2,/r/haskell/comments/tbn46e/out_of_memory_when_building_productprofunctors/i0j0v30/,1647200436,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
941.0,[],False,,Swordlash,,,[],,,,text,t2_2fpxe4mw,False,False,"Actually the module it fails compiling on is `Data.Profunctor.Product.Tuples`, which apart from imports is basically a single directive: `mkTs [0..maxTupleSize]`

So I guess that TH is a culprit here.",6213b7568def5e9245b7bd59ad3af1239a4ad715,True,False,,,,,0,1647198892,,0,{},i0ixbn2,True,t3_tbn46e,False,True,t1_i0ih4gx,/r/haskell/comments/tbn46e/out_of_memory_when_building_productprofunctors/i0ixbn2/,1647198904,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
942.0,[],False,,gdeest,,,[],,,,text,t2_f9a1w,False,False,I stand corrected: https://github.com/haskell-servant/servant/issues/986#issuecomment-1065996140,8801a79fd5719680953aa26509ec606abf6df2aa,True,False,,,,,0,1647196428,,0,{},i0irjh6,False,t3_t8rwe2,False,True,t1_i081i9n,/r/haskell/comments/t8rwe2/named_routes_in_servant/i0irjh6/,1647196446,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
943.0,[],False,,gdeest,,,[],,,,text,t2_f9a1w,False,False,"It actually seems to improve performance on non-nested APIs, which I find very surprising (but if confirmed, is absolutely excellent news.)",505d0f66cdf7057ab1d017062aed634de51cd844,True,False,,,,,0,1647196417,,0,{},i0irijr,False,t3_t8rwe2,False,True,t1_i0fwogr,/r/haskell/comments/t8rwe2/named_routes_in_servant/i0irijr/,1647196446,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
944.0,[],False,,davi_suga,,,[],,,,text,t2_79n3neq0,False,False,"In Brazil, Elixir, which is one of the top paying techs, has the average salary of around 2.2K USD a month (direct conversion). That's a HIGH salary here because the living cost is very low compared to other countries. 4K here is absolutely a top paying position.",e0fa0327776fbe689ca375811f9322dc2e6c896d,True,False,,,,,0,1647194918,,0,{},i0inwey,False,t3_td7txq,False,True,t1_i0i04sb,/r/haskell/comments/td7txq/4k_per_month_looking_for_someone_to_work_on_an/i0inwey/,1647194935,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
945.0,[],False,,doctahFoX,,,[],,,,text,t2_z6pv3,False,False,"This is perfect for my use case, thanks everyone! &lt;3",04062132ee143cf0722df5c089d2fb4d4573f12f,True,False,,,,,0,1647193902,,0,{},i0iley6,False,t3_t3zw0x,False,True,t1_i0ig10n,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i0iley6/,1647193920,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
946.0,[],False,,SSchlesinger,,,[],,,,text,t2_jggeg,False,False,Link is broken for me,243e8ad1fc03f4a99196f140cd557f0801e97791,True,False,,,,,0,1647193806,,0,{},i0il6ew,False,t3_td4xbd,False,True,t3_td4xbd,/r/haskell/comments/td4xbd/property_testing_textbook/i0il6ew/,1647193820,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
947.0,[],False,,the-coot,,,[],,,,text,t2_1t3hztq2,False,False,It's back again.,740b34fce412939b7087aaa510e7a491fb75bd95,True,False,,,,,0,1647192711,,0,{},i0iih1l,True,t3_tcsnnz,False,True,t1_i0i32pw,/r/haskell/comments/tcsnnz/a_remark_on_lazy_st_monad_and_monadfix/i0iih1l/,1647192729,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
948.0,[],False,,tomejaguar,,,[],,,,text,t2_45sug,False,False,"On my Mac Book Pro M1 I was able to compile successfully and it used a few hundred MB of memory, so I haven't been able to reproduce the problem. I haven't heard any other reports of similar behaviour either.

If you're really interested in solving it then you could download [the git repo](https://github.com/tomjaguarpaw/product-profunctors/), run `cabal build`, see if you get the same error, and if so progressively remove parts of the package (by commenting them out in the source files) until you get something to compile. That way you may be able to pinpoint the exact problem.

I'm not sure what else to suggest at this point I'm afraid.",3d8ac0ffb1ff068737f61571a6e2af18e94d21e3,True,False,,,,,0,1647192150,,0,{},i0ih4gx,False,t3_tbn46e,False,True,t1_i0i07ze,/r/haskell/comments/tbn46e/out_of_memory_when_building_productprofunctors/i0ih4gx/,1647192163,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
949.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"You could also store `Maybe`s instead; gotta deal with the `Maybe` in the type of `lookup` anyway. :)

Using an IntSet as a free ""list"" could also work.  Then either `size map` or `minView freeSet` gives you a free (but potentially reused) index, and `size map + size freeSet` gives you an free (and ""new"") index.",05de26fb51137c05ad465ca0dfcba289b3da7591,True,False,,,,,0,1647192089,,0,{},i0igz8t,False,t3_t3zw0x,False,True,t1_i0ig10n,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i0igz8t/,1647192102,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
950.0,[],False,,Noughtmare,,,[],,,,text,t2_shhn8,False,False,"The problem with using `size` as new key is that some entries in the map may be empty. Instead, you could track the empty cells in a [free list](https://en.wikipedia.org/wiki/Free_list) and use `size` only if the free list is empty.",424591d453eb13e65e82dcf4d98bef8cae810010,True,False,,,,,0,1647191692,,0,{},i0ig10n,False,t3_t3zw0x,False,True,t1_i0ieezu,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i0ig10n/,1647191709,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
951.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"Yeah, for a job with that time split, any US based person will expect 150k, at least -- even if they are in ""fly over"" territory.  Technical managers make more than plain devs.

Maybe the position has perks that make up for the low pay -- a righteous cause or stake in future rewards, or maybe it's just targeted for a different job market.  Either way, there's value in being upfront about the base compensation.",5df14b2c8bc2c0559d198dc8e7bc4cce42344a0e,True,False,,,,,0,1647191514,,0,{},i0iflt3,False,t3_td7txq,False,True,t1_i0i04sb,/r/haskell/comments/td7txq/4k_per_month_looking_for_someone_to_work_on_an/i0iflt3/,1647191529,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
952.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"Use `IntMap` structure and `size` before the insert as the key.

Alternatively, I'm pretty sure there's a `Seq`uence type on hackage that has O(1) `length` (same as `IntMap.size`), O(lg n) `!` (same as `IntMap.lookup`), and O(1) `snoc` (`IntMap.insert` is O(lg n), so better).

I'd check the Edison library, searching for a fingertree implementation also works.",eb0bfe5c1b086bf6f3f1f68b89319c0d5fafc5d3,True,False,,,,,0,1647191016,,0,{},i0ieezu,False,t3_t3zw0x,False,True,t1_i0hxo5q,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i0ieezu/,1647191029,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
953.0,[],False,,arkaros,,,[],,,,text,t2_8to21,False,False,I only work on uninteresting projects,cea50aa7a7958ca213bffe005f2f69e7db1bbfad,True,False,,,,,0,1647190745,,0,{},i0idr8p,False,t3_td7txq,False,False,t3_td7txq,/r/haskell/comments/td7txq/4k_per_month_looking_for_someone_to_work_on_an/i0idr8p/,1647190763,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
954.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"`Int#` is an unboxed type. `Int` is a boxed type.

At a high level, both has the semantics of a native-with signed integer.

`Int` has lazy semantics, so the runtime has to be able to hold not just a reified value, but also a closure/thunk.  It also wants to have all references to the same closure be updateable to the result (to avoid double-evaluation; be efficient). `Int` is in Haskell-by-the-report.

`Int#` has strict semantics, so it is fine for the runtime to just always a reified value, and pass it around by value/copy everywhere. `Int#` is GHC-specific.",2c09bcc780488086d8036f051a4d903d4385ec56,True,False,,,,,0,1647190540,,0,{},i0id9n9,False,t3_tcmtk2,False,True,t1_i0h2493,/r/haskell/comments/tcmtk2/what_is_the_point_of_solo_beginner_question/i0id9n9/,1647190552,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
955.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"Instead of `do { liftIO x }` you can do `liftIO do { x }` and instead of `\x -&gt; liftIO y` you can do `liftIO &lt;$&gt; (\x -&gt; y)`.

Pulling `liftX` in/out of lambdas and `do`s might let you combine them with others.",fd7135a4ad6e0b6777f757042cc38792a93a88b4,True,False,,,,,0,1647189980,,0,{},i0ibxbc,False,t3_td22b3,False,True,t1_i0h2zug,/r/haskell/comments/td22b3/question_from_a_beginner_is_liftio_a_code_smell/i0ibxbc/,1647189995,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
956.0,[],False,,BlancII,,,[],,,,text,t2_jl7q6x5x,False,False,4k for a part time job (30-40%)?,da8373aa0db91d63133f8cbac5dddbf31d1a1484,True,False,,,,,0,1647189773,,0,{},i0ibfdz,False,t3_td7txq,False,True,t3_td7txq,/r/haskell/comments/td7txq/4k_per_month_looking_for_someone_to_work_on_an/i0ibfdz/,1647189790,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
957.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"Aw, nuts. :(

I was guessing.",dab5e9b967ba31a1fe992db0e4bf0bfb3d500dd2,True,False,,,,,0,1647189719,,0,{},i0ibalu,False,t3_tcmtk2,False,True,t1_i0hv8vi,/r/haskell/comments/tcmtk2/what_is_the_point_of_solo_beginner_question/i0ibalu/,1647189734,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
958.0,[],False,,ocramz_,,,[],,,,text,t2_jaolcjrr,False,False,Site is unreachable,63053022edb0ea0bfefaa8926a73ea562a1034e7,True,False,,,,,0,1647186210,,0,{},i0i32pw,False,t3_tcsnnz,False,True,t3_tcsnnz,/r/haskell/comments/tcsnnz/a_remark_on_lazy_st_monad_and_monadfix/i0i32pw/,1647186227,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
959.0,[],False,,CultsCultsCults,,,[],,,,text,t2_688e3,False,False,I would like his nuts in Haskell script for 4K per month,3daf37ee70bf9100f4dd1836e45b672a1cad922f,True,False,,,,,0,1647185656,,0,{},i0i1tip,False,t3_td7txq,False,True,t1_i0i04sb,/r/haskell/comments/td7txq/4k_per_month_looking_for_someone_to_work_on_an/i0i1tip/,1647185669,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
960.0,[],False,,pituitarianices,,,[],,,,text,t2_druf6com,False,False,Its an excellent rate in Portugal at least.,f3c3c96fa4e248cc2c0d0ce009ee5b03940b880d,True,False,,,,,0,1647185508,,0,{},i0i1hje,False,t3_td7txq,False,True,t1_i0i04sb,/r/haskell/comments/td7txq/4k_per_month_looking_for_someone_to_work_on_an/i0i1hje/,1647185526,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
961.0,[],False,,Swordlash,,,[],,,,text,t2_2fpxe4mw,False,False,"I am unable to spot the ghc process in the activity monitor, it takes about 3 secs between I enter the command and it fails, as if it were suddenly trying to allocate a huge amount of memory. I'm unable to test any version below [10.0.0.1](https://10.0.0.1), as it requires older ghc and 8.10.7 is the oldest one (in terms of versioning) that is supported on aarch64.",714d9bb4145bdb45fc573c5530398b9e293f37f7,True,False,,,,,0,1647185290,,0,{},i0i1083,True,t3_tbn46e,False,True,t1_i0a924o,/r/haskell/comments/tbn46e/out_of_memory_when_building_productprofunctors/i0i1083/,1647185303,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
962.0,[],False,,Swordlash,,,[],,,,text,t2_2fpxe4mw,False,False,"So have you reproduced the issue, or is it just failing for me?",a604c503dafe7f363c83d38f8612f221938aa691,True,False,,,,,0,1647184930,,0,{},i0i07ze,True,t3_tbn46e,False,True,t1_i0a924o,/r/haskell/comments/tbn46e/out_of_memory_when_building_productprofunctors/i0i07ze/,1647184948,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
963.0,[],False,,dun-ado,,,[],,,,text,t2_ihltqlra,False,False,"Let’s assume US dollars. $4k a month is $48k a year. Either the poster of this job is completely ignorant of market rates or is trying to find a sucker to work way below market rates. 

Regardless, you definitely don’t want to work for someone who could possibly post a job like that.",da72ff9e072031b842405fe61971f369345c42a3,True,False,,,,,0,1647184890,,0,{},i0i04sb,False,t3_td7txq,False,True,t3_td7txq,/r/haskell/comments/td7txq/4k_per_month_looking_for_someone_to_work_on_an/i0i04sb/,1647184902,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
964.0,[],False,,doctahFoX,,,[],,,,text,t2_z6pv3,False,False,"Yeah I think so too, but I have to come up with a not-extremely-inefficient way of getting a free index at every insertion. Maybe I'll just save the greatest taken index and call it a day :D",87b555b5935e67fc6740d0b3b195325b1ca79f33,True,False,,,,,0,1647183761,,0,{},i0hxo5q,False,t3_t3zw0x,False,True,t1_i0htfzq,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i0hxo5q/,1647183776,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
965.0,[],False,,phadej,,,[],,,,text,t2_4qmwn,False,False,"Checking existential properties (i.e. ""there is x such that x = f x"" or ""there is x such that x &lt; f x"") with `QuickCheck` is generally not recommended. There's always a chance that `QuickCheck` won't find an example value.

I'll assume that `f = g y`, i.e. it is a function family, otherwise you could just find parameters for which `f x = x` or `f x &lt; x` and write two ordinary assertion tests.

Better approach is to provide an explicit witness. Instead of ""classical"" 

    forall y. exists x. g y x = x 

make it constructive

    forall y. g y (h y) = h y

where `h` is a function constructing a value `x` at which `g y x = x`.",2304786f5e028aec1c7616fe6b438d63e68ec3c5,True,False,,,,,0,1647183387,,0,{},i0hwvw9,False,t3_tcwird,False,True,t3_tcwird,/r/haskell/comments/tcwird/sometimes_for_quickcheck_verify_that_an/i0hwvw9/,1647183399,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
966.0,[],False,,integrate_2xdx_10_13,,,[],,,,text,t2_h94wf5c8,False,False,"Box = on the heap, Unboxed = on the stack.",23c050bff0c22c2b73f84d737a3012d84d41953b,True,False,,,,,0,1647183325,,0,{},i0hwr8m,False,t3_tcmtk2,False,True,t1_i0h2493,/r/haskell/comments/tcmtk2/what_is_the_point_of_solo_beginner_question/i0hwr8m/,1647183342,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
967.0,[],False,,JohnnyBenis,,,[],,,,text,t2_5n43eni4,False,False,4k of what? Dollars? Gold bars? Punches to the face in case you fail to do your job?,89cafecbcdeeaac83a5a9c20c370960c2cee157a,True,False,,,,,0,1647183237,,0,{},i0hwksl,False,t3_td7txq,False,False,t3_td7txq,/r/haskell/comments/td7txq/4k_per_month_looking_for_someone_to_work_on_an/i0hwksl/,1647183253,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
968.0,[],False,,maerwald,,,[],,,,text,t2_t8qgl,False,False,No. It's fine. Carry on.,318445babfaf37370fac06d456d6022eaf6944ec,True,False,,,,,0,1647182918,,0,{},i0hvwca,False,t3_td22b3,False,True,t3_td22b3,/r/haskell/comments/td22b3/question_from_a_beginner_is_liftio_a_code_smell/i0hvwca/,1647182949,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
969.0,[],False,,phadej,,,[],,,,text,t2_4qmwn,False,False,"Solo's documentation says

&gt; The most important feature of Solo is that it is possible to force its ""outside"" (usually by pattern matching) without forcing its ""inside"", because it is defined as a datatype rather than a newtype. One situation where this can be useful is when writing a function to extract a value from a data structure. Suppose you write an implementation of arrays and offer only this function to index into them:

... https://hackage.haskell.org/package/base-4.16.0.0/docs/Data-Tuple.html#t:Solo",9ba49ed4b535c8cc8042c2e19fc38bea9ec21c0c,True,False,,,,,0,1647182679,,0,{},i0hven3,False,t3_tcmtk2,False,True,t3_tcmtk2,/r/haskell/comments/tcmtk2/what_is_the_point_of_solo_beginner_question/i0hven3/,1647182689,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
970.0,[],False,,phadej,,,[],,,,text,t2_4qmwn,False,False,"&gt; Also, in GHC there's different treatment of boxed and unboxed types. I think maybe Identity can only be applied to boxed types, were Solo can be applied to any type. 

If you meant to say that `Solo` is levity-polymorphic, i.e. we could write `Solo Int#`, than that' iss wrong: `Solo` is not levity-polymorphic.",4752cdc2bcc3c6d752c5fbe7909554ca4484d28c,True,False,,,,,0,1647182601,,0,{},i0hv8vi,False,t3_tcmtk2,False,True,t1_i0edaxj,/r/haskell/comments/tcmtk2/what_is_the_point_of_solo_beginner_question/i0hv8vi/,1647182615,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
971.0,[],False,,phadej,,,[],,,,text,t2_4qmwn,False,False,"`Only` is a `newtype`, not `data`. (I.e. `Identity` vs `Solo`).",4f9e40511250ffd15b181222f552754afeb5c190,True,False,,,,,0,1647182410,,0,{},i0huumr,False,t3_tcmtk2,False,True,t1_i0h3kpk,/r/haskell/comments/tcmtk2/what_is_the_point_of_solo_beginner_question/i0huumr/,1647182425,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
972.0,[],False,,tom-md,,,[],,,,text,t2_7b2si,False,False,A Map works be easiest. I'd start there and only change based on actual needs (vs expectations or guesses).,f7916af54aa76e86a56f22a135073e25d7eba01b,True,False,,,,,0,1647181708,,0,{},i0htfzq,False,t3_t3zw0x,False,True,t1_i0h9mdm,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i0htfzq/,1647181721,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
973.0,[],False,,maerten,,,[],,,,text,t2_4fee6,False,False,"Just fyi, there’s a new release of cryptonite that works with ghc9.2",3573130b545f48a2f2d5a950df0002054c2e3012,True,False,,,,,0,1647180913,,0,{},i0hrwq6,False,t3_t8a53f,False,True,t1_hzw3kka,/r/haskell/comments/t8a53f/announce_ghc_922_is_now_available/i0hrwq6/,1647180931,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
974.0,[],False,,AdhesivenessTrue9696,,,[],,,,text,t2_5jzjx1br,False,False,Looks great,6e3e37482d605264790cb75c5985adb3eb04c2c6,True,False,,,,,0,1647174250,,0,{},i0hgtz4,False,t3_tcjwvv,False,True,t3_tcjwvv,/r/haskell/comments/tcjwvv/haskell_almost_standard_libraries_is_now_complete/i0hgtz4/,1647174266,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
975.0,[],False,,SleezyROM,,,[],,,,text,t2_7meizuh9,False,False,"The consumer is actually spawned off with Pipes.Concurrent, and exists solely to listening for broadcast messages. Maybe forever is over kill but for my simple proof of concept it's fine.",ff310ad0c6ba59f253f75c00fff82e359aed586d,True,False,,,,,0,1647172962,,0,{},i0hf1xe,True,t3_td22b3,False,True,t1_i0hbjdf,/r/haskell/comments/td22b3/question_from_a_beginner_is_liftio_a_code_smell/i0hf1xe/,1647172974,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
976.0,[],False,,affinehyperplane,,,[],,,,text,t2_12xogr,False,False,"Cool book, but I think it is mostly unrelated to property-based testing (which was my first thought when reading the title). Rather,

&gt; the goal is to design algorithms that decide whether their input satisfies a predetermined property in sublinear time, or even in constant time.

which is interesting, but for property-based testing, the part which is usually more challenging is coming up with good generators for your test data, and not how to design faster ways of testing the desired (generally rather simple) properties of the generated test data.",24695b4f997d45ef158edacdc14369ff3182de07,True,False,,,,,0,1647172683,,0,{},i0heos5,False,t3_td4xbd,False,True,t3_td4xbd,/r/haskell/comments/td4xbd/property_testing_textbook/i0heos5/,1647172695,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
977.0,[],False,,r3dnaz,,,[],,,,text,t2_2ornf0zo,False,False,"\&gt; Googling

i think you misspelled ""hoogling"" there. https://hoogle.haskell.org/?hoogle=Solo",22ee3f3e7675ed9fb79a254f997ee42c0327d5c3,True,False,,,,,0,1647172346,,0,{},i0he8yu,False,t3_tcmtk2,False,True,t3_tcmtk2,/r/haskell/comments/tcmtk2/what_is_the_point_of_solo_beginner_question/i0he8yu/,1647172362,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
978.0,[],False,,ocramz_,,,[],,,,text,t2_jaolcjrr,False,False,"Also worth noting that this will block your thread forever. You want the monad to be something that can fork threads, like IO or MonadUnliftIO m =&gt; m ( ... )",10796005f5e25f6f8610220f1365f514d27c9d01,True,False,,,,,0,1647170196,,0,{},i0hbjdf,False,t3_td22b3,False,True,t1_i0h3297,/r/haskell/comments/td22b3/question_from_a_beginner_is_liftio_a_code_smell/i0hbjdf/,1647170211,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
979.0,[],False,,doctahFoX,,,[],,,,text,t2_z6pv3,False,False,"Hello everyone! I have a ""what data structure should I use"" question: I need a structure representing a very simplified version of a heap memory, namely I want the following operations:

1.  insertion at un unspecified point, but the insert operation should return a pointer/index to the position of the inserted value

1. retrieval of a value, using the pointer/index obtained after the insertion

1. removal of a value, using the same pointer/index

I don't want to actually model how memory works, so all values will have the same type and they will occupy a single space in this data structure. (Hence there should always be space to insert a new element)

The two options that came to my mind are `Map`s and `MVector`s (of `Maybe`s, so that removal is efficient), but I don't know if there is some data structure more suited to my request. Also, I have never used `Vector` in Haskell, so I don't really know if it would work lol",9f1d08c0a147d2380b24ad1a027116a8ae5c4a5a,True,False,,,,,0,1647168606,,0,{},i0h9mdm,False,t3_t3zw0x,False,True,t3_t3zw0x,/r/haskell/comments/t3zw0x/monthly_hask_anything_march_2022/i0h9mdm/,1647168620,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
980.0,[],False,,Goheeca,,,[],,,,text,t2_97s0g,False,False,[`Int#`](https://downloads.haskell.org/~ghc/9.2.2/docs/html/users_guide/exts/primitives.html#unboxed-types) hash sign at the end typically indicates that.,5dc0de8bccc5b16e7422f15f70689a60cf621c23,True,False,,,,,0,1647164868,,0,{},i0h53q7,False,t3_tcmtk2,False,True,t1_i0h2493,/r/haskell/comments/tcmtk2/what_is_the_point_of_solo_beginner_question/i0h53q7/,1647164883,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
981.0,[],False,,on_hither_shores,,,[],,,,text,t2_jnsj1me6,False,False,float `a` out = move the binding `a = some stuff` to an enclosing scope,4eddb15afd92cfb9a5850034dd907f5e390d5217,True,False,,,,,0,1647163752,,0,{},i0h3rkg,False,t3_td22b3,False,True,t1_i0h2zug,/r/haskell/comments/td22b3/question_from_a_beginner_is_liftio_a_code_smell/i0h3rkg/,1647163768,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
982.0,[],False,,TechnoEmpress,,,[],,,,text,t2_8nmmm9k7,False,False,"Before `Solo` existed, we had a multitude of similarly-named 1-tuples like https://hackage.haskell.org/package/postgresql-simple-0.6.4/docs/Database-PostgreSQL-Simple.html#t:Only for a variety of purposes. 
The documentation of `Only` is actually quite clear on its purpose.",a4d61c5dfe6b9aa0d52ee69ff9608f331e909328,True,False,,,,,0,1647163589,,0,{},i0h3kpk,False,t3_tcmtk2,False,True,t3_tcmtk2,/r/haskell/comments/tcmtk2/what_is_the_point_of_solo_beginner_question/i0h3kpk/,1647163602,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
983.0,[],False,,CoBuddha,,,[],,,,text,t2_12byxs,False,False,what do you mean by that?,01d87fbfd96ba1cee9eb50cb208366ad5de88eec,True,False,,,,,0,1647163356,,0,{},i0h3b0a,True,t3_tc7g4q,False,True,t1_i0h22hj,/r/haskell/comments/tc7g4q/any_haskelllike_languages_with_native_frp/i0h3b0a/,1647163369,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
984.0,[],False,,SleezyROM,,,[],,,,text,t2_7meizuh9,False,False,"That makes sense, my imperative programming brain kicks in sometimes and I simply blank on when I can create another monad.",5e5bd34e531d9c08b5a12015bfff790a908c9fb5,True,False,,,,,0,1647163150,,0,{},i0h3297,True,t3_td22b3,False,True,t1_i0h2ggw,/r/haskell/comments/td22b3/question_from_a_beginner_is_liftio_a_code_smell/i0h3297/,1647163163,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
985.0,[],False,,SleezyROM,,,[],,,,text,t2_7meizuh9,False,False,"Thanks for the tip! What exactly do you mean by ""float them out""?",6cfaf79a7857f337be7b6f5b4c272d746a19459f,True,False,,,,,0,1647163095,,0,{},i0h2zug,True,t3_td22b3,False,True,t1_i0h0ezp,/r/haskell/comments/td22b3/question_from_a_beginner_is_liftio_a_code_smell/i0h2zug/,1647163105,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
986.0,[],False,,nxnt,,,[],,,,text,t2_we1z6qx,False,False,"As u/bss03 pointed out, you can combine some of your liftIO call.

Something like:
```hs
a &lt;- liftIO b
liftIO c
d &lt;- liftIO $ e
liftIO f
```

can be converted into:
```hs
liftIO $ do
    a &lt;- b
    c
    d &lt;- e
    f
```",7f76e52dac040cc1c07f49fabaf18520511657a3,True,False,,,,,0,1647162644,,0,{},i0h2ggw,False,t3_td22b3,False,True,t3_td22b3,/r/haskell/comments/td22b3/question_from_a_beginner_is_liftio_a_code_smell/i0h2ggw/,1647162659,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
987.0,[],False,,CoAnalyticSet,,,[],,,,text,t2_8hsjqz5m,False,False,I don't understand what is an unboxed type then,2a2b6a7700e4a78ae367a1355794474e3a045411,True,False,,,,,0,1647162363,,0,{},i0h2493,True,t3_tcmtk2,False,True,t1_i0h0i08,/r/haskell/comments/tcmtk2/what_is_the_point_of_solo_beginner_question/i0h2493/,1647162374,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
988.0,[],False,,ShalokShalom,,,[],,,,text,t2_gehcq,False,False,"Yeah, that's making a case for the DSL principle",66c8bc5fc76ca227d7259b794630c49e106c8a4e,True,False,,,,,0,1647162322,,0,{},i0h22hj,False,t3_tc7g4q,False,True,t1_i0gj8p9,/r/haskell/comments/tc7g4q/any_haskelllike_languages_with_native_frp/i0h22hj/,1647162334,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
989.0,[],False,,nxnt,,,[],,,,text,t2_we1z6qx,False,False,"You can convert something like:
```
a &lt;- liftIO $ b
liftIO c
liftIO d
```
to
```
liftIO $ do
    a &lt;- b
    c
    d
```",ceaadc2f45617cd44fd974325442a5c06cf5581b,True,False,,,,,0,1647162246,,0,{},i0h1z1z,False,t3_td22b3,False,True,t3_td22b3,/r/haskell/comments/td22b3/question_from_a_beginner_is_liftio_a_code_smell/i0h1z1z/,1647162263,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
990.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"`Int` is a pointer.  `String` is a pointer, to a singly-linked list of `Char`s which are also pointers.",59d2cf7323f18f62b117805f7eb214dbb519126f,True,False,,,,,0,1647161024,,0,{},i0h0i08,False,t3_tcmtk2,False,True,t1_i0gp0nw,/r/haskell/comments/tcmtk2/what_is_the_point_of_solo_beginner_question/i0h0i08/,1647161039,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
991.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"Your code isn't formatted well for me (I'm on old reddit), but it looks like you could combine some of the liftIO calls, possibly even float them out.

But, I wouldn't say liftIO in general is code smell; it's barely different from using (other) mtl-style type classes and their members.",44072b9583603b290be2abcf8303400e04520c43,True,False,,,,,0,1647160953,,0,{},i0h0ezp,False,t3_td22b3,False,True,t3_td22b3,/r/haskell/comments/td22b3/question_from_a_beginner_is_liftio_a_code_smell/i0h0ezp/,1647160970,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
992.0,[],False,,bss03,,,[],,,,text,t2_e3mbb,False,True,"I'd say ""base"" is slim compared to the Python Standard Library.  Pretty sure it's even smaller than the ES6 standard library -- but it is very different so it's hard to judge the relative sizes of the non-overlapping parts.

What's actually in the report is even smaller than that, and is smaller than the vast majority of languages.  Comparable to the C99 standard libraries.",032a5126e1939b696ecad1e5c79925dfff1f9cc4,True,False,,,,,0,1647160705,,0,{},i0h04gh,False,t3_tcjwvv,False,True,t1_i0gs0fq,/r/haskell/comments/tcjwvv/haskell_almost_standard_libraries_is_now_complete/i0h04gh/,1647160717,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
993.0,[],False,,imihnevich,,,[],,,,text,t2_gtbhi7wu,False,False,"&gt; must be eligible to work in the US
I'm in Ukraine, I'm not sure my hours would fit",74d9b3c7c6417054c48de1acb771052eae0564e9,True,False,,,,,0,1647159708,,0,{},i0gyx3v,False,t3_tbrm72,False,True,t1_i0dvbd8,/r/haskell/comments/tbrm72/associate_level_haskellelm_job/i0gyx3v/,1647159719,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
994.0,[],False,,tomejaguar,,,[],,,,text,t2_45sug,False,False,"Sure, but firstly it's not particularly slow in the first place and secondly it's not clear there's a single transition between working and non-working. I want to find the most recent one.",09742bd0981b9e43883b82a04767782384b4c897,True,False,,,,,0,1647156053,,0,{},i0guesl,False,t3_tbn46e,False,True,t1_i0gceip,/r/haskell/comments/tbn46e/out_of_memory_when_building_productprofunctors/i0guesl/,1647156068,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
995.0,[],False,,Akangka,,,[],,,,text,t2_b0zqvos,False,False,"&gt;Haskell's base library is quite slim

\*chuckles\* no. However, Haskell standard libraries provide advanced features that specifically require Haskell runtime, and common typeclasses.",84f2c2921291b4056a4fe262b8233c75059b19fc,True,False,,,,,0,1647154204,,0,{},i0gs0fq,False,t3_tcjwvv,False,True,t3_tcjwvv,/r/haskell/comments/tcjwvv/haskell_almost_standard_libraries_is_now_complete/i0gs0fq/,1647154220,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
996.0,[],False,,brandonchinn178,,,[],,,,text,t2_ognt1qc,False,False,"As much as possible, I'd try to break up the test into two test cases. Most of the time, it works out much better that way, e.g. if for certain inputs you know the result is one way.

But if thats not possible, I would do something similar to the other commenter, but more concrete:

    testSometimesEqual :: [Double] -&gt; Bool
    testSometimesEqual xs = percentTrue (zipWith (==) (map f xs) xs) &gt; 0.1

    testSometimesLess :: [Double] -&gt; Bool
    testSometimesLess xs = percentTrue (zipWith (&lt;) (map f xs) xs) &gt; 0.6

    percentTrue :: [Bool] -&gt; Double
    percentTrue xs = length (filter id xs) / length xs",8989d76b8ce1050abb048ae625f35262e2f1a3bc,True,False,,,,,0,1647152354,,0,{},i0gpfrt,False,t3_tcwird,False,True,t3_tcwird,/r/haskell/comments/tcwird/sometimes_for_quickcheck_verify_that_an/i0gpfrt/,1647152366,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
997.0,[],False,,CoAnalyticSet,,,[],,,,text,t2_8hsjqz5m,False,False,"I see, thanks! I wasn't even aware that GHC supports boxed types then!",fdca0215023d10d15f34772770a90142782f1117,True,False,,,,,0,1647152067,,0,{},i0gp0nw,True,t3_tcmtk2,False,True,t1_i0g7f3z,/r/haskell/comments/tcmtk2/what_is_the_point_of_solo_beginner_question/i0gp0nw/,1647152082,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
998.0,[],False,,CoBuddha,,,[],,,,text,t2_12byxs,False,False,"Yeah honestly I think it's a sweetspot for nearly all web apps where you have a global ""clock"" and don't want to think about plumbing. I just long for the finer grained control of full FRP for things like realtime (in principle)",b407348eb4f3d56c6240d69cc24a05283c63507e,True,False,,,,,0,1647148317,,0,{},i0gj8p9,True,t3_tc7g4q,False,True,t1_i0f2drg,/r/haskell/comments/tc7g4q/any_haskelllike_languages_with_native_frp/i0gj8p9/,1647148328,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
999.0,[],False,,xdavidliu,,,[],,,,text,t2_57oangqz,False,True,"I'm using ghc on macOS with an M1 macbook pro 14 inch, and I have the exact same problem as OP",3fddd16be8a02a12b152d49db60bf808ee69ea81,True,False,,,,,0,1647146603,,0,{},i0ggfvg,False,t3_ph2ge2,False,True,t3_ph2ge2,/r/haskell/comments/ph2ge2/ghci_problem_with_arrow_key/i0ggfvg/,1647146616,1,False,True,False,haskell,t5_2qh36,r/haskell,public,,0,[],,
